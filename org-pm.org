#+TODO: TODO UNDERWAY | DONE
* Command for loading this file manually
:PROPERTIES:
:ID:       DE05B7A2-2C3F-4AB8-B3AF-E2670087E570
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-babel-load-current-file ()
    (interactive)
    (org-babel-load-file (buffer-file-name (current-buffer))))  
  (global-set-key (kbd "C-c C-=") 'org-babel-load-current-file)
#+END_SRC

#+RESULTS:
: org-babel-load-current-file

* UNDERWAY Variables
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:52>
:END:

** UNDERWAY org-pm-project-components
:PROPERTIES:
:ID:       A8ABC239-E74B-4654-9850-53C8521E50BA
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-components nil
  "Store the projects that each file or its sections belong to.
  For each file it store a list: (full-path project1 project2 ...)")
#+END_SRC

** DONE org-pm-auto-parse
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       03CF07FC-5FD7-46C6-BE11-74C3D339A315
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-auto-parse nil
    "If not nil, automatically parse a org-mode buffer
   for org-pm data before saving it.")
#+END_SRC

** DONE org-pm-auto-copy
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       3AF37A0C-F14A-41A3-B477-5B12696315BE
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-auto-copy nil
  "If not nil, automatically copy file components to a project to the 
  project's source folder before publishing.")
#+END_SRC

** DONE org-pm-project-data-file-path
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       A71224C0-989C-419B-A7B6-2B0CEC64CEE7
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-data-file-path nil
  "Path of file for storing org-publish-project-alist and 
  org-pm-project-components.  If nil, the path is deduced from the existence
  of .emacs.d folder in user's home directory. 
  If .emacs.d exists, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.  
  Create savefile folder if it does not exist.")
#+END_SRC

** DONE org-pm-default-project-name
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       3C9E0229-923D-4527-B2FE-903792AA5452
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-name "org-pm-default"
  "Name of default, auto-generated project.")
#+END_SRC

** DONE org-pm-default-project-org-folder
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       3475B9CF-FDDF-4760-8CF1-FE22DC2AA589
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-org-folder "~/pm-org"
  "Path of folder for source files of default project.")
#+END_SRC

** DONE org-pm-default-project-html-folder
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       92AFE11D-6A08-4D77-A2E9-BF0A196271F8
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-html-folder "~/pm-html"
    "Path of folder for html (published website) files of default project.")
#+END_SRC

** DONE org-pm-default-project-plist
CLOSED: [2013-12-18 Wed 22:16]
:PROPERTIES:
:ID:       7539D61D-95E4-4308-B1C4-F86669E921B7
:END:
#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-plist 
    '(
      :base-extension "org"
      :recursive t
      :publishing-function org-publish-org-to-html
      :headline-levels 5
      :auto-preamble t
    )
  "The defalt properties for publishing a project with html.
  Used to provide initial contents when creating a project plist in 
  org-pm-make-default-project-plist. "
  )
#+END_SRC

** TODO org-pm-project-template-name
:PROPERTIES:
:ID:       9D5B4E5D-90E1-4F32-842D-620B262665AF
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-template-name 
    (concat (file-name-directory (or load-file-name (buffer-file-name)))
            "org-pm-project-template.org")
  "Full path of file containing template of project definition for 
  projects generated automatically with org-pm-make-project-template-file.
  The path is initialized at code loading time by function org-pm-init-project-template-name.
  org-pm-make-project-template-file uses it to make project templates.")
#+END_SRC

* Auxiliary functions
:PROPERTIES:
:DATE:     <2013-12-18 Wed 17:24>
:END:

** DONE Functions for adding, removing and replacing elements in a-lists
CLOSED: [2013-12-19 Thu 09:01]
:PROPERTIES:
:ID:       6F334A92-6B8C-473B-B8C5-1BAFB70F819F
:END:

#+BEGIN_SRC emacs-lisp
  (defun assoc-add (alist key element)
    "Add element to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons element (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key element) (cdr alist)))
          (setq alist (list (list key element))))))
    alist)
  
  (defun assoc-remove (alist key element)
    "Remove element from the sublist of alist whose car is equal to key."
    (when alist
      (let ((sublist (assoc key alist)))
        (when sublist
          (setcdr sublist(remove element (cdr sublist)))
          (if (equal 1 (length sublist)) (setq alist (remove sublist alist))))
        alist)))
  
  (defun assoc-remove-key (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))
  
    ;;; older version
  (defun assoc-remove-key-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))
  
  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
       add (cons key newlist) to alist."
    (setq alist (assoc-remove-key alist key))
    (setq alist (cons (cons key newlist) alist))
    )
  
#+END_SRC

** DONE org-pm-make-default-project-alist
CLOSED: [2013-12-19 Thu 02:12]
:PROPERTIES:
:ID:       29715E74-6E71-43C0-A50C-F312C3173645
:END:
#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-default-project-plist ()
    "Construct default plist for publishing a project in html."
    (let ((plist (copy-sequence org-pm-default-project-plist)))
      (setq plist (plist-put plist :base-directory
                             (file-truename org-pm-default-project-org-folder)))
      (setq plist (plist-put plist :publishing-directory 
                             (file-truename org-pm-default-project-html-folder)))))
#+END_SRC

#+RESULTS:
: org-pm-make-default-project-plist
** DONE org-pm-add-project-file
CLOSED: [2013-12-19 Thu 09:14]
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be copied to a project base directory, add the project name to the list of projects of this file.  The list of projects of files is stored in org-pm-project-components.  

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-project-file (project-name file)
    "In list org-pm-project-components, add the project-name to the list 
  of projects that file bel ongs. "
    (setq org-pm-project-components
          (assoc-add org-pm-project-components file project-name)))
#+END_SRC
 
** TODO org-pm-remove-project-file
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be removed from a project, remove the project name from the list of projects of this file in org-pm-project-components.  (The list of projects of files is stored in org-pm-project-components.)

NOTE: Removing components from projects is more complex than adding, because we should also remove the files of the components from the base directory of the project.  Therefore: org-pm-parse-buffer must remove any files of components that no longer exist.  How to do this?

#+BEGIN_SRC emacs-lisp
  (defun org-pm-remove-project-file (project-name file)
    "In list org-pm-project-components, add the project-name to the list 
  of projects that file belongs. "
    (setq org-pm-project-components
          (assoc-add org-pm-project-components file project-name)))
#+END_SRC
 

** TODO org-pm-save-projects-and-components
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       E3ED5198-9807-4051-88E2-4A9A50A0FC7A
:END:

#+BEGIN_SRC emacs-lisp
(defun org-pm-save-projects-and-components ()

)
#+END_SRC

** TODO org-pm-add-project-to-file-header
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       3E557B48-9700-4BEE-9D72-D4AC276DCF9C
:END:

#+BEGIN_SRC emacs-lisp
(defun org-pm-add-project-to-file-header (project-name)

)
#+END_SRC

** TODO org-pm-get-file-projects
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       54A8502C-CC61-4F6E-9CEB-F58EE65B58F4
:END:

Get list of all projects to which this file is published in its entirety. (Not projects to  which any of its sections are published.)

To get the list, look in 2 places: 

1. Project names defined by header-type property (=#+PROJECT:=) in any place of the file.  Several such lines may exist.  Collect all projects named there.
2. Project definition sections that have the tag =include-this-file=. (See reference on how project definition sections are defined.)

#+BEGIN_SRC emacs-lisp
(defun org-pm-get-file-projects ()

)
#+END_SRC

** TODO org-pm-get-section-projects
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       02A9DD60-795A-462D-A803-91E8D719560B
:END:

Get list of all projects to which any individual sections in the file should be copied. Such projects Projects are named by tags in sections.  The tags must be enclosed in underscores "_". For example, if a section has the tag =_blog_= it will be copied to be published in project named =blog=. 

#+BEGIN_SRC emacs-lisp
(defun org-pm-get-section-projects ()

)
#+END_SRC

** DONE org-pm-make-project-template-file
CLOSED: [2013-12-19 Thu 02:12]
:PROPERTIES:
:ID:       36439CB5-E875-4E45-B595-5116888C9DCA
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-project-template-file (project)
    "Read file containing template of project definition for 
    projects generated automatically with org-pm-make-project-template-file,
    from the synonymous file in the org-pm project source
    code folder.  Replace relevant parts of the template with 
    information specific to the project.  
    Finally, save the template the project's base-directory."
    
    ;; Consider using with-temp-buffer for constructing the template file contents
  
    (save-excursion
      (find-file org-pm-project-template-name)
      (let* ((filename (file-name-nondirectory org-pm-project-template-name))
             (plist (cdr project))
             (path (concat (plist-get plist :base-directory) "/" filename)))
        (unless (file-exists-p path)
          (beginning-of-buffer)
          (replace-string "PROJECTNAME" (car project))
          (beginning-of-buffer)
          (replace-string "BASEDIRECTORY" (plist-get plist :base-directory))
          (beginning-of-buffer)
          (replace-string "PUBLISHINGDIRECTORY" (plist-get plist :publishing-directory))
          (beginning-of-buffer)
          (replace-string "EXCLUDEFILE" filename)
          (write-file path)
          ;; leave buffer open for edits ?
          ;; (kill-buffer (current-buffer))
          ))))
  
  ;; (org-pm-make-project-template-file "test")
#+END_SRC

** TODO functions operating on org-pm-project-components

*** Add a project to a file component

*** Add a project to a section component

*** Remove a project from a file component

*** Remove a project from a section component




* IMPORTANT CONSIDERATIONS!!!: CONSISTENCY: Cleaning up duplicate links and dead projects+files

1. Some sections may have duplicate IDs, created by copy-pasting sections. Must clean this up or else both link and copying errors will happen.  Registering duplicates across all projects and checking them seems a manageable task.

2. When a project definition is copied or renamed, this may result in having duplicate definitions, i.e. multiple project definitions with the same name in different places.  Which is the one to work with. 

3. When a project definition is renamed or removed, the one stored under its previous name becomes orphaned. What to do?

4. When a project component is deleted or moved to another project, or when the project or folder or name of the file where it should be copied changes, then the old file becomes orphaned.   What to do?

Which of these are important and feasible to automate?

No. 1 above seems both not too complex to check and essential to keep always consistent. 

No. 2 is also possible to check as soon as it happens, because the moment a new project gets defined one can check if the already existing definition is in the same file, and ask for the user to choose one of the two.

No. 3 could be delegated to commands that a user can call independently of the main specification and publishing process. 

No. 4 could be handled like No. 3.

* Main functions and commands
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:16>
:END:

** New org-pm-parse-buffer draft
:PROPERTIES:
:DATE:     <2013-12-20 Fri 21:10>
:ID:       D7E1FC11-2681-47D3-B43A-E24F7EE5A215
:END:

New version, differnt approach.

Scan file to do several things: 

1. Build list of all IDs of nodes that contain project definitions
2. Check for duplicates IDs. Ask to resolve them.
3. Check for duplicate projects under diffent IDs.  Ask to resolve them.
4. Build the project definitions and add them to =org-publish-project-alist=.
5. Build list of all IDs of nodes that are components of projects.
6. Check for duplicates across all files and projects.  Ask to resolve them.
7. Save list of project component section IDs and file paths to =org-pm-project-components=.
8. Save =org-publish-project-alist= and =org-pm-project-components=.

Refining, towards implementation: 



#+BEGIN_SRC emacs-lisp
  (defun d1-org-pm-parse-file ()
    "DRAFT Dec 20, 2013 (9:11 PM)"
    ()
  )
#+END_SRC


** old org-pm-parse-buffer notes 

This command parses the current  in order to do 3 things: 

1. Create project definitions. (org-pm-make-projects)
2. Find which parts of the file are stored in which project, and store the results in org-pm-project-components. (org-pm-make-component-project-list)
3. Save the resulting configurations by writing =org-publish-project-alist= and =org-pm-project-components= to the file whose path is contained in =org-pm-project-data-file-path=

org-pm-parse-buffer can be called explicitly by the user as a command.

If org-pm-auto-parse is enabled, then it is called automatically whenever a buffer is saved.

*** IMPORTANT: When scanning for which projects are
NOTE: Removing components from projects is more complex than adding, because we should also remove the files of the components from the base directory of the project.  Therefore: org-pm-parse-buffer must remove any files of components that no longer exist.  How to do this?


** org-pm-make-projects
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:00>
:ID:       C4B36522-9597-4911-A829-B2414572DC06
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-default-project-plist ()
    "Construct default plist for publishing a project in html."
    (let ((plist (copy-sequence org-pm-default-project-plist))
          (root (file-name-directory (buffer-file-name (current-buffer)))))
      (plist-put plist :base-directory (concat root "org"))
      (plist-put plist :publishing-directory (concat root "html"))))
  
  ;; FIXME: REDOING HERE see -buggy
  (defun org-pm-make-projects ()
    "Construct the projects for all project definitions found in current file.
  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_DEFS.
  Note about project definition node-IDs:  
  Section IDs of project definitions are used only as links 
  to point to the position in the file where a project definition is, not to identify
  a project.  A project is identified by its name.  Therefore: 
  The node-id of a project is set to <full-file-path>::#<section id>.
  When a duplicate section id is found in a definition, it is replaced by a new one, 
  and the new id is stored in the project."
    (let ((template (org-pm-make-default-project-plist))
          entry-checklist level levels ids projects)
      
      (org-map-entries 
       '(let
            ((entry (cadr (org-element-at-point))))
          (message "ENTRY: %s" entry)
          (when (member "PROJECT_DEFS" (plist-get entry :tags))
            (setq level (+ 1 (plist-get entry :level)))
            (setq levels (cons level levels))
            (setq entry-checklist
                  (cons (list (plist-get entry :raw-value)
                              (format "newly set level %s" level)
                              levels
                              (plist-get entry :tags)
                              )
                        entry-checklist)))
          (setq entry-checklist 
                (cons (list
                       (message "level: %s" level)
                       (message "levels: %s" levels)
                       (message "eq level %s" (equal (car levels) (plist-get entry :level)))
                       (message "title: %s" (plist-get entry :raw-value))
                       )
                      entry-checklist))
          (if (equal (car levels) (plist-get entry :level))
              (setq projects (cons (org-pm-parse-project-def entry template) projects)))
          )
       "PROJECT_DEFS")
      ;; entry-checklist
      projects
      ))
  
  ;; FIXME: nested org-map-entries results in repeated parsing of same nodes. 
  ;; Therefore redoing this above. 
  (defun org-pm-make-projects-buggy ()
    "Construct the projects for all project definitions found in current file.
  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_DEFS."
    (interactive)
    (save-excursion
      (save-restriction
        (widen)
        (org-pm-check-project-config-nodes)
        (let
            (project-def
             id-list
             id
             (template (org-pm-make-default-project-plist))
             (supernodes
              (org-map-entries '(cadr (org-element-at-point)) "PROJECT_DEFS"))
             project-def-list tags begin level)
          (dolist (node supernodes)
            (cond ((and
                    (plist-get node :tags)
                    (setq begin (plist-get node :contents-begin)))
                   (setq level (+ 1 (plist-get node :level)))
                   (save-excursion
                     (save-restriction
                       (narrow-to-region begin (plist-get node :contents-end))
                       (dolist 
                           (proj-node (org-map-entries '(cadr (org-element-at-point))))
                         (message "check: %s - %s" (org-id-get-create) id-list)
                         (cond ((equal level (plist-get proj-node :level))
                                (setq id (org-id-get-create))
                                (when (member id id-list)
                                  (error "DUPLICATE ID FOUND %s %s"
                                         id
                                         id-list
                                         )) ;; FIXME: Need better error!
                                (setq id-list (cons id id-list))
                                (setq project-def
                                      (org-pm-parse-project-def proj-node template))
                                (push project-def 
                                      project-def-list)))))))))
          project-def-list))))
  
  (defun org-pm-check-add-projects (projects)
    "Check each project in projects: If it is defined in a component with a different ID,
  then ask user to select which project to keep. 
  NOTE: 
        Possibly offer to remove project definitions?  
        Offer to remove projects after checking if they are in a different place?
        Or post info about replaced projects so that user can decide how do deal with them?
        The posting can be done one project at a time.  No need to build a list."
    (dolist (project projects) (org-pm-query-select-project project)
      (let ((duplicate (assoc (car project) org-publish-project-alist)))
        (if duplicate (setq project (org-pm-query-select-project project duplicate)))
        (org-pm-add-project project))))
  
  (defun org-pm-query-select-project (new-project old-project)
    "Check if new project definition is from a different source than old-project.
  If yes, then ask the user which of the project definitions to keep.
  Post info about the rejected definition so that user can remove or edit it.
  Return the selected project so that it is added by org-pm-add-project,
  replacing the previous entry for this project."
    (let ((selection new-project))
      (unless (equal (plist-get (cdr new-project) :source-id) 
                     (plist-get (cdr old-project) :source-id))
        (setq selection (must-write-the-code-for-query-selection new-project old-project))
        (must-write-the-code-for-message-about-rejected
         (if (eq selection new-project) old-project new-project)))
      selection))
  
  (defun org-pm-add-project (project)
    "Add project to org-pm-project-alist.
  If previous project with same name exist, replace it."
   (setq org-publish-project-alist 
         (assoc-replace org-publish-project-alist (car project) (cdr project))))
  
  (defun org-pm-check-project-config-nodes ()
    "Check if a node tagged POJECT_CONFIGS has invalid content before first subnode."
    (org-map-entries 
     '(let
          (begin (node (cadr (org-element-at-point))))
        (if (and
             (setq begin (plist-get node :contents-begin))
             (member "PROJECT_DEFS" (plist-get node :tags))
             )
            ;; only works with if statement in the following way. Why?
            (if (equal 0 (string-match 
                          "\\*+ " 
                          (buffer-substring-no-properties begin (plist-get node :contents-end))))
                "ok"
              (error (format 
                      "ERROR: Node named '%s' should be empty before first subnode.\n%s"
                      (plist-get node :raw-value)
                      "Please remove all content before first subnode.")))
          ))
     "PROJECT_DEFS"))
  
  (defun org-pm-parse-project-def (proj-node template)
    "Return a project definition plist for the node represented by proj-node
  org-element plist."
    (let ((pdef (copy-sequence template))
          (pname (plist-get proj-node :raw-value))
          (begin (plist-get proj-node :contents-begin)))
      (setq pdef (plist-put pdef :project-name pname))
      (setq pdef (plist-put pdef :node-id (org-id-get-create)))
      (setq pdef (plist-put pdef :node-filename
                            (buffer-file-name (current-buffer))))
      (cond 
       (begin
        (save-excursion
          (save-restriction
            (narrow-to-region begin (plist-get proj-node :contents-end))
            (org-map-entries
             '(let* (
                     (element (cadr (org-element-at-point)))
                     (heading (plist-get element :raw-value))
                     (space (string-match " .*" heading))
                     prop-name prop-value contents-begin)
                (cond
                 (space
                  (setq prop-name (substring heading 0 space))
                  (setq prop-value (eval (read (substring heading space))))
                  (if (and 
                       (equal prop-name "include-containing-file")
                       prop-value)
                      (org-pm-add-component 
                       pname (buffer-file-name (current-buffer)) prop-value)))
                 (t (setq prop-name heading)
                    (setq contents-begin (plist-get element :contents-begin))
                    (if contents-begin
                        (setq 
                         prop-value 
                         (buffer-substring-no-properties 
                          contents-begin
                          (plist-get element :contents-end))))))
                (setq pdef
                      (plist-put pdef (intern (concat ":" prop-name)) prop-value))
                ))))))
      (cons pname pdef)))
  
#+END_SRC

#+RESULTS:
: org-pm-parse-project-def

For test purposes: 
#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c C-x t") 'org-pm-make-projects)
#+END_SRC

#+RESULTS:
: org-pm-make-projects

** org-pm-add-file-to-project:
:PROPERTIES:
:ID:       24187886-5ADA-4263-806B-8655A9813C8B
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-file-to-project ()
    "Add the file of the current buffer to a project selected or input by the user.
      If the project selected/input by the user is not already in the file's project list:
      - If no project of that name exists, request that the project be defined using
      org-pm or other methods.
      - If no project at all exists, then offer to create default project.
      - Add the selected project to the file's list in org-pm-project-components.
      - Save org-pm-project-components.
      - Add the project name to property PROJECT in file's header."
    (interactive)
    (unless (buffer-file-name (current-buffer))
      (error "This buffer is not associated with a file.  Please save first."))
    (let* ((org-completion-use-ido t)
           (projects 
            (if org-publish-project-alist
                (mapcar org-publish-project-alist 'car)
              (list org-pm-default-project-name)))
           (project-name
            (org-icompleting-read "Choose or input a project name: " projects)))
      (if (member project-name (org-pm-get-file-projects))
          (error "This file is already part of project '%s'" project-name))
      (setq project (org-pm-query-make-default-project project-name))
      (org-pm-add-project-to-file-header project-name)
      (org-pm-add-project-file project-name (buffer-file-name (current-buffer)))
      (org-pm-save-projects-and-components)
      (org-pm-make-project-template-file project)
      (message 
       "Added project named: %s to file: %s\nBase directory is: %s\nPublishing directory is: %s"
       project-name
       (file-name-nondirectory (buffer-file-name (current-buffer)))
       (plist-get (cdr project) :base-directory)
       (plist-get (cdr project) :publishing-directory))))
  
  (defun org-pm-query-make-default-project (project-name)
    "Make a project using default settings and project-name as name."
    (unless (y-or-n-p (format "Create project '%s'? " project-name))
      (error "Project creation cancelled."))
    (let (plist)
      (setq plist (org-pm-make-default-project-plist))
      (setq plist
            (plist-put 
             plist :base-directory
             (query-make-folder (plist-get plist :base-directory) 
                                "Base directory:")))
      (setq plist 
            (plist-put 
             plist :publishing-directory
             (query-make-folder (plist-get plist :publishing-directory) 
                                "Publishing directory:")))
      (cons project-name plist)))
  
  (defun query-make-folder (path &optional prompt-string)
    "If folder at path does not exist, then show dialog offering to user 
      the option to create the indicated folder or to choose another path.
      If the path selected does not exist, create folder."
    (setq path (file-truename path))
    (unless prompt-string (setq prompt-string "Folder select or create:"))
    (let ((answer
           (read-file-name
            (format 
             "%s\nSelect or input folder (folder will be created if needed):\n"
             prompt-string)
            path)))
      (unless (equal (file-truename answer) (buffer-file-name (current-buffer))) 
        (setq path answer))
      (unless (file-exists-p path) (make-directory path))
      path))
  
#+END_SRC elisp

#+BEGIN_SRC elisp
  (let ((result
         (read-file-name "test" "~/")))
    (if (equal (file-truename result) (buffer-file-name (current-buffer)))
        "this would be the original default"
      result)
  )
#+END_SRC

#+RESULTS:
: this would be the original default

#+BEGIN_SRC elisp
(query-make-folder "~/pm-org")
#+END_SRC

#+RESULTS:
: ~/Documents/Dev/Emacs/org-publish-meta/org-pm.org

** org-pm-remove-file-from-project:

** org-pm-publish: Select a project to publish from the projects targeted by current buffer. 

Since a file containing org-pm tags can be anywhere outside an org-mode project folder, one cannot use org-publish-current-project to automatically provide the target project based on the file.  Therefore, use =org-pm-publish= instead to select the desired project to publish from a list of projects that are targeted by the current file.

** org-pm-make-projects (called by org-pm-parse-buffer)

** org-pm-make-component-project-list: 

** org-pm-copy-components:

org-pm-copy-components can be called explicitly by the user as a command.

If org-pm-auto-copy is enabled, then it is called automatically whenever a project is published. 

** org-pm-enable-auto: 

** org-pm-disable-auto: 
:PROPERTIES:
:ID:       5D8EF403-7567-4C82-B919-37ED86C3D268
:END:


* Handling links

Open issue in this part: Not clear if org-id will register duplicate links when opening files from projects which contain parts copied from other files through org-pm.  Apart from that, the following approach should work.

** Use unique id for links
:PROPERTIES:
:DATE:     <2013-11-29 Fri 00:12>
:ID:       D9BE6D1C-0139-4A61-9DC1-BAEA24192ED8
:END:

When the org-id packages is installed, and org-id-link-to-org-use-id is set to t, then links created with C-c l (org-store-link) and inserted with C-c C-l (org-insert-link) will work even if the sections containing the links are moved to another file.  Note: the description at http://orgmode.org/manual/Handling-links.html states this, but the description regarding using CUSTOM_ID is a bit short and unclear.  I tried out setting org-id-link-to-org-use-id to t and it works consistently.  I do not use CUSTOM_ID.  

See further more: [[id:F1DBFCAD-39E9-477F-83A5-25FFBEEFD442][Converting links in the files copied to base directories for publication]].

#+BEGIN_SRC elisp
(require 'org-id)
(setq org-id-link-to-org-use-id t)
;; (defvar org-only-store-id-links t)
#+END_SRC

** Converting links in the files copied to base directories for publication
:PROPERTIES:
:DATE:     <2013-12-20 Fri 20:46>
:ID:       F1DBFCAD-39E9-477F-83A5-25FFBEEFD442
:END:

Org-id stores the list of links with their locations in variable =org-id-locations=.  This should be used by org-pm to provide the right paths to links in the files copied to the base directories of projects for publication.


