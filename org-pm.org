#+TODO: TODO UNDERWAY | DONE CANCELLED
#+TITLE: Org-publish-meta: Easy projects for Org-mode
* UNDERWAY Variables
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:52>
:END:

** DONE org-pm-project-data-file-path
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       A71224C0-989C-419B-A7B6-2B0CEC64CEE7
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-data-file-path
    (let ((home (file-truename "~/.emacs.d")))
        (cond
         ((file-exists-p home)
          (setq home (concat home "/savefile"))
          (unless (file-exists-p home) (make-directory home))
          (concat home "/org-pm-project.data.el"))
         (t (concat home "/.org-pm-project.data.el"))))
    "Path of file for storing org-publish-project-alist and
  org-pm-files.  If nil, the path is deduced from the existence
  of .emacs.d folder in user's home directory.
  If .emacs.d exists, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.
  Create savefile folder if it does not exist.")
#+END_SRC

#+RESULTS:
: org-pm-project-data-file-path

** DONE org-pm-file-exports
:PROPERTIES:
:ID:       A8ABC239-E74B-4654-9850-53C8521E50BA
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-file-exports nil
  "List of files copied to projects.
  For each file, store a list starting with the full path of the file, and
  followed by the list of path-project pairs specified in the file.
    (full-path-of-file (path . project1) (path . project2) ...)
  Function org-pm-get-file-project-paths updates this list
  whenever it scans a buffer.
  The value is saved on disc in file specified by org-pm-project-data-file-path")
#+END_SRC

** org-pm-section-exports

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-section-exports nil
    "List of sections of files copied to projects.
  For each file, store a list starting with the full path of the file, and
  followed by the list of section position and sublist path-project pairs
  specified in the file:

    (full-path-of-file
           (position-section-1 (path . project1) (path . project2) ...)
           (position-section-2 (path . project1) (path . project2) ...)
    )
  Function org-pm-get-section-project-paths updates this list
  whenever it scans a buffer.
  The value is saved on disc in file specified by org-pm-project-data-file-path")
#+END_SRC

** DONE org-pm-project-def-duplicates
CLOSED: [2013-12-21 Sat 22:07]

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-def-duplicates nil
    "List of links to files/sections which contains project definitions
  that were overwritten because another definition with the same name was found.
  Auto-saved together with org-publish-project-alist and org-pm-files.
  Used to create org-mode buffer with links to these locations.
  See functions:
  - org-pm-check-add-project
  - org-pm-list-dupicate-project-defs
  - org-pm-list-project-defs
  - pm/edit-duplicate-project-def"
  )
#+END_SRC

#+RESULTS:
: org-pm-project-def-duplicates

** UNDERWAY org-pm-project-template-file-name
:PROPERTIES:
:ID:       9D5B4E5D-90E1-4F32-842D-620B262665AF
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-template-file-name
    (concat (file-name-directory (or load-file-name (buffer-file-name)))
            "org-pm-project-template.org")
  "Full path of file containing template of project definition for
  projects generated automatically with org-pm-make-project-template.
  The path is initialized at code loading time by function org-pm-init-project-template-name.
  org-pm-make-project-template uses it to make project templates.")
#+END_SRC

#+RESULTS:
: org-pm-project-template-file-name

* Auxiliary functions
:PROPERTIES:
:DATE:     <2013-12-18 Wed 17:24>
:END:

** DONE Get header properties
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-get-header-property (property &optional all)
    "Get property from buffer variable.  Returns only fist match except if ALL is defined.
  NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
    (with-current-buffer
        (current-buffer)
      (save-excursion
        (save-restriction
          (save-match-data
            (widen)
            (goto-char (point-min))
            (let (values)
              (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
                (add-to-list 'values (substring-no-properties (match-string 1))))
              (if all
                  values
                (car values))))))))
#+END_SRC

#+RESULTS:
: org-get-header-property

#+BEGIN_SRC elisp
(org-get-header-property "TEST")
#+END_SRC

** Set state of current heading to COMMENT

This function is derived by modifying org-toggle-comment.

#+BEGIN_SRC emacs-lisp
  (defun org-set-comment ()
    "Change the COMMENT state of an entry to COMMENT.
  Do *not* remove COMMENT state if already present.
  This function is derived from org-toggle-coment."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let (case-fold-search)
        (cond
         ((looking-at (format org-heading-keyword-regexp-format
                              org-comment-string))
          ;; if comment was found, then do nothing:
          )
         ((looking-at org-outline-regexp)
          (goto-char (match-end 0))
          (insert org-comment-string " "))))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-;") 'org-set-comment))
#+END_SRC

** DONE Functions for adding, removing and replacing elements in a-lists
CLOSED: [2013-12-19 Thu 09:01]
:PROPERTIES:
:ID:       6F334A92-6B8C-473B-B8C5-1BAFB70F819F
:END:

#+BEGIN_SRC emacs-lisp
  (defun assoc-add (alist key element)
    "Add element to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons element (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key element) (cdr alist)))
          (setq alist (list (list key element))))))
    alist)

  (defun assoc-remove (alist key element)
    "Remove element from the sublist of alist whose car is equal to key."
    (when alist
      (let ((sublist (assoc key alist)))
        (when sublist
          (setcdr sublist(remove element (cdr sublist)))
          (if (equal 1 (length sublist)) (setq alist (remove sublist alist))))
        alist)))

  (defun assoc-remove-key (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))

    ;;; older version
  (defun assoc-remove-key-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))

  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
       add (cons key newlist) to alist."
    (setq alist (assoc-remove-key alist key))
    (setq alist (cons (cons key newlist) alist)))

#+END_SRC

#+RESULTS:
: assoc-replace

** DONE org-pm-add-project-file
CLOSED: [2013-12-19 Thu 09:14]
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be copied to a project base directory, add the project name to the list of projects of this file.  The list of projects of files is stored in org-pm-files.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-project-file (project-name file)
    "In list org-pm-files, add the project-name to the list
  of projects that file bel ongs. "
    (setq org-pm-files
          (assoc-add org-pm-files file project-name)))
#+END_SRC

** TODO org-pm-remove-project-file
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be removed from a project, remove the project name from the list of projects of this file in org-pm-files.  (The list of projects of files is stored in org-pm-files.)

NOTE: Removing components from projects is more complex than adding, because we should also remove the files of the components from the base directory of the project.  Therefore: org-pm-parse-buffer must remove any files of components that no longer exist.  How to do this?

#+BEGIN_SRC emacs-lisp
  (defun org-pm-remove-project-file (project-name file)
    "In list org-pm-files, add the project-name to the list
  of projects that file belongs. "
    (setq org-pm-files
          (assoc-add org-pm-files file project-name)))
#+END_SRC

** DONE org-pm-add-project-to-file-header
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       3E557B48-9700-4BEE-9D72-D4AC276DCF9C
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-project-to-file-header (project-name)
    "Add property PROJECT with value project-name at beginning of file."
    (save-excursion
      (save-restriction
        (widen)
        (beginning-of-buffer)
        (insert (format "#+PROJECT: %s\n" project-name)))))
#+END_SRC

** org-pm-edit-project-template

Edit the file containing the global project template.
Note that edits may cause conflicts when updating org-pm from git.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-edit-project-template ()
    "Edit the file containing the global project template.
  Note that edits may cause conflicts when updating org-pm from git."
    (interactive)
    (find-file org-pm-project-template-file-name))
#+END_SRC

** org-pm-edit-saved-project-data

Edit the file containing the auto-saved data for org-pom.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-edit-saved-project-data ()
    "Edit the file containing the global project data."
    (interactive)
    (find-file org-pm-project-data-file-path))
#+END_SRC

** org-pm-show-project-definition-section

#+BEGIN_SRC emacs-lisp
  (defun org-pm-show-project-definition-section ()
    "Mark all sections tagged PROJECT_DEFS.
    Additionally go to the first section tagged PROJECT_DEFS, if it exists."
    (interactive)
    (let ((defs (org-map-entries '(cadr (org-element-at-point)) "PROJECT_DEFS")))
      (cond
       (defs
         (org-match-sparse-tree nil "PROJECT_DEFS")
         (goto-char (plist-get (car defs) :begin))
         (recenter-top-bottom '(4))
         (message "Showing location of first project definition section."))
       (t (message "No project definitions were found in this file.")))))
#+END_SRC

** DONE org-pm-make-project-template
:PROPERTIES:
:ID:       36439CB5-E875-4E45-B595-5116888C9DCA
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-project-template (&optional project-name no-name-query no-query)
    "Create a project definition template and insert it into current file.
  Input project name, base directory and publishing directory from user.
  Skip input step if called with prefix argument.
  Read file containing template of project definition
  from org-pm-project-template-file-name
  If arguments present, replace relevant parts of the template with
  custom name, base-directory, publishing-directory
  Insert the resulting template in the current file.
  Create the project as well as its static project and component project.
  Store all 3 in org-publish-project-alists.
  Save updated project, file and duplicate lists to disk."
    (interactive "P")
    (let* ((base-directory (file-truename "~/org-pm/"))
           (publishing-directory
            (file-truename "~/Sites/org-pm/"))
           (def-node
             (car (org-map-entries '(cadr (org-element-at-point)) "PROJECT_DEFS")))
           (buffer (get-buffer-create "*def*"))
           plist template-string)
      (unless project-name (setq project-name "org_pm_default"))
      (unless no-name-query
        (setq project-name (read-string "Enter project name: " project-name)))
      (unless no-query
        (setq base-directory (query-make-folder base-directory))
        (setq publishing-directory (query-make-folder publishing-directory)))
      (save-excursion
        (set-buffer buffer)
        (insert-file-contents org-pm-project-template-file-name)
        (beginning-of-buffer)
        (replace-string "PROJECTNAME" project-name)
        (beginning-of-buffer)
        (replace-string "BASEDIRECTORY" base-directory)
        (beginning-of-buffer)
        (replace-string "PUBLISHINGDIRECTORY" publishing-directory)
        (setq template-string (buffer-string))
        (kill-buffer buffer))
      (cond (def-node
             (goto-char (plist-get def-node :begin))
             (end-of-line)
             (insert "\n")
             (org-paste-subtree (+ 1 (plist-get def-node :level)) template-string))
            (t
             (end-of-buffer)
             (insert "\n* COMMENT Project Definitions              :PROJECT_DEFS:\n")
             (org-paste-subtree 2 template-string)))
      (org-id-get-create)
      (org-pm-check-add-project (org-pm-parse-project-def (cadr (org-element-at-point))))
      (org-pm-save-all-project-data)))
#+END_SRC

* Main functions and commands
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:16>
:END:

** Persistence: Saving and loading project data
*** org-pm-load-all-project-data

#+BEGIN_SRC emacs-lisp
  (defun org-pm-load-all-project-data ()
    "Load project alist, project file lists, duplicate project def lists
  from previously saved date on disk."
    (interactive)
    (if (file-exists-p org-pm-project-data-file-path)
        (load-file org-pm-project-data-file-path)))
#+END_SRC

#+RESULTS:
: org-pm-load-all-project-data

*** org-pm-save-all-project-data

#+BEGIN_SRC emacs-lisp
  (defun org-pm-save-all-project-data ()
    "Load project alist, project file lists, duplicate project def lists
  from previously saved date on disk."
    (interactive)
    (dump-vars-to-file
     '(org-publish-project-alist
       org-pm-file-exports
       org-pm-section-exports
       org-pm-project-def-duplicates)
     org-pm-project-data-file-path))

  (defun dump-vars-to-file (varlist filename)
    "simplistic dumping of variables in VARLIST to a file FILENAME"
    (save-excursion
      (let ((buf (find-file-noselect filename)))
        (set-buffer buf)
        (erase-buffer)
        (dump varlist buf)
        (save-buffer)
        (kill-buffer))))

  (defun dump (varlist buffer)
    "insert into buffer the setq statement to recreate the variables in VARLIST"
    (loop for var in varlist do
          (print (list 'setq var (list 'quote (symbol-value var)))
                 buffer)))
#+END_SRC

** Creating and managing project definitions

*** org-pm-reset-project-list / org-pm-clear-project-defs

#+BEGIN_SRC emacs-lisp
  (defun org-pm-reset-project-list ()
    "Set org-publish-project-alist to nil.  Save"
    (interactive)
    (cond ((y-or-n-p "Really erase all projects and save?")
           (setq org-publish-project-alist)
           (org-pm-save-all-project-data))))
#+END_SRC

*** DONE org-pm-make-projects
#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-projects (&optional do-not-save-now)
    "Construct the projects for all project definitions found in current file.
  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_DEFS.
  Note about project definition node-IDs:
  Section IDs of project definitions are used only as links
  to point to the position in the file where a project definition is, located.
  They do nod identify a project.  A project is identified by its name.
  Therefore:
  The node-id of a project is set to <full-file-path>::#<section id>.
  When a duplicate section id is found in a definition, it is replaced by a new one,
  and the new id is stored in the project."
    (interactive)
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let (
          ;; abandoning template IZ Jan 5, 2014 (6:28 PM)
          ;; (template (org-pm-make-default-project-plist))
          levels id ids projects)
      (org-map-entries
       '(let
            ((entry (cadr (org-element-at-point))))
          (if (member "PROJECT_DEFS" (plist-get entry :tags))
              (setq levels (cons (+ 1 (plist-get entry :level)) levels)))
          (when (equal (car levels) (plist-get entry :level))
            (setq id (org-id-get-create))
            (when (member id ids)
              (org-delete-property "ID")
              (setq id (org-id-get-create))
              (setq entry (plist-put entry :ID id)))
            (setq ids (cons id ids))
            ;; (setq projects (cons (org-pm-parse-project-def entry template) projects))
            (setq projects (cons (org-pm-parse-project-def entry) projects))
            ))
       "PROJECT_DEFS")
      (mapcar 'org-pm-check-add-project projects)
      (unless do-not-save-now (org-pm-save-all-project-data))
      (message "Org-pm defined %d projects" (length projects))))
#+END_SRC

*** org-pm-parse-project-def

#+BEGIN_SRC emacs-lisp
  (defun org-pm-parse-project-def (proj-node &optional template)
    "TEmp note: template is no longer used IZ Jan 5, 2014 (6:27 PM)
  Create a project definition list based on the contents of the
  section described in proj-node plist. Convert headings
  to property names and contents to their values.
  Add useful identification data.
  Argument template is a plist with additional properties,
  but may be left out if the section contains all the properties needed
  to define the project."
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let (
          ;; (pdef (copy-sequence template))
          pdef
          (pname (plist-get proj-node :raw-value))
          (begin (plist-get proj-node :contents-begin))
          (node-id (plist-get proj-node :ID))
          (file-name (buffer-file-name (current-buffer))))
      (setq pdef (plist-put pdef :project-name pname))
      (setq pdef (plist-put pdef :node-id node-id))
      (setq pdef (plist-put pdef :node-filename file-name))
      (setq pdef (plist-put pdef :project-id (concat file-name "::#" node-id)))
      (setq pdef (plist-put pdef :last-updated (format-time-string "[%Y-%m-%d %a %H:%M]")))
      (cond
       (begin
        (save-excursion
          (save-restriction
            (narrow-to-region begin (plist-get proj-node :contents-end))
            (org-map-entries
             '(let* (
                     (element (cadr (org-element-at-point)))
                     (heading (plist-get element :raw-value))
                     (space (string-match " .*" heading))
                     prop-name prop-value contents-begin)
                (cond
                 (space
                  (setq prop-name (substring heading 0 space))
                  (setq prop-value (eval (read (substring heading space))))
                  (if (and
                       (equal prop-name "include-containing-file")
                       prop-value)
                      (org-pm-add-component
                       pname (buffer-file-name (current-buffer)) prop-value)))
                 (t (setq prop-name heading)
                    (setq contents-begin (plist-get element :contents-begin))
                    (if contents-begin
                        (setq
                         prop-value
                         (buffer-substring-no-properties
                          contents-begin
                          (plist-get element :contents-end))))))
                (setq pdef
                      (plist-put pdef (intern (concat ":" prop-name)) prop-value))))))))
      (cons pname pdef)))
#+END_SRC

*** org-pm-check-add-project
#+BEGIN_SRC emacs-lisp
  (require 'dash)
  (defun org-pm-check-add-project (project)
    "Add the project definition contained in plist 'project' to org-publish-project-alist,
  replacing any previously existing definition there.  Before replacing, save any
  previously existing project whose definition is in a different file component in
  the variable org-pm-project-def-duplicates:
  If a project with the same name already exists in org-publish-project-alist,
  and that project has a different ID (file path + section ID), then the previously
  existing project definition is added to the list in org-pm-project-def-duplicates.
  Also create static and combined project components.
  Create alternate ids for the latter, by appending -static and -combined
  to the id of the main project."
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let* ((p-name (car project))
           (p-def (cdr project))
           (prev-proj (assoc p-name org-publish-project-alist))
           (prev-proj-id (plist-get (cdr prev-proj) :project-id))
           (duplicates (assoc p-name org-pm-project-def-duplicates))
           static-project static-project-name combined-project)
      (cond
       ((not prev-proj))
       ((equal prev-proj-id (plist-get p-def :project-id)))
       (t (setq
           org-pm-project-def-duplicates
           (assoc-replace org-pm-project-def-duplicates p-name
                          (add-to-list 'duplicates prev-proj-id)))))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist p-name p-def))
      (setq static-project
            (-flatten
             (-map
              (lambda (pair)
                (list (intern (replace-regexp-in-string "^:static-" ":"
                                                        (symbol-name (car pair))))
                      (cadr pair)))
                       (-filter
                        (lambda (pair) (string-match "^:static-"
                                                     (symbol-name (car pair))))
                        (-partition 2 p-def)))))
      (setq static-project-name (concat "static_" p-name))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist
                           static-project-name static-project))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist
                           (concat "combined_" p-name)
                           (list :components
                                 p-name static-project-name))))
    project)
#+END_SRC

*** org-pm-post-project-def
:PROPERTIES:
:DATE:     <2014-01-05 Sun 19:11>
:END:

Select a project interactively and post its definition.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-post-project-def ()
    "Select a project interactively and post its definition."
    (interactive)
    (let ((project-name
           (grizzl-completing-read
            "Which project? "
            (grizzl-make-index (mapcar 'car org-publish-project-alist)))))
      (message "THIS IS THE DEFINITION OF PROJECT %s:\n%s"
               project-name
               (assoc project-name org-publish-project-alist))))
#+END_SRC

** UNDERWAY org-pm-add-file-to-project:
:PROPERTIES:
:ID:       24187886-5ADA-4263-806B-8655A9813C8B
:END:

Add file to current buffer to project interactively selected or input by user.

If project name input by user does not correspond to an existing project, offer to create that project.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-file-to-project ()
    "Add the file of the current buffer to a project selected or input by the user.
      If the project selected/input by the user is not already in the file's project list:
      - If no project of that name exists, request that the project be defined using
      org-pm or other methods.
      - If no project at all exists, then offer to create default project.
      - Add the selected project to the file's list in org-pm-files.
      - Save org-pm-files.
      - Add the project name to property PROJECT in file's header."
    (interactive)
    (unless (buffer-file-name (current-buffer))
      (error "This buffer is not associated with a file.  Please save first."))
    (let* ((org-completion-use-ido t)
           (projects
            (if org-publish-project-alist
                (mapcar org-publish-project-alist 'car)
              (list org-pm-default-project-name)))
           (project-name
            (org-icompleting-read "Choose or input a project name: " projects)))
      (if (member project-name (org-pm-get-file-projects))
          (error "This file is already part of project '%s'" project-name))
      (setq project (org-pm-query-make-default-project project-name))
      (org-pm-add-project-to-file-header project-name)
      (org-pm-add-project-file project-name (buffer-file-name (current-buffer)))
      (org-pm-save-all-project-data)
      (org-pm-make-project-template project)
      (message
       "Added project named: %s to file: %s\nBase directory is: %s\nPublishing directory is: %s"
       project-name
       (file-name-nondirectory (buffer-file-name (current-buffer)))
       (plist-get (cdr project) :base-directory)
       (plist-get (cdr project) :publishing-directory))))
  #+END_SRC
** query-make-folder
#+BEGIN_SRC emacs-lisp
  (defun query-make-folder (path &optional prompt-string)
    "If folder at path does not exist, then show dialog offering to user
      the option to create the indicated folder or to choose another path.
      If the path selected does not exist, create folder."
    (setq path (file-truename path))
    (unless prompt-string (setq prompt-string "Folder select or create:"))
    (let ((answer
           (read-file-name
            (format
             "%s\nSelect or input folder (folder will be created if needed):\n"
             prompt-string)
            path)))
      (unless (equal (file-truename answer) (buffer-file-name (current-buffer)))
        (setq path answer))
      (unless (file-exists-p path) (make-directory path))
      path))

#+END_SRC

** TODO org-pm-remove-file-from-project:

Remove file from project interactively selected by user.


** org-pm-select-project-from-menu

Present menu for selecting one project from the list of known projects.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-select-project-from-menu ()
    "Present menu for selecting one project from the list of known projects."
    (interactive)
    (let* ((projects
            (-filter
             (lambda (pn) (not (string-match "^combined_" pn)))
             (-map 'car org-publish-project-alist)))
           index selected-project-name)
      (unless projects (setq projects '("new_project")))
      (setq index (grizzl-make-index projects))
      (setq selected-project-name
            (grizzl-completing-read "Choose a project:" index))
      (unless (assoc selected-project-name org-publish-project-alist)
        (org-pm-make-project-template selected-project-name t))
      selected-project-name))
#+END_SRC

** DONE org-pm-add-section-to-project
:PROPERTIES:
:DATE:     <2014-01-13 Mon 07:30>
:END:

Add current section (node) to a project interactively selected or input by user.

If project name input by user does not correspond to an existing project, offer to create that project.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-section-to-project ()
    "Present menu of existing project definitions.
  Add selected project as tag to current section."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let* ((project-name (org-pm-select-project-from-menu))
             (tags (plist-get (cadr (org-element-at-point)) :tags))
             (existing-projects
              (-map (lambda (p) (car (org-pm-parse-prop-or-tag p)))
                    (-filter (lambda (tag) (string-match "^_.*_$" tag)) tags))))
        (unless (member project-name existing-projects)
          (org-set-tags-to (cons (concat "_" project-name "_") tags))))))
#+END_SRC

** DONE org-pm-remove-section-from-project
:PROPERTIES:
:DATE:     <2014-01-13 Mon 08:43>
:END:

Remove current section (node) from a project interactively selected by user.
#+BEGIN_SRC elisp
  (defun org-pm-remove-section-from-project ()
    "Show menu for selecting a project definition from tags of current section.
    Then remove selected project from tags of current section."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let* ((tags (plist-get (cadr (org-element-at-point)) :tags))
             (existing-projects
              (-map (lambda (p) (car (org-pm-parse-prop-or-tag p)))
                    (-filter (lambda (tag) (string-match "^_.*_$" tag)) tags)))
             (index (grizzl-make-index existing-projects))
             (project (grizzl-completing-read "Select project to remove:" index)))
       (org-set-tags-to
        (-reject
         (lambda (p) (equal (car (org-pm-parse-prop-or-tag p)) project)) tags)))))
#+END_SRC

** org-pm-get-section-projects

#+BEGIN_SRC emacs-lisp

  (defun org-pm-get-section-projects ()
    "Return list of projects found in the tags of the current section"
   (save-excursion
     (org-back-to-heading)
     (-map (lambda (p) (car (org-pm-parse-prop-or-tag p)))
           (-filter (lambda (tag) (string-match "^_.*_$" tag))
                    (plist-get (cadr (org-element-at-point)) :tags)))))
#+END_SRC

** org-pm-copy-components-to-projects

- org-pm-copy-components can be called explicitly by the user as a command.
- If org-pm-auto-copy is enabled, then it is called automatically.
- There are two ways to automate the copying:
  1. Copy whenever the file is saved.
  2. Copy whenever the project is published.

Assessment:

Version 1 lengthens the file saving time.
Version 2 lengthens the publishing time.

The accumulated delay of copying project components from all files when publishing may be more distracting than the delay of copying components of a single project.  Additionally, it is better to be able to check the condition of a project at any stage, and to have it updated as soon as a file is saved.  So I start by setting the default to copy components when the file is saved.

*** Variable: flag for reporting (may be removed)
#+BEGIN_SRC emacs-lisp
  ;; Will replace org-pm-register-project-components.

  ;; Review?  Remove? :
  (defvar org-pm-report-after-copying-p t
  "If not-nil, org-pm-copy-components-to-projects will post a report
  of projects not found or of projects targeted when finishing.")
#+END_SRC

*** DONE Construct path of a target file to copy file or section to

Three functions are defined here:

1. =org-pm-parse-component= extracts project, folder and file name strings from a property or tag in an org file, plus the name of the current file and the value of the DATE property, if present.
2. =org-pm-make-target-path= constructs the final path, based on the list containing the project, folder and file, which is produced by =org-pm-parse-component=.
3.

**** org-pm-parse-component
Called by:
- org-pm-get-file-components
- org-pm-get-section-components

Process data obtained from property or tag, and create list of form: (project folder filename). This is then processed by org-pm-make-target-path to make the path used to copy the file.

**** org-pm-make-target-path

Called by
- org-pm-copy-file-components
- org-pm-copy-section-components

Construct path for copying a file or section to, from list (project folder file) received from org-pm-parse-component. This funcion returns a cons pair: (path . path-or-project).  =path= is used for copying.  =path-or-project= for display/menus. If project def not found, path is nil and path-or-project is '<project-name> (not found)'

**** org-pm-make-filename

Called by org-get-section-components.  Converts the title of a section to a filename by replacing non-alphanumeric characters with dashes (=-=).  Also removes trailing timestamp from title.

**** Code

#+BEGIN_SRC emacs-lisp
  (defun org-pm-parse-prop-or-tag (prop-or-tag &optional filename date)
    "Process property or tag, name of file containing component,
  and date property of file or section to provide project, folder, filename strings.
  Split prop-or-tag to project, folder, filename if separated by @.
  Construct blog entry style filename if date is provided.

  If date is provided, convert date into jekyll- (hexo-, etc.) compatible
  blog entry format, and prepend it.
  Entry title 'thoughts-on-pre-processing', with date <2014-01-05 Sun 10:56>
  becomes: '2014-01-05-thoughts-on-pre-processing'

  Do not convert filename from title format.  That is done by function
  org-pm-make-filename, which is called by org-pm-get-section-project-components."

    ;; strip enclosing underscores _
    (setq prop-or-tag (replace-regexp-in-string
                     "^_" "" (replace-regexp-in-string "_$" "" prop-or-tag)))
    ;; replace # by .
    (setq prop-or-tag (replace-regexp-in-string "#" "." prop-or-tag))
    ;; split into project, folder, filename
    ;; and provide "" as folder, filename where @ separators are missing
    (setq prop-or-tag (-take 3 (split-string (concat prop-or-tag "@@") "@")))
    ;; if prop-or-tag had filename, use that instead of filename argument
    (if (> (length (caddr prop-or-tag)) 0) (setq filename (caddr prop-or-tag)))
    ;; provide extension
    (unless filename (setq filename "index"))
    (unless (file-name-extension filename)
      (setq filename (concat filename ".org")))
    ;; if date present, prepend date in jekyll blog-entry format
    (when (and date
               (string-match
                "^<\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                date))
      (setq filename (concat (substring date 1 11) "-" filename)))
    ;; return project, folder, new filename as list
    (setcdr (cdr prop-or-tag) (list filename))
    prop-or-tag)

  ;; Create final path to copy file, from list (project folder file)
  ;; received from org-pm-parse-prop-or-tag.
  ;; Return (path . path-or-project)
  ;; path is used for copying.  path-or-project for display/menus.
  ;; If project def not found, path is nil.

  (defun org-pm-make-target-path (proj-folder-file)
    "Create path of file for copying contents of current buffer to a project.
  Combine base directory + folder + file from list proj-folder-file
  to make target-path.
  Return (path . project-name)
  The car of the result is used to copy the component to the path.
  The cdr of the result (project-name) is used for display and debugging."
    (let* ((pname (car proj-folder-file))
           (project (cdr (assoc pname org-publish-project-alist)))
           (folder (cadr proj-folder-file))
           (slash (if (string-match "/$" folder) "" "/"))
           (target-path
            (if project
                (concat (plist-get project :base-directory)
                        folder slash (caddr proj-folder-file)))))
      (cons target-path pname)))

  ;; Convert title of org-mode section entry into filename
  ;; Used by org-pm-get-section-project-components
  (defun org-pm-make-filename (title &optional date)
    "Convert title of org-mode section entry into filename.
  Remove non alphanumeric characters.
  Replace spaces by dashes (-).
  Strip initial or ending dashes.
  Lowercase everything.
  Strip : mm/dd/yy ... part from the end.
  Entry title:
  'Watching: Sacha_Chua Emacs_chat_with_magnar_sven (emacs_rocks): 12/08/13_14:54:11'
  Becomes:
  'watching-sacha-chua-emacs-chat-with-magnar-sven-emacs-rocks'"
    (let (filename
          (title-date-pos
           (string-match
            ": [[:digit:]]\\{2\\}/[[:digit:]]\\{2\\}/[[:digit:]]\\{2\\}"
            title)))
      (if title-date-pos
          (setq filename (substring title 0 title-date-pos))
        (setq filename title))
      (setq filename (downcase
                      (replace-regexp-in-string
                       "-+" "-"
                       (replace-regexp-in-string "[^[:alnum:]]" "-" filename))))
      (setq filename
            (replace-regexp-in-string
             "^-" "" (replace-regexp-in-string "-$" "" filename)))
      (when (and date
                 (string-match
                  "^<\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                  date))
        (setq filename (concat (substring date 1 11) "-" filename)))
      filename))
#+END_SRC

*** Get list of file components to be copied to projects

**** org-pm-get-file-project-paths

Get all values of file property "PROJECT".  Parse each value, and return a list of paths.
Returns list of the form:

: ((path . projectname) (path . projectname) ... )

Where =path= is the place to copy the file to and =projectname= is the name of the project followed by "undefined project" if the targed project is not defined.

**** org-pm-get-section-project-paths

Get all sections marked with tags that are enclosed in underscore (=_=).  Parse each value and return a list of lists:
((section-position (project folder file) (project folder file) ...)
 (section-position (project folder file) (project folder file) ...)
...)

**** Code
#+BEGIN_SRC emacs-lisp
  (defun org-pm-get-file-project-paths ()
    "Build list of projects-folders-files to export this buffer to.
  The list is created from the list of values of property PROJECT
  that are defined in this buffer.
  The list is passed to org-pm-copy-file-project-paths for copying. "
    (interactive)
    (let* ((fullpath (buffer-file-name (current-buffer)))
           (filename (file-name-nondirectory fullpath))
           (date (org-get-header-property "DATE" nil))
           (components
            (-map (lambda (component)
                    (org-pm-make-target-path
                     (org-pm-parse-prop-or-tag component filename date)))
                  (org-get-header-property "PROJECT" t))))
      ;;  (message "file components for %s are:\n%s" filename components)
      ;; FIXME: TODO: save paths to disc in org-pm save file
      components))

  (defun org-pm-get-section-project-paths ()
    "Build list of projects-folders-files to export sections of this buffer to.
  The list is created from those sections whose tags specify projects,
  i.e . tags enclosed in underscores: _projectname_
  The list is passed to org-pm-copy-section-project-components for copying.
  Each element in the list has the form:
  <start-point of section> (project projectname folder filename)
                           (project projectname folder filename)
                           ... "
    (interactive)
    (let (components)
     (org-map-entries
      '(let* ((node (cadr (org-element-at-point)))
              (pspecs (-filter (lambda (tag) (string-match "^_.*_$" tag))
                               (plist-get node :tags)))
              name date)
         (message "pspecs: \n%s" pspecs)
         (if pspecs
           (let (section-entries)
            (setq name (plist-get node :raw-value))
            (setq date (plist-get node :DATE))
            (dolist (spec pspecs)
              (setq section-entries
                    (cons (org-pm-make-target-path
                           (org-pm-parse-prop-or-tag
                            spec
                            (org-pm-make-filename name)
                            date)) section-entries)))
            (setq components (cons (cons (point) section-entries) components))))))
    ;;  (message "COMPONENTS: \n%s" components)
     ;; FIXME: TODO: save paths to disc in org-pm save file
     components))

  ;;; The next function should be reviewed.  May be scrapped.
  (defun org-pm-get-section-project-targets ()
    "Return list of paths of files to which sections of current file are copied."
    (interactive)
    (let (sections
          (components
           (-map (lambda (clist)
                   (-map (lambda (c) (org-pm-make-displayable-target-path c))
                         clist))
                 (-map (lambda (aclist) (cdr aclist))
                       (org-pm-get-section-project-components)))))
      (message "%s" (-flatten components))
      (-flatten components)))

  ;; pass components for posting (reporting) by calling function


#+END_SRC

*** Copy files / sections to project targets
#+BEGIN_SRC emacs-lisp
  (defun org-pm-export ()
    "Top level function for exporting file and sections to projects.
  Copy both file and any sections specified by properties, tags
  to the designated projects and folders.
  Before copying, re-scan buffer to build list of targets for copying."
    (interactive)
    (save-excursion
      (save-restriction
        (widen)
        (org-pm-export-file-to-projects)
        (org-pm-export-sections-to-projects))))

  (defun org-pm-export-buffer-to-file (path-project)
    "
  path-project has the form (path . project-name).
  If path is not nil, save current buffer to path."
    (let ((path (car path-project)))
      (when path
        (make-directory (file-name-directory path) t)
        (write-region nil nil path))))

  (defun org-pm-export-file-to-projects (&optional paths)
    "Copy entire file to any projects specified by property PROJECT
  Copies the file to targets given in paths.  If paths is nil,
  then get the paths by scanning the current buffer.
  Components is provided by org-pm-get-file-project-paths."
    (interactive)
    (unless paths (setq paths (org-pm-get-file-project-paths)))
    (when paths
      (let ((origin-buffer (current-buffer))
             (target-buffer (get-buffer-create "*org-pm-copy-buf*")))
        (set-buffer target-buffer)
        (insert-buffer origin-buffer)
        (dolist (path paths) (org-pm-export-buffer-to-file path))
        (kill-buffer target-buffer)))
    ;; (message "%s exported to paths:\n %s" (buffer-file-name) paths)
    paths)

  (defun org-pm-export-sections-to-projects (&optional sections-with-paths)
    "Copy sections of this file to paths specified by tags."
    (interactive)
    (unless sections-with-paths
      (setq sections-with-paths (org-pm-get-section-project-paths)))
    (let ((buffer (current-buffer)))
     (dolist (section sections-with-paths)
       (org-pm-export-1-section-to-projects section buffer))))

  (defun org-pm-export-1-section-to-projects (section-with-paths origin-buffer)
    "Copy section to temporary buffer, then save it to all
  paths in the rest of section-with-paths."
    (let ((target-buffer (get-buffer-create "*org-pm-copy-buf*")))
      (set-buffer origin-buffer)
      (goto-char (car section-with-paths))
      (org-copy-subtree)
      (set-buffer target-buffer)
      (org-paste-subtree 1)
      (dolist (path-project (cdr section-with-paths))
        (org-pm-export-buffer-to-file path-project))
      (kill-buffer target-buffer)
      (message "exported section: %s" section-with-paths)))

  (defun org-pm-save-buffer (specs buffer)
  "Save current buffer "
    (let ((target-path (org-pm-make-target specs)))
      (make-directory (file-name-directory target-path) t)
      (write-region nil nil target-path)))


#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-target (specs)
    (let* ((project-name (car specs))
           (folder (cadr specs))
           (slash (if (string-match "/$" folder) "" "/"))
           (project (assoc project-name org-publish-project-alist)))
      (cond (project
             (add-to-list '*org-pm-updated-projects* project-name)
             (concat (plist-get (cdr project) :base-directory)
                     folder slash (caddr specs)))
            (t
             (add-to-list '*org-pm-missing-projects* project-name)
             nil))))

  (defun org-pm-make-filename-simple (title &optional date)
    "Simple version - to be deleted. See org-pm-make-filenme
  Convert title of entry into filename.
  remove non alphanumeric characters.
  replace spaces by dashes (-).
  lowercase everything.
  if date is provided, convert date into jekyll- (hexo-, etc.) compatible
  blog entry format, and prepend it.
  entry title 'thoughts on [pre-]processing',
  with date <2014-01-05 sun 10:56>
  becomes: '2014-01-05-thoughts-on-pre-processing' "
    (let ((filename
           (downcase
            (replace-regexp-in-string
             "-+" "-"
             (replace-regexp-in-string "[^[:alnum:]]" "-" title)))))
      filename))


  ;; Fix grizzl-completing-read to display custom prompt
  (require 'grizzl)
  (defun grizzl-completing-read (prompt index)
    "Performs a completing-read in the minibuffer using INDEX to fuzzy search.
  Each key pressed in the minibuffer filters down the list of matches."
    (minibuffer-with-setup-hook
        (lambda ()
          (setq *grizzl-current-result* nil)
          (setq *grizzl-current-selection* 0)
          (grizzl-mode 1)
          (lexical-let*
              ((hookfun (lambda ()
                          (setq *grizzl-current-result*
                                (grizzl-search (minibuffer-contents)
                                               index
                                               ,*grizzl-current-result*))
                          (grizzl-display-result index prompt)))
               (exitfun (lambda ()
                          (grizzl-mode -1)
                          (remove-hook 'post-command-hook    hookfun t))))
            (add-hook 'minibuffer-exit-hook exitfun nil t)
            (add-hook 'post-command-hook    hookfun nil t)))
      (read-from-minibuffer (if prompt prompt ">>> "))
      (grizzl-selected-result index)))

#+END_SRC

*** User interaction: Display info, menus etc.

#+BEGIN_SRC emacs-lisp
(defun org-pm-show-target-file-list (&optional file-components section-components)
  "Create a list of paths of all files which the current file and its sections
outputs to.  Present this as a grizzl list for auto-complete search.
Open selected file."
  (interactive)
  (unless file-components
    (setq file-components (org-pm-get-file-project-targets)))
  (unless section-components
    (setq section-components (org-pm-get-section-project-targets)))
  (let* ((target-list
         (mapcar (lambda (t) (cdr t))
                 (append file-components section-components)))
         (index (grizzl-make-index target-list))
         answer)
    ;; (message "%s" target-list)
    (setq answer (grizzl-completing-read "Choose file to open: " index))
    (if (string-match "(undefined project)$" answer)
        (message "No file: %s" answer)
       (find-file answer))))
#+END_SRC

** TODO org-pm-publish: Select a project to publish from the projects targeted by current buffer.
:PROPERTIES:
:ID:       688C2A25-277F-4263-95C9-FFFDA2F15E87
:END:

Since a file containing org-pm tags can be anywhere outside an org-mode project folder, one cannot use org-publish-current-project to automatically provide the target project based on the file.  Therefore, use =org-pm-publish= instead to select the desired project to publish from a list of projects that are targeted by the current file.

** DONE org-pm-list-dupicate-project-defs
CLOSED: [2013-12-22 Sun 12:21]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-duplicate-project-defs ()
    "List project definitions of same name that are found in more than one file or section.
  Do this in a separate org-mode buffer, and provide links to both file and section."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no duplicate project definitions at all.\n!!! ... YAyyy ... !!!"))

    (let ((buffer (get-buffer-create "*org-pm-project-def-duplicates*")))
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "DUPLICATE PROJECT DEFINITIONS")
      (dolist (project org-pm-project-def-duplicates)
        (let ((project-name (car project)))
          (insert "\n** " project-name "\n")
          (dolist (def (cdr project))
            (let ((path-and-id (split-string def "::#")))
              (insert "file: file:" (car path-and-id) "\n")
              (insert "node: " "id:" (cadr path-and-id) "\n")))))
      ))
#+END_SRC

** DONE org-pm-list-project-defs
CLOSED: [2013-12-22 Sun 14:30]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-project-defs ()
    "Build list of projects with links to file and node containing the project definition,
  in a separate org-mode buffer, and provide links to both file and section.
  Also list duplicate project definitions,
  i.e. definitions of same name that are found in more than one file or section.
  Note: static and combined projects created by the system
  are not checked and added as duplicates by org-pm-check-add-project.
  But they are in org-publish-project-alist, which we use for this list.
  So we filter them out."

    (interactive)

    (if (equal 0 (length org-publish-project-alist))
        (error "There are no project definitions at all."))

    (let ((buffer (get-buffer-create "*org-pm-project-definitions*"))
          node-id dir)
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "PROJECT DEFINITIONS")
      (dolist (project (-remove (lambda (proj)
                                  (or (string-match "^combined_" (car proj))
                                      (string-match "^static_" (car proj))))
                                org-publish-project-alist))
        (setq node-id (plist-get (cdr project) :node-id))

        (insert "\n** "
                (car project)
                " (click [[elisp:(org-pm-search-link \""
                (plist-get (cdr project) :project-id)
                "\")][*HERE*]] to edit definition)\n")
        (setq dir (plist-get (cdr project) :base-directory))
        (insert "base dir: [[elisp:(dired\"" dir "\")][" dir "]]\n" )
        (setq dir (plist-get (cdr project) :publishing-directory))
        (insert "publishing dir: [[elisp:(dired\"" dir "\")][" dir "]]\n" )
        (insert "file: file:" (plist-get (cdr project) :node-filename) "\n")
        (insert "node: id:" node-id "\n")
        (let ((duplicates (cdr (assoc (car project) org-pm-project-def-duplicates))))
          (if duplicates
              (dolist (def duplicates)
                (let ((path-and-id (split-string def "::#")))
                  (insert "\n*** duplicate: ")
                  (insert
                   " (click [[elisp:(org-pm-search-link \""
                   def
                   "\")][*HERE*]] to edit)"
                   )
                  (insert "\nfile: file:" (car path-and-id) "\n")
                  (insert "node: " "id:" (cadr path-and-id) "\n")))
            (insert "\nThere no duplicate definitions for this project!\n"))))))
#+END_SRC

#+RESULTS:
: org-pm-list-project-defs

*** DONE org-pm-search-link
CLOSED: [2013-12-22 Sun 18:45]

Currently, links to IDs that are not in org-link-locations are not found by org-mode.  =org-pm-search-link= finds such links by going to the file and then searching for the property with the id of the link.  It is used in org-pm-list-project-defs to enable jumping to links of duplicate project defs.  It can also be used for the same purpose in lists of components.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-search-link (link)
    (let ((file-and-id (split-string link "::#")))
      (find-file (car file-and-id))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr file-and-id)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (recenter-top-bottom 1)
      (message "
  ---> Marked the entire section containing project definition.
  Type C-space C-space to de-select region and deactivate mark.")))
#+END_SRC

#+RESULTS:
: org-pm-search-link

** UNDERWAY pm/edit-duplicate-project-def

Note: Naming this function org-pm-edit-duplicate-project-def disabled the auto-display of selections in the command line.  Something with org-mode recognizing names of functions and changing the meaning of completing-read?

#+BEGIN_SRC emacs-lisp
  (defun pm/edit-duplicate-project-def ()
    "Select a project definition from the list of found duplicates, and
  go to the containing file at the selected location, so as to edit the
  duplicate definition (or to remove it)."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no project definitions to edit."))
    (let ((definitions (mapcar (lambda (p) (car p)) org-pm-project-def-duplicates))
          definition def-address)
      (setq project
            (completing-read "Select project: " definitions nil t (car definitions)))
      (setq definitions (cdr (assoc project org-pm-project-def-duplicates)))
      (setq project
            (completing-read "Select definition: " definitions nil t (car definitions)))
      (setq def-address (split-string project "::#"))
      (find-file (car def-address))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr def-address)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (message "
  Marked the entire section containing duplicate project definition.
  Type C-space C-space to de-select region and deactivate mark")
      ))
#+END_SRC

#+RESULTS:
: pm/edit-duplicate-project-def


* Menu: select org-pm command interactively

#+BEGIN_SRC emacs-lisp
  (defun org-pm-menu ()
    "Select and run an org-pm command from a grizzl-minibuffer menu list."
    (interactive)
    (let* ((commands '(
                       org-pm-load-all-project-data
                       org-pm-list-project-defs
                       org-pm-show-target-file-list
                       org-pm-make-projects
                       org-pm-make-project-template
                       org-pm-copy-all-parts-to-projects
                       ))
           (menu (grizzl-make-index
                 (-map (lambda (c)
                         (replace-regexp-in-string
                          "-"
                          " "
                          (replace-regexp-in-string
                           "^org-pm-" "" (symbol-name c))))
                       commands)))
          selection)
      (setq selection (grizzl-completing-read  "Select command: " menu))
      (eval
       (read (concat
              "(org-pm-"
              (replace-regexp-in-string " " "-" selection)
              ")")))))
#+END_SRC
* Keyboard shortcuts

Note: I use the Hyper-m  (= Mac fn key m) as prefix, because it is not likely to be occupied by other packages.  Users can easily remap.

#+BEGIN_SRC emacs-lisp
  ;; Add org-mode hook for org-pm-key bindings.
  ;; To initialize if present file is compiled after start time, run hook qnow.
  (let ((org-pm-key-bindings
         (lambda ()
           (define-key org-mode-map (kbd "H-m H-m") 'org-pm-menu)
           (define-key org-mode-map (kbd "H-m a") 'org-pm-toggle-auto)
           (define-key org-mode-map (kbd "H-m s") 'org-pm-save-and-update)
           (define-key org-mode-map (kbd "H-m v") 'org-pm-toggle-verbose)
           (define-key org-mode-map (kbd "H-m l") 'org-pm-list-project-defs)
           (define-key org-mode-map (kbd "H-m m") 'org-pm-make-projects)
           (define-key org-mode-map (kbd "H-m c") 'org-pm-copy-components-to-projects)
           (define-key org-mode-map (kbd "H-m t") 'org-pm-make-project-template))))
    (funcall org-pm-key-bindings)
    (add-hook 'org-mode-hook
              org-pm-key-bindings))


#+END_SRC

* COMMENT Project Definitions                                  :PROJECT_DEFS:
** org_pm
:PROPERTIES:
:ID:       5F6A7EFA-7491-49CB-9985-26D53BB17F34
:END:
*** base-directory "/Users/iani2/Documents/Dev/Emacs/org-publish-meta/"
*** base-extension "org"
*** recursive t
*** publishing-directory "/ssh:iani@larigot.avarts.ionio.gr:Sites/org-pm/"
*** publishing-function 'org-html-publish-to-html
*** headline-levels 4
*** auto-preamble t
*** section-numbers nil
*** with-toc t
*** html-preamble t
*** with-author t
*** with-creator t
*** with-emphasize t
*** with-sub-superscript nil
*** with-tables t
*** with-tags t
*** with-tasks t
*** with-todo-keywords nil
*** html-head-include-scripts t
*** with-latex t
*** with-drawers nil
*** html-link-up "{{.}}/"
*** html-link-home "{{.}}/"
*** toc-heading "Contents"
*** html-head
<link href="{{.}}/static/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="{{.}}/static/worg.min.css" rel="stylesheet" type="text/css">
*** html-head-include-default-style nil
*** html-head-include-scripts nil
*** static_base-directory "/Users/iani2/Documents/Dev/Emacs/org-publish-meta/static/"
*** static_publishing-directory "/ssh:iani@larigot.avarts.ionio.gr:Sites/org-pm/static/"
*** static_base-extension "css\\|js\\|less\\|sass\\|php\\|rb\\|py\\|pdf\\|jpg\\|gif\\|png"
*** static_publishing-function 'org-publish-attachment
*** static_recursive t
