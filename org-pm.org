#+TODO: TODO UNDERWAY | DONE CANCELLED
#+TITLE: Org-publish-meta: Easy projects for Org-mode


* DONE Overview: List of Commands

** Six main command categories
There are overall 16 top-level user commands and 1 menu command listing the 16 commands.

The commands are organized into 6 topics/sections:

1. Create and  edit project definitions
2. List project definitions
3. Add/Remove sections to projects
4. Export sections to projects
5. List files exported to projects
6. Save, load, clear, edit data lists


** Commands and Keyboard Shortcuts Table

|--------------------------+---------------------------------------------|
| Shortcut                 | Command                                     |
|--------------------------+---------------------------------------------|
| *MAIN COMMANDS*          |                                             |
|--------------------------+---------------------------------------------|
| H-m H-m                  | org-pm-menu (list all commands, select one) |
| H-m n or H-m p n         | org-pm-insert-new-project                   |
| H-m m or H-m p m         | org-pm-make-projects (current buffer)       |
| C-u H-m m or C-u H-m p m | org-pm-make-projects (all files)            |
| H-m a                    | org-pm-add-section-to-project               |
| H-m r                    | org-pm-remove-section-from-project          |
| H-m e                    | org-pm-export                               |
| H-m P                    | org-pm-publish                              |
|--------------------------+---------------------------------------------|
| *PROJECT DEFINITIONS*    |                                             |
|--------------------------+---------------------------------------------|
| H-m p e or H-m p s       | org-pm-show-project-definition-section      |
| H-m p t                  | org-pm-edit-project-template                |
| H-m p l                  | org-pm-project-def-list |
| H-m p d                  | org-pm-list-duplicate-project-defs          |
| C-u H-m p d              | pm/edit-duplicate-project-def               |
| H-m p p                  | org-pm-post-project-def                     |
|--------------------------+---------------------------------------------|
| *TARGET FILE LISTS*      |                                             |
|--------------------------+---------------------------------------------|
| H-m f                    | org-pm-list-exported-files (current buffer) |
| C-u H-m f                | org-pm-list-exported-files (all)            |
| H-m F                    | org-pm-show-target-file-list                |
|--------------------------+---------------------------------------------|
| *SAVED DATA*             |                                             |
|--------------------------+---------------------------------------------|
| H-m d l                  | org-pm-load-project-data                    |
| H-m d s                  | org-pm-save-project-data                    |
| H-m d r or H-m d c       | org-pm-reset-project-list                   |
| H-m d e                  | org-pm-edit-saved-project-data              |
|--------------------------+---------------------------------------------|

** Global menu with all commands

*** org-pm-menu

Show menu of 16 org-pm commands using grizzl-menu.  Run command selected by user.

** The commands by category
*** Create and edit project definitions

**** org-pm-edit-project-template

Open the file containing the global project template in EMACS for editing.  This template is used to create new projects definitions.

Note that edits may cause conflicts when updating org-pm from git.

**** org-pm-make-project-template -> org-pm-insert-new-project

Create a project definition template and insert it into the current file.
Input project name, base directory and publishing directory from user.
Skip input step if called with prefix argument.

**** org-pm-make-projects

Construct the projects for all project definitions found in current file.

Save the upated org-publish-project-alist.

Project definitions are those nodes which are contained in nodes tagged as PROJECT_DEFS.

**** pm/edit-duplicate-project-def


*** List project definitions

**** org-pm-show-project-definition-section

In the present buffer, mark all sections tagged PROJECT_DEFS.
Additionally go to the first section tagged PROJECT_DEFS, if it exists.

**** org-pm-project-def-list

**** org-pm-list-dupicate-project-defs

**** org-pm-post-project-def


*** Add/Remove sections to projects

**** org-pm-add-section-to-project

**** org-pm-remove-section-from-project


*** Export sections to projects

**** org-pm-export


*** List files exported to projects

**** org-pm-list-exported-files


*** Save, load, clear, edit data lists

**** org-pm-load-project-data

**** org-pm-save-project-data

Save contents of org-publish-project-alist, org-pm-project-def-duplicates, org-pm-section-exports to disk using path stored in org-pm-project-data-file-path.

This function is also called by org-pm-make-projects and org-pm-export.

**** org-pm-reset-project-list

Set org-publish-project-alist to nil.  Save.

**** org-pm-edit-saved-project-data

* DONE Variables
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:52>
:END:

** DONE org-pm-project-data-file-path
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       A71224C0-989C-419B-A7B6-2B0CEC64CEE7
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-data-file-path
    (let ((home (file-truename "~/.emacs.d")))
        (cond
         ((file-exists-p home)
          (setq home (concat home "/savefile"))
          (unless (file-exists-p home) (make-directory home))
          (concat home "/org-pm-project-data.el"))
         (t (concat home "/.org-pm-project-data.el"))))
    "Path of file for storing org-publish-project-alist and
  org-pm-files.  If nil, the path is deduced from the existence
  of .emacs.d folder in user's home directory.
  If .emacs.d exists, use ~/.emacs.d/savefile/org-pm-project-data.el
  else use ~/.org-pm-project-data.el.
  Create savefile folder if it does not exist.")
#+END_SRC

** DONE org-pm-section-exports

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-section-exports nil
    "List of sections of files copied to projects.
  For each file, store a list starting with the full path of the file, and
  followed by the list of section position and sublist path-project pairs
  specified in the file:

    (full-path-of-file
           (position-section-1 (path . project1) (path . project2) ...)
           (position-section-2 (path . project1) (path . project2) ...)
    )
  Function org-pm-get-section-project-paths updates this list
  whenever it scans a buffer.
  The value is saved on disc in file specified by org-pm-project-data-file-path")
#+END_SRC

** DONE org-pm-project-def-duplicates
CLOSED: [2013-12-21 Sat 22:07]

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-def-duplicates nil
    "List of links to files/sections which contains project definitions
  that were overwritten because another definition with the same name was found.
  Auto-saved together with org-publish-project-alist and org-pm-files.
  Used to create org-mode buffer with links to these locations.
  See functions:
  - org-pm-check-add-project
  - org-pm-list-dupicate-project-defs
  - org-pm-project-def-list
  - pm/edit-duplicate-project-def"
  )
#+END_SRC

** UNDERWAY org-pm-project-template-file-name
:PROPERTIES:
:ID:       9D5B4E5D-90E1-4F32-842D-620B262665AF
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-template-file-name
    (concat (file-name-directory (or load-file-name (buffer-file-name)))
            "org-pm-project-template-jekyll.org")
  "Full path of file containing template of project definition for
  projects generated automatically with org-pm-insert-new-project.
  The path is initialized at code loading time by function
  org-pm-init-project-template-name.
  org-pm-insert-new-project uses it to make project templates.
  The default template is for exporting to jekyll:
  org-pm-project-template-jekyll.org
  An alternative template for full html export with header is provided:
  org-pm-project-template-plain.org" )
#+END_SRC

* DONE Main Commands, Menu, Keyboard Shortcuts

|--------------------------+---------------------------------------------|
| Shortcut                 | Command                                     |
|--------------------------+---------------------------------------------|
| *MAIN COMMANDS*          |                                             |
|--------------------------+---------------------------------------------|
| H-m H-m                  | org-pm-menu (list all commands, select one) |
| H-m n                    | org-pm-insert-new-project                   |
| H-m m or H-m p m         | org-pm-make-projects (current buffer)       |
| C-u H-m m or C-u H-m p m | org-pm-make-projects (all files)            |
| H-m a                    | org-pm-add-section-to-project               |
| H-m r                    | org-pm-remove-section-from-project          |
| H-m e                    | org-pm-export                               |
|--------------------------+---------------------------------------------|

** DONE org-pm-menu

Select org-pm command interactively

#+BEGIN_SRC elisp
  (defun debug-org-pm-menu ()
    (interactive)
    (let* ((commands '("a" "b"))
           (menu (grizzl-make-index commands)))
      (grizzl-completing-read "select command: " menu)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun org-pm-menu ()
    "Select and run an org-pm command from a grizzl-minibuffer menu list."
    (interactive)
    (setq  *grizzl-read-max-results* 32)
    (let* ((commands '(
                       org-pm-open-target-of-this-file
                       org-pm-open-source-of-this-file
                       org-pm-source-file-menu
                       org-pm-target-file-menu
                       org-pm-project-def-list
                       org-pm-insert-new-project
                       org-pm-make-projects
                       org-pm-add-section-to-project
                       org-pm-remove-section-from-project
                       org-pm-export
                       org-pm-publish
                       org-pm-show-project-definition-section
                       org-pm-edit-project-template
                       org-pm-list-duplicate-project-defs
                       pm/edit-duplicate-project-def
                       org-pm-post-project-def
                       org-pm-load-project-data
                       org-pm-save-project-data
                       org-pm-reset-project-list
                       org-pm-edit-saved-project-data
                       ))
           (index 0)
           (menu (grizzl-make-index
                 (-map (lambda (c)
                         (format "%s: %s"
                                 (progn
                                   (setq index (+ 1 index))
                                   (if (> index 9)
                                       (format "%d" index)
                                     (format ".%d" index)))
                                 (replace-regexp-in-string
                                  "-"
                                  " "
                                  (replace-regexp-in-string
                                   "^org-pm-" "" (symbol-name c)))))
                       commands)))
          selection)
      (setq selection (grizzl-completing-read "Select command: " menu))
      (eval
       (read (concat
              "(org-pm-"
              (replace-regexp-in-string
               " " "-"
               (replace-regexp-in-string
                "^[.0-9]+: " "" selection))
              ")")))))
#+END_SRC

** UNDERWAY Keyboard shortcuts

Note: I use the Hyper-m  (= Mac fn key m) as prefix, because it is not likely to be occupied by other packages.  Users can easily remap.

#+BEGIN_SRC emacs-lisp
  ;; Add org-mode hook for org-pm-key bindings.

  ;; Make menu globally available:
  (global-set-key (kbd "H-m H-m") 'org-pm-menu)

  ;; All other commands available in org-mode:
  (let ((org-pm-key-bindings
         (lambda ()
         ;;  (define-key org-mode-map (kbd "H-m H-m") 'org-pm-menu)
           (define-key org-mode-map (kbd "H-m s") 'org-pm-source-file-menu)
           (define-key org-mode-map (kbd "H-m H-s") 'org-pm-open-source-of-this-file)
           (define-key org-mode-map (kbd "H-m t") 'org-pm-target-file-menu)
           (define-key org-mode-map (kbd "H-m H-t") 'org-pm-open-target-of-this-file)
           (define-key org-mode-map (kbd "H-m n") 'org-pm-insert-new-project)
           (define-key org-mode-map (kbd "H-m p n") 'org-pm-insert-new-project)
           (define-key org-mode-map (kbd "H-m m") 'org-pm-make-projects)
           (define-key org-mode-map (kbd "H-m p m") 'org-pm-make-projects)
           (define-key org-mode-map (kbd "H-m a") 'org-pm-add-section-to-project)
           (define-key org-mode-map (kbd "H-m r") 'org-pm-remove-section-from-project)
           (define-key org-mode-map (kbd "H-m e") 'org-pm-export)
           (define-key org-mode-map (kbd "H-m P") 'org-pm-publish)
           (define-key org-mode-map (kbd "H-m p e") 'org-pm-show-project-definition-section)
           (define-key org-mode-map (kbd "H-m p s") 'org-pm-show-project-definition-section)
           (define-key org-mode-map (kbd "H-m p t") 'org-pm-edit-project-template)
           (define-key org-mode-map (kbd "H-m p l") 'org-pm-project-def-list)
           (define-key org-mode-map (kbd "H-m p d") 'org-pm-list-duplicate-project-defs)
           (define-key org-mode-map (kbd "H-m p p") 'org-pm-post-project-def)
           (define-key org-mode-map (kbd "H-m d l") 'org-pm-load-project-data)
           (define-key org-mode-map (kbd "H-m d s") 'org-pm-save-project-data)
           (define-key org-mode-map (kbd "H-m d r") 'org-pm-reset-project-list)
           (define-key org-mode-map (kbd "H-m d c") 'org-pm-reset-project-list)
           (define-key org-mode-map (kbd "H-m d e") 'org-pm-edit-saved-project-data)
           )))
    (add-hook 'org-mode-hook org-pm-key-bindings)
    )

  ;; To initialize if present file is compiled after start time, run hook now.
  ;; (funcall org-pm-key-bindings)

#+END_SRC



** DONE org-pm-insert-new-project

#+BEGIN_SRC emacs-lisp
  (defun org-pm-insert-new-project (&optional project-name no-name-query no-query)
    "Create a project definition template and insert it into current file.
  Input project name, base directory and publishing directory from user.
  Skip input step if called with prefix argument.
  Read file containing template of project definition
  from org-pm-project-template-file-name
  If arguments present, replace relevant parts of the template with
  custom name, base-directory, publishing-directory
  Insert the resulting template in the current file.
  Create the project as well as its static project and component project.
  Store all 3 in org-publish-project-alists.
  Save updated project, file and duplicate lists to disk."
    (interactive "P")
    (let* ((base-directory (file-truename "~/org-pm/"))
           (publishing-directory
            (file-truename "~/Sites/org-pm/"))
           (def-node
             (car (org-map-entries '(cadr (org-element-at-point)) "PROJECT_DEFS")))
           (buffer (get-buffer-create "*def*"))
           plist template-string)
      (unless project-name (setq project-name "org_pm_default"))
      (unless no-name-query
        (setq project-name (read-string "Enter project name: " project-name)))
      (unless no-query
        (setq base-directory (query-make-folder base-directory))
        (setq publishing-directory (query-make-folder publishing-directory)))
      (save-excursion
        (set-buffer buffer)
        (insert-file-contents org-pm-project-template-file-name)
        (beginning-of-buffer)
        (replace-string "PROJECTNAME" project-name)
        (beginning-of-buffer)
        (replace-string "BASEDIRECTORY" base-directory)
        (beginning-of-buffer)
        (replace-string "PUBLISHINGDIRECTORY" publishing-directory)
        (setq template-string (buffer-string))
        (kill-buffer buffer))
      (cond (def-node
             (goto-char (plist-get def-node :begin))
             (end-of-line)
             (insert "\n")
             (org-paste-subtree (+ 1 (plist-get def-node :level)) template-string))
            (t
             (end-of-buffer)
             (insert "\n* COMMENT Project Definitions              :PROJECT_DEFS:\n")
             (org-paste-subtree 2 template-string)))
      (org-id-get-create)
      (org-pm-check-add-project (org-pm-parse-project-def (cadr (org-element-at-point))))
      (org-pm-save-project-data)))
#+END_SRC


** DONE org-pm-make-projects

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-projects (&optional do-not-save-now)
    "Construct the projects for all project definitions found in current file.
  Save the upated org-publish-project-alist.

  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_DEFS.
  Note about project definition NODE-IDs:
  Section IDs of project definitions are used only as links
  to point to the position in the file where a project definition is, located.
  They do not identify a project.  A project is identified by its name.
  Therefore:
  The node-id of a project is set to <full-file-path>::#<section id>.
  When a duplicate section id is found in a definition, it is replaced by a new one,
  and the new id is stored in the project."
    (interactive)
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let (levels id ids projects)
      (org-map-entries
       '(let
            ((entry (cadr (org-element-at-point))))
          (if (member "PROJECT_DEFS" (plist-get entry :tags))
              (setq levels (cons (+ 1 (plist-get entry :level)) levels)))
          (when (equal (car levels) (plist-get entry :level))
            (setq id (org-id-get-create))
            (when (member id ids)
              (org-delete-property "ID")
              (setq id (org-id-get-create))
              (setq entry (plist-put entry :ID id)))
            (setq ids (cons id ids))
            (setq projects (cons (org-pm-parse-project-def entry) projects))))
       "PROJECT_DEFS")
      (mapcar 'org-pm-check-add-project projects)
      (unless do-not-save-now (org-pm-save-project-data))
      (message "Org-pm defined %d projects" (length projects))))
#+END_SRC

*** Auxiliary functions for project parsing

**** org-pm-parse-project-def

#+BEGIN_SRC emacs-lisp
  (defun org-pm-parse-project-def (proj-node &optional template)
    "Temp. note: template is no longer used IZ Jan 5, 2014 (6:27 PM)
  Create a project definition list based on the contents of the
  section described in proj-node plist. Convert headings
  to property names and contents to their values.
  Add useful identification data.
  Argument template is a plist with additional properties,
  but may be left out if the section contains all the properties needed
  to define the project."
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let (
          ;; (pdef (copy-sequence template))
          pdef
          (pname (plist-get proj-node :raw-value))
          (begin (plist-get proj-node :contents-begin))
          (node-id (plist-get proj-node :ID))
          (file-name (buffer-file-name (current-buffer))))
      (setq pdef (plist-put pdef :project-name pname))
      (setq pdef (plist-put pdef :node-id node-id))
      (setq pdef (plist-put pdef :node-filename file-name))
      (setq pdef (plist-put pdef :project-id (concat file-name "::#" node-id)))
      (setq pdef (plist-put pdef :last-updated (format-time-string "[%Y-%m-%d %a %H:%M]")))
      (cond
       (begin
        (save-excursion
          (save-restriction
            (narrow-to-region begin (plist-get proj-node :contents-end))
            (org-map-entries
             '(let* (
                     (element (cadr (org-element-at-point)))
                     (heading (plist-get element :raw-value))
                     (space (string-match " .*" heading))
                     prop-name prop-value contents-begin)
                (cond
                 (space
                  (setq prop-name (substring heading 0 space))
                  (setq prop-value (eval (read (substring heading space))))
                  (if (and
                       (equal prop-name "include-containing-file")
                       prop-value)
                      (org-pm-add-component
                       pname (buffer-file-name (current-buffer)) prop-value)))
                 (t (setq prop-name heading)
                    (setq contents-begin (plist-get element :contents-begin))
                    (if contents-begin
                        (setq
                         prop-value
                         (buffer-substring-no-properties
                          contents-begin
                          (plist-get element :contents-end))))))
                (setq pdef
                      (plist-put pdef (intern (concat ":" prop-name)) prop-value))))))))
      (cons pname pdef)))
#+END_SRC

**** org-pm-check-add-project
#+BEGIN_SRC emacs-lisp
  (require 'dash)
  (defun org-pm-check-add-project (project)
    "Add project definition contained in plist 'project' to org-publish-project-alist,
  replacing any previously existing definition there.  Before replacing, save any
  previously existing project whose definition is in a different file component in
  the variable org-pm-project-def-duplicates:
  If a project with the same name already exists in org-publish-project-alist,
  and that project has a different ID (file path + section ID), then the previously
  existing project definition is added to the list in org-pm-project-def-duplicates.
  Also create static and combined project components.
  Create alternate ids for the latter, by appending -static and -combined
  to the id of the main project."
    (unless org-publish-project-alist (org-pm-load-all-project-data))
    (let* ((p-name (car project))
           (p-def (cdr project))
           (prev-proj (assoc p-name org-publish-project-alist))
           (prev-proj-id (plist-get (cdr prev-proj) :project-id))
           (duplicates (assoc p-name org-pm-project-def-duplicates))
           static-project static-project-name combined-project)
      (cond
       ((not prev-proj))
       ((equal prev-proj-id (plist-get p-def :project-id)))
       (t (setq
           org-pm-project-def-duplicates
           (assoc-replace org-pm-project-def-duplicates p-name
                          (add-to-list 'duplicates prev-proj-id)))))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist p-name p-def))
      (setq static-project
            (-flatten
             (-map
              (lambda (pair)
                (list (intern (replace-regexp-in-string "^:static-" ":"
                                                        (symbol-name (car pair))))
                      (cadr pair)))
                       (-filter
                        (lambda (pair) (string-match "^:static-"
                                                     (symbol-name (car pair))))
                        (-partition 2 p-def)))))
      (setq static-project-name (concat "static_" p-name))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist
                           static-project-name static-project))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist
                           (concat "combined_" p-name)
                           (list :components
                                 p-name static-project-name))))
    project)
#+END_SRC


**** query-make-folder
#+BEGIN_SRC emacs-lisp
  (defun query-make-folder (path &optional prompt-string)
    "If folder at path does not exist, then show dialog offering to user
      the option to create the indicated folder or to choose another path.
      If selected path does not exist, create folder."
    (setq path (file-truename path))
    (unless prompt-string (setq prompt-string "Folder select or create:"))
    (let ((answer
           (read-file-name
            (format
             "%s\nSelect or input folder (folder will be created if needed):\n"
             prompt-string)
            path)))
      (unless (equal (file-truename answer) (buffer-file-name (current-buffer)))
        (setq path answer))
      (unless (file-exists-p path) (make-directory path))
      path))
#+END_SRC




** DONE org-pm-add-section-to-project
Add tag naming selected project to current section (node).

If project name input by user does not correspond to an existing project, offer to create that project.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-section-to-project ()
    "Present menu of existing project definitions.
  Add selected project as tag to current section."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let* ((project-name (org-pm-select-project-from-menu))
             (tags (plist-get (cadr (org-element-at-point)) :tags))
             (existing-projects
              (-map (lambda (p) (car (org-pm-parse-tag p)))
                    (-filter (lambda (tag) (string-match "^_.*_$" tag)) tags))))
        (unless (member project-name existing-projects)
          (org-set-tags-to (cons (concat "_" project-name "_") tags))))))
#+END_SRC

*** org-pm-select-project-from-menu

Present menu for selecting one project from the list of known projects.  Utility function used by org-pm-add-section-to-project.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-select-project-from-menu ()
    "Present menu for selecting one project from the list of known projects."
    (interactive)
    (let* ((projects
            (-filter
             (lambda (pn) (not (string-match "^combined_" pn)))
             (-map 'car org-publish-project-alist)))
           index selected-project-name)
      (unless projects (setq projects '("new_project")))
      (setq index (grizzl-make-index projects))
      (setq selected-project-name
            (grizzl-completing-read "Choose a project:" index))
      (unless (assoc selected-project-name org-publish-project-alist)
        (org-pm-insert-new-project selected-project-name t))
      selected-project-name))
#+END_SRC


** DONE org-pm-remove-section-from-project
:PROPERTIES:
:DATE:     <2014-01-13 Mon 08:43>
:END:

Remove tag naming selected project from current section (node).

#+BEGIN_SRC elisp
  (defun org-pm-remove-section-from-project ()
    "Show menu for selecting a project definition from tags of current section.
    Then remove selected project from tags of current section."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let* ((tags (plist-get (cadr (org-element-at-point)) :tags))
             (existing-projects
              (-map (lambda (p) (car (org-pm-parse-tag p)))
                    (-filter (lambda (tag) (string-match "^_.*_$" tag)) tags)))
             (index (grizzl-make-index existing-projects))
             (project (grizzl-completing-read "Select project to remove:" index)))
       (org-set-tags-to
        (-reject
         (lambda (p) (equal (car (org-pm-parse-tag p)) project)) tags)))))
#+END_SRC

** UNDERWAY org-pm-export

*** Notes
STATUS: Focus on =org-pm-export-1-section-to-projects=

First thing to do:

Decide which category this section belongs to:

1. non-html (css, scss, el, etc.):  If project alist property :publishing-function is not org-html-publish-to-html, then just save the contents to file, in the path provided by the section scanning process. (Later: try to use org-publish functions for the saving?).
2. html export (convert to html using available org-publish functions).  Use =org-pm-export-buffer-to-html=.  Details:
   1. Copy section to buffer.
   2. Remove extra section levels, trailing date from header etc.
   3. Loop for all projects in tags of section, and do following:
      1. Create string containing YAML header, using =org-pm-make-yaml-header=.
      2. Store it in current project alist, in property =:yaml-header= which is used as info channel by org-publish functions.
      3. Call =org-pm-export-buffer-to-html=, which will use a filter to copy the yaml header before saving.
      4. Store an empty string in =:yaml-header=

Note that both the yaml header construction and the conversion to html is done again for each project.  This is because differences in project property values may require differt renderings.

**** non-html export

Copy the contents of the section to the buffer, but leave out the heading.  To get the contents, use this:

: (plist-get section-plist :contents-begin) ;; beginning of contents
; (plist-get section-plist :contents-end) ;; end of contents

Note: P

See for example section-plist of the present section here:

#+BEGIN_SRC elisp
  (save-excursion
    (org-back-to-heading)
    (cadr (org-element-at-point)))
#+END_SRC

#+RESULTS:
| :raw-value | non-html export | :begin | 26972 | :end | 27255 | :pre-blank | 1 | :hiddenp | nil | :contents-begin | 26994 | :contents-end | 27253 | :level | 4 | :priority | nil | :tags | nil | :todo-keyword | nil | :todo-type | nil | :post-blank | 1 | :footnote-section-p | nil | :archivedp | nil | :commentedp | nil | :quotedp | nil | :CATEGORY | org-pm | :title | non-html export |

**** html export

For the present, do not strip the section title, but include it in the buffer to be exported.

Test formatting with section title, and if needed, rewrite to omit the section title, possibly using the =:contents-begin= and =:contents-end= markers as with non-html export.

- Reduce the section level of all sections until the first section of the buffer has level 1.
- strip date postfix from heading if present.
- remove project-export-related tags.
- generate YAML front matter if required.
- use org-pm-publish-buffer-to. Thereby obviate org-publish step.

***** Reducing section level to 1

To reduce section level, do not use org-promote-subtree, because (a) it calls unnecessary functions related to updating display (b) it is only available in vesion for promoting 1 level at a time.

Instead, use this method:

- find the level of the section from the section's plist
- compute the number of levels to reduce:

: (- (plist-get section-plist :level) 1)

If number of levels to reduce > 0, then first copy the section to the buffer for converting, and then run this on that buffer:

Here is the formula. (One more magic regex[p]. hahaha)

#+BEGIN_SRC elisp
(re-search-forward "\n\\*\\{5\\}\\*+ " nil t)
(replace-match (concat "\n" (substring (match-string 0) 3)))
#+END_SRC

Simpler yet:
#+BEGIN_SRC elisp
(re-search-forward "\n\\*+ " nil t)
(replace-match (concat "\n" (substring (match-string 0) 2)))
#+END_SRC


#+RESULTS:
: 28828

Should be just after this:
******** test!!!

*****

#+begin_src elisp
(while (re-search-forward "\n\*\*\* " nil t)
    (replace-match TO-STRING nil t))
#+end_src

#+RESULTS:

#+BEGIN_SRC elisp
(re-search-forward "h.lp")
#+END_SRC

#+RESULTS:
: 28667

(see help string of functions replace-string, replace-match, search-forward).

***** strip date postfix

***** remove project-export-related tags

***** generate YAML front matter if needed

...

*** TODO org-pm-publish-buffer-to-html

Test case for =org-pm-publish-buffer-to-html=.  Shows that it works if we initialize cache.

#+BEGIN_SRC
(let* ((project (assoc "octopress_pm_test"  org-publish-project-alist))
       (pname (car project))
       (plist (cdr project))
      (root (plist-get plist :publishing-directory))
      (path (concat root "/test.html")))
 ;;  (org-publish-initialize-cache pname)
  (org-pm-publish-buffer-to-html (get-buffer "test") path plist)
  )
#+END_SRC

**** org-pm-export Top level: publish sections to html or source

#+BEGIN_SRC emacs-lisp
  (defun org-pm-export ()
    "Top-level function for exporting sections to projects.
  Renders sections of the current org-mode buffer that belong to html-projects.
  Files produced by this function are ready for viewing on web, or for
  processing with Jekyll to create site pages.

  Copy any sections specified by properties, tags to designated folders.
  List sections-with-paths is constructed by org-pm-get-section-project-paths.

  If project specified is html, then render the file to html.
  If project property body-only is t, then also prepend yaml-front-matter.

  Before copying, re-scan buffer to build list of targets for copying.

  After copying, add list of sections (point location and id) and target file paths to
  org-pm-section-exports, and save it to disk."

    (interactive)
    (save-buffer)
    (save-excursion
      (save-restriction
        (widen)
        (let* ((sections-with-paths (org-pm-get-section-project-paths))
               (buffer (current-buffer))
              (filename (buffer-file-name buffer)))
          (dolist (section sections-with-paths)
            (org-pm-export-1-section-to-projects section buffer))
          (setq org-pm-section-exports
                (assoc-replace org-pm-section-exports filename sections-with-paths)))
        (org-pm-save-project-data))))

  (defun org-pm-export-1-section-to-projects (section-with-paths origin-buffer)
    "Copy section to temporary buffer, then save it to all
  paths in the rest of section-with-paths.

  SECTION-WITH-PATHS is list with car the starting position of the section to be
  exported, cadr the id of the section, and cddr the list of path-project pairs
  where the section will be exported.

  ORIGIN-BUFFER is the buffer containing the section to be exported.

  SECTION-PLIST is obtained from the section to be exported, and is used
  to create YAML front matter where required."
    (let* ((section-begin (car section-with-paths))
           (section-plist
           (with-current-buffer origin-buffer
             (goto-char section-begin)
             (cadr (org-element-at-point))))
          (target-buffer (org-pm-make-section-buffer origin-buffer section-begin)))
      (dolist (path-project (cddr section-with-paths))
        (when (car path-project)
          (let* ((project (assoc (cdr path-project) org-publish-project-alist))
                (plist (cdr project))
                (path (car path-project)))
            (if (equal (plist-get plist :publishing-function) 'org-html-publish-to-html)
             (org-pm-publish-buffer-to-html
              target-buffer path
              (org-pm-make-yaml-front-matter plist section-plist))
             (with-current-buffer target-buffer
               (let ((dir (file-name-directory path)))
                 (unless (file-exists-p dir) (make-directory dir t)))
               (write-region nil nil path))))))
      (message "exported section: %s" section-with-paths)))

  (defun org-pm-make-section-buffer (origin-buffer position)
    "Copy the contents of an org-mode section located at position
  in origin-buffer to a temporary buffer, for exporting.
  Return the temporary buffer.
  Used by org-pm-export-1-section-to-projects.
  Passed as argument to org-pm-export-buffer-to-html."
    (with-current-buffer origin-buffer
      (goto-char position)
      (org-copy-subtree))
    (with-current-buffer (get-buffer-create "*org-pm-copy-buf*")
      (erase-buffer)
      (org-mode)
      (org-paste-subtree 1)
      ;; TODO:
      ;; (later: optionally remove title?)
      ;; strip trailing date from header
      ;; remove tags that indicate projects
      (current-buffer)))

  (defun org-pm-publish-buffer-to-html (buffer path plist)
    "Publish an Org-mode buffer to html.
    Adapted from org-publish-org-to.

    BUFFER is the buffer to publish.
    PATH is the target filename of publish the buffer to.
    PLIST is the property list for the given project."

    (let* ((org-inhibit-startup t)
           (pub-dir (file-name-directory path))
           (body-p (plist-get plist :body-only)))
      (unless (file-exists-p pub-dir) (make-directory pub-dir t))
      (with-current-buffer buffer
        (let ((output-file path))
          (org-export-to-file 'html output-file
            nil nil nil body-p plist)))))

  (defun org-pm-make-target (specs)
    (let* ((project-name (car specs))
           (folder (cadr specs))
           (slash (if (string-match "/$" folder) "" "/"))
           (project (assoc project-name org-publish-project-alist)))
      (cond (project
             (add-to-list '*org-pm-updated-projects* project-name)
             (concat (plist-get (cdr project) :base-directory)
                     folder slash (caddr specs)))
            (t
             (add-to-list '*org-pm-missing-projects* project-name)
             nil))))
#+END_SRC

No longer used?:

#+BEGIN_SRC elisp
(defun org-pm-export-buffer-to-file (path-project)
  "path-project has the form (path . project-name).
   If path is not nil, save current buffer to path."
  (let ((path (car path-project)))
    (when path
      (make-directory (file-name-directory path) t)
      (write-region nil nil path))))

(defun org-pm-save-buffer (specs buffer)
  "Save current buffer "
  (let ((target-path (org-pm-make-target specs)))
    (make-directory (file-name-directory target-path) t)
    (write-region nil nil target-path)))
#+END_SRC

***** org-pm-get-non-project-tags

Get those tags which are not enclosed in dash (=-=).
Function org-pm-make-yaml-matter inserts these tags as part of the YAML matter in the file header for use by Jekyll/Octopress.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-get-non-project-tags (section-plist)
    "Get those tags which are not enclosed in dash (=-=).
  Function org-pm-make-yaml-matter inserts these tags as part of the YAML matter
  in the file header for use by Jekyll/Octopress."
    (-reject (lambda (tag) (string-match "^_.*_$" tag)) (plist-get section-plist :tags)))
#+END_SRC

**** Define Filter for adding yaml front matter

When headlines are present in an org buffer, org-export-as encloses the entire body in divs.  So the only way is to add the YAML header *AFTER* org-export-as has finished the conversion.  Use the publish filter mechanism provided for this by orgmode.  The next section here contains a working example from dynsite. Adapt this example to insert a header instead of doing replace-regexp-in-string.

***** Providing relative paths to root of published project

This makes sure that when a file is copied to a subfolder of the publishing directory, the paths pointing to includes such as css, images, etc. will be converted to show to the root of the project, so that links work.  Such links must be marked using the string ={{.}}= to denote the relative root to the published project, that is, the =publishing-directory=.

****** Original example.
#+BEGIN_SRC emacs-lisp
  (defun org-html-provide-relative-path (string backend info)
    "Provide relative path for link."
    (when (org-export-derived-backend-p backend 'html)
      (let ((base-dir (plist-get info :base-directory))
            (input-file (plist-get info :input-file)))
        (when (and base-dir input-file)
          (replace-regexp-in-string
           "{{.}}"
           (org-make-relpath-string
            (plist-get info :base-directory)
            ;; distance of input file from base-directory = relative path!
            (plist-get info ':input-file))
           string)))))

    ;;; Add relative path filter to export final output functions
  (add-to-list 'org-export-filter-final-output-functions
               'org-html-provide-relative-path)

  (defun org-make-relpath-string (base-path file-path)
    "create a relative path for reaching base-path from file-path ('./../..' etc)"
    (let (
          (path ".")
          (depth (-
                  (length (split-string (file-name-directory file-path) "/"))
                  (length (split-string base-path "/")))))
      (dotimes (number
                (- depth 1)
                path)
        (setq path (concat path "/..")))))

#+END_SRC

#+RESULTS:
: org-make-relpath-string

******* Version to use: Remove cache-requiring filters

UPDATE: The YAML stuff must be done in a filter.  This is the only way.
See preparation in section above.

Transfer the YAML stuff from the version in the next section to the present version.

Test case without cache-initialization:

#+BEGIN_SRC elisp
  (let* ((project (assoc "octopress_pm_test"  org-publish-project-alist))
         (pname (car project))
         (plist (cdr project))
        (root (plist-get plist :publishing-directory))
        (path (concat root "/test.html")))
  ;;   (org-publish-initialize-cache pname)
    (with-current-buffer (get-buffer "test")
      (let ((section-plist (cadr (org-element-at-point))))
        ;;  (org-pm-make-yaml-front-matter plist section-plist)
        (org-pm-publish-buffer-to (current-buffer) path project)
        )))

#+END_SRC

#+RESULTS:
: ~/Documents/Dev/Web/octopress-pm-test-html/test.html

******* With Yaml: Transfer this to above

#+BEGIN_SRC elisp
  ;;; TODO: Adapt this to work with buffer instead of file
  ;;; Original function: org-publish-org-to
  (defun org-pm-publish-buffer-to (buffer path project section-plist)
    "Publish a buffer to html.
  Adapted from org-publish-org-to.

  BUFFER is the buffer containing the text to be converted to html.
  PATH is the full path to write the file to.
  PROJECT is the project-name + property list for the given project.
  SECTION-PLIST is the plist of the section that is copied to buffer.

  If project plist has property export-to-jekyll set to true, then:
  - Copy the buffer into a new buffer in order not to affect next publications.
  - Create and insert jekyll YAML front matter at the beginning of the new buffer.


  "
    ;; Check if a buffer visiting FILENAME is already open.
    (let* ((pname (car project))
           (plist (cdr project))
           must-kill-buffer
           work-buffer
           (pub-dir (file-name-directory path))
           (org-inhibit-startup t))
      (unless (file-exists-p pub-dir) (make-directory pub-dir t))
      (cond ((plist-get plist :export-to-jekyll)
             (setq must-kill-buffer t)
             (setq work-buffer (get-buffer-create "*org-pm-copy-yaml-buf*"))
             ... first make yaml front matter based on plist, section-plist
             ... and put it in work-buffer
             ... then copy/append buffer to work-buffer
             ... use append-to-buffer for this.  Description:
             (append-to-buffer BUFFER START END)

             Append to specified buffer the text of the region.
             It is inserted into that buffer before its point.

             When calling from a program, give three arguments:
             BUFFER (or buffer name), START and END.
             START and END specify the portion of the current buffer to be copied.
            ;; ()
             )
        (t (setq work-buffer buffer)))
      ;;; initialize cache - otherwise error occurs.
      ;;; ALTERNATIVELY REMOVE THE org-combine-plists call below!!!
      (org-publish-initialize-cache pname)
      ;; can be progn instead of prog1:
      (prog1 (with-current-buffer work-buffer
               (let ((body-p (plist-get plist :body-only)))
                   (org-export-to-file 'html path nil nil nil body-p
                   ;; Add `org-publish-collect-numbering' and
                   ;; `org-publish-collect-index' to final output
                   ;; filters.  The latter isn't dependent on
                   ;; `:makeindex', since we want to keep it up-to-date
                   ;; in cache anyway.
                   (org-combine-plists
                    plist
                    `(:filter-final-output
                      ,(cons 'org-publish-collect-numbering
                             (cons 'org-publish-collect-index
                                   (plist-get plist :filter-final-output)))))))))
      (when must-kill-buffer (kill-buffer work-buffer))))
#+END_SRC

****** YAML filter

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-yaml-front-matter (string backend info)
    "Add yaml front matter header to export string before writing file."
    (when (org-export-derived-backend-p backend 'html)
      (concat (or (plist-get info :yaml-header) "") string)))

  ;;; Add yaml front matter for jekyll / octopress files
  (add-to-list 'org-export-filter-final-output-functions
               'org-pm-add-yaml-front-matter)
#+END_SRC

#+RESULTS:
| org-pm-add-yaml-front-matter | org-html-provide-relative-path |


**** Get list of file components to be copied to projects

***** org-pm-get-section-project-paths

Get all sections marked with tags that are enclosed in underscore (=_=).  Parse each value and return a list of lists:
((section-position (project folder file) (project folder file) ...)
 (section-position (project folder file) (project folder file) ...)
...)

#+BEGIN_SRC emacs-lisp

  (defun org-pm-get-section-project-paths ()
    "Build list of projects-folders-files to export sections of this buffer to.
  The list is created from those sections whose tags specify projects,
  i.e . tags enclosed in underscores: _projectname_
  The list is passed to org-pm-copy-section-project-components for copying.
  Each element in the list has the form:
  <start-point of section>
      <id of section>
      (project projectname folder filename)
      (project projectname folder filename)
                           ... "
    (interactive)
    (let (components)
     (org-map-entries
      '(let* ((node (cadr (org-element-at-point)))
              (pspecs (-filter (lambda (tag) (string-match "^_.*_$" tag))
                               (plist-get node :tags)))
              name date)
         ;; (message "pspecs: \n%s" pspecs)
         (if pspecs
           (let (section-entries)
            (setq name (plist-get node :raw-value))
            (setq date (plist-get node :DATE))
            (dolist (spec pspecs)
              (setq section-entries
                    (cons (org-pm-make-target-path
                           (org-pm-parse-tag
                            spec
                            (org-pm-make-filename name)
                            date)) section-entries)))
            (setq components
                  (cons
                   (cons (point) (cons (org-id-get-create) section-entries))
                   components))))))
    ;;  (message "COMPONENTS: \n%s" components)
     components))

#+END_SRC

***** org-pm-get-1-section-project-paths

#+BEGIN_SRC emacs-lisp
  (defun org-pm-get-1-section-project-paths ()
    "Get the paths for exporting the current section, based on its tags."
   (let* ((node (cadr (org-element-at-point)))
          (pspecs (-filter (lambda (tag) (string-match "^_.*_$" tag))
                           (plist-get node :tags)))
          name date paths path)
     (when pspecs
         (setq name (plist-get node :raw-value))
         (setq date (plist-get node :DATE))
         (dolist (spec pspecs)
           (setq path (car (org-pm-make-target-path
                        (org-pm-parse-tag
                         spec
                         (org-pm-make-filename name)
                         date))))
           (if path (setq paths (cons path paths)))))
     paths))
#+END_SRC

**** org-pm-get-section-projects

#+BEGIN_SRC emacs-lisp

  (defun org-pm-get-section-projects ()
    "Return list of projects found in the tags of the current section"
   (save-excursion
     (org-back-to-heading)
     (-map (lambda (p) (car (org-pm-parse-tag p)))
           (-filter (lambda (tag) (string-match "^_.*_$" tag))
                    (plist-get (cadr (org-element-at-point)) :tags)))))
#+END_SRC

**** DONE Construct path of a target file to copy file or section to

Three functions are defined here:

1. =org-pm-parse-component= extracts project, folder and file name strings from a property or tag in an org file, plus the name of the current file and the value of the DATE property, if present.
2. =org-pm-make-target-path= constructs the final path, based on the list containing the project, folder and file, which is produced by =org-pm-parse-component=.
3. =org-pm-make-filename= convert heading of section to filename:  Strip non-alphanumeric characters, replace spaces by dashes, remove trailing timestamp, add blog (Jeckyll etc.) compatible date prefix if DATE property is given.

***** org-pm-parse-component
Called by:
- org-pm-get-file-components
- org-pm-get-section-components

Process data obtained from property or tag, and create list of form: (project folder filename). This is then processed by org-pm-make-target-path to make the path used to copy the file.

***** org-pm-make-target-path

Called by
- org-pm-copy-file-components
- org-pm-copy-section-components

Construct path for copying a file or section to, from list (project folder file) received from org-pm-parse-component. This funcion returns a cons pair: (path . path-or-project).  =path= is used for copying.  =path-or-project= for display/menus. If project def not found, path is nil and path-or-project is '<project-name> (not found)'

***** org-pm-make-filename

Called by org-get-section-components.  Converts the title of a section to a filename by replacing non-alphanumeric characters with dashes (=-=).  Also removes trailing timestamp from title.

***** Code

#+BEGIN_SRC emacs-lisp
  (defun org-pm-parse-tag (tag &optional filename date)
    "Process property or tag, name of file containing component,
  and date property of file or section to provide project, folder, filename strings.
  Split tag to project, folder, filename if separated by @.
  Construct blog entry style filename if date is provided.

  If date is provided, convert date into jekyll- (hexo-, etc.) compatible
  blog entry format, and prepend it.
  Entry title 'thoughts-on-pre-processing', with date <2014-01-05 Sun 10:56>
  becomes: '2014-01-05-thoughts-on-pre-processing'

  Do not convert filename from title format.  That is done by function
  org-pm-make-filename, which is called by org-pm-get-section-project-components."

    ;; strip enclosing underscores _
    (setq tag (replace-regexp-in-string
                     "^_" "" (replace-regexp-in-string "_$" "" tag)))
    ;; replace # by .
    (setq tag (replace-regexp-in-string "#" "." tag))
    ;; split into project, folder, filename
    ;; and provide "" as folder, filename where @ separators are missing
    (setq tag (-take 3 (split-string (concat tag "@@") "@")))
    ;; if tag had filename, use that instead of filename argument
    (if (> (length (caddr tag)) 0) (setq filename (caddr tag)))
    ;; provide extension
    (unless filename (setq filename "index"))
    (unless (file-name-extension filename)
      (setq filename (concat filename ".org")))
    ;; if date present, prepend date in jekyll blog-entry format
    (when (and date
               (string-match
                "^<\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                date))
      (setq filename (concat (substring date 1 11) "-" filename)))
    ;; return project, folder, new filename as list
    (setcdr (cdr tag) (list filename))
    tag)

  ;; Create final path to copy file, from list (project folder file)
  ;; received from org-pm-parse-tag.
  ;; Return (path . path-or-project)
  ;; path is used for copying.  path-or-project for display/menus.
  ;; If project def not found, path is nil.

  (defun org-pm-make-target-path (proj-folder-file)
    "Create path of file for copying contents of current buffer to a project.
  Combine base directory + folder + file from list proj-folder-file
  to make target-path.
  Return (path . project-name)
  The car of the result is used to copy the component to the path.
  The cdr of the result (project-name) is used for display and debugging."
    (let* ((pname (car proj-folder-file))
           (project (cdr (assoc pname org-publish-project-alist)))
           (folder (cadr proj-folder-file))
           (slash (if (string-match "/$" folder) "" "/"))
           (target-path
            (if project
                (concat (plist-get project :base-directory)
                        folder slash (caddr proj-folder-file)))))
      (cons target-path pname)))

  ;; Convert title of org-mode section entry into filename
  ;; Used by org-pm-get-section-project-components
  (defun org-pm-make-filename (title &optional date)
    "Convert title of org-mode section entry into filename.
  Remove non alphanumeric characters.
  Replace spaces by dashes (-).
  Strip initial or ending dashes.
  Lowercase everything.
  Strip : mm/dd/yy ... part from the end.
  Entry title:
  'Watching: Sacha_Chua Emacs_chat_with_magnar_sven (emacs_rocks): 12/08/13_14:54:11'
  Becomes:
  'watching-sacha-chua-emacs-chat-with-magnar-sven-emacs-rocks'"
    (let (filename
          (title-date-pos
           (string-match
            ": [[:digit:]]\\{2\\}/[[:digit:]]\\{2\\}/[[:digit:]]\\{2\\}"
            title)))
      (if title-date-pos
          (setq filename (substring title 0 title-date-pos))
        (setq filename title))
      (setq filename (downcase
                      (replace-regexp-in-string
                       "-+" "-"
                       (replace-regexp-in-string "[^[:alnum:]]" "-" filename))))
      (setq filename
            (replace-regexp-in-string
             "^-" "" (replace-regexp-in-string "-$" "" filename)))
      (when (and date
                 (string-match
                  "^<\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                  date))
        (setq filename (concat (substring date 1 11) "-" filename)))
      filename))
#+END_SRC



**** Create Jekyll/Octopress Headers ("YAML Front Matter")

If the value of property =body-only= in the project-plist is =t=, then org-pm adds YAML front matter at the beginning of the file when exporting.  This makes the file to be processed by Jekyll or Octopress.  The following items are provided, if their values are set:

- author :: value of eamcs/orgmode variable author
- categories :: value of property CATEGORIES
- commments :: value of property COMMENTS
- date :: value of property DATE
- external-url :: value of property EXTERNAL-URL
- layout :: =default= if no DATE property is set. =blog= if DATE property is set.  Value can be customized by setting property LAYOUT.
- permalink :: value of property PERMALINK
- published :: value of property PUBLISHED
- tags :: tags of section or values of property TAGS
- title :: from title property of file or header of section

***** About Yaml front matter

YAML front matter for jekyll or octopress is a header to be added at the beginning of the file, consisting of keyword-value pairs.  The header is demarcated by writing it between 3 dashes.  Example:

#+BEGIN_SRC
---
layout: post
title: "Categories"
date: 2014-01-04 19:05:17 +0200
comments: true
categories:
- CSS3
- Sass
- Media Queries
---
#+END_SRC

***** Doc of YAML front matter items

In http://jekyllrb.com/docs/frontmatter/ the following items are given for yaml front matter:

- layout :: If set, this specifies the layout file to use. Use the layout file name without the file extension. Layout files must be placed in the  _layouts directory.
- permalink :: If you need your processed blog post URLs to be something other than the default /year/month/day/title.html then you can set this variable and it will be used as the final URL.
- published :: Set to false if you don’t want a specific post to show up when the site is generated.
- categories :: Instead of placing posts inside of folders, you can specify one or more categories that the post belongs to. When the site is generated the post will act as though it had been set with these categories normally. Categories (plural key) can be specified as a YAML list or a space-separated string.
- tags :: Similar to categories, one or multiple tags can be added to a post. Also like categories, tags can be specified as a YAML list or a space- separated string.

Examples in http://octopress.org/docs/blogging/ include additional items:

- title
- date
- commments
- external-url
- author
- published

***** List of YAML front matter items

Following is list of front matter items collected from  http://jekyllrb.com/docs/frontmatter/ and  http://octopress.org/docs/blogging/ (More to be added if found later).

- author
- categories
- commments
- date
- external-url
- layout
- permalink
- published
- tags
- title

***** Header examples from octopress

#+BEGIN_SRC
---
layout: default
---
#+END_SRC

#+BEGIN_SRC
---
layout: page
title: Blog Archive
footer: false
---
#+END_SRC

#+BEGIN_SRC
---
layout: post
title: "Categories"
date: 2014-01-04 19:05:17 +0200
comments: true
categories:
- CSS3
- Sass
- Media Queries
---
#+END_SRC

**** org-pm-make-yaml-front-matter

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-yaml-front-matter (project-plist section-plist)
    "Make YAML front matter for Jekyll or Octopress.

  If the value of property body-only in the project-plist is t, then add YAML
  front matter at the beginning of the file when exporting.  This causes the file
  to be processed by Jekyll or Octopress.

  Add string containing the yaml-header as property :yaml-header to project-plist.
  Return the modified project-plist, to be used by org-pm-publish-buffer-to-html.
  This is then used by org-pm-add-yaml-front-matter, which is a filter added to
  'org-export-filter-final-output-functions and called by the final publishing function.

  The following items are provided, depending on the values of corresponding properties
  from global emacs variables, the project's p-list or the section's properties,
  or the section's tags:

  - author :: value of property AUTHOR or emacs/orgmode variable author
  - categories :: value of property CATEGORIES
  - commments :: value of property COMMENTS
  - date :: value of property DATE or current date and time
  - external-url :: value of property EXTERNAL-URL
  - layout :: value of property LAYOUT, if available.  Else:
              'default' if no DATE property is set, 'blog' if DATE property is set.
  - permalink :: value of property PERMALINK
  - published :: value of property PUBLISHED
  - tags :: tags of section or values of property TAGS
  - title :: from header of section.
  - sharing :: from property SHARING
  - footer :: from property FOOTER

  If :body-only is nil, then the yaml-header string is the empty string."
    (let (yaml-header)
      (if (plist-get project-plist :body-only)
          (let*
              ((buffer (get-buffer-create "*yaml-header*"))
               (time-format-string  "%Y-%m-%d %T %z")
               (title (plist-get section-plist :raw-value))
               (tags (org-pm-get-non-project-tags section-plist))
               (author (plist-get section-plist :AUTHOR))
               (categories (plist-get section-plist :CATEGORIES))
               (comments (plist-get section-plist :COMMENTS))
               (date (plist-get section-plist :DATE))
               (external-url (plist-get section-plist :EXTERNAL-URL))
               (layout (or (plist-get section-plist :LAYOUT)
                           (if date "blog" "default")))
               (permalink (plist-get section-plist :PERMALINK))
               (published (plist-get section-plist :PUBLISHED))
               (sharing (plist-get section-plist :SHARING))
               (footer (plist-get section-plist :FOOTER)))
            (if date
                (setq date (format-time-string
                            time-format-string
                            (org-time-string-to-time date)))
              (setq date (format-time-string time-format-string)))
            (setq author (or author (user-full-name)))
            (with-current-buffer buffer
              (insert "---\n")
              (insert (format "title: %s\n" title))
              (insert (format "layout: %s\n" layout))
              (insert (format "author: %s\n" author))
              (insert (format-time-string
                       "date: %Y-%m-%d %T %z\n"
                       (if date (org-time-string-to-time date))))
              (if external-url (insert (format "external-url: %s\n" external-url)))
              (if permalink (insert (format "permalink: %s\n" permalink)))
              (if published (insert (format "published: %s\n" published)))
              (if comments (insert (format "comments: %s\n" comments)))
              (if sharing (insert (format "sharing: %s\n" sharing)))
              (if footer (insert (format "footer: %s\n" footer)))
              (when categories
                (insert "categories:\n")
                (dolist (category (split-string categories ", "))
                  (insert (format "- %s\n" category))))
              (when tags
                (insert "tags:\n")
                (dolist (tag tags) (insert (format "- %s\n" tag))))
              (insert "---\n")
              (setq yaml-header (buffer-string)))
            (kill-buffer buffer)
            )
        (setq yaml-header ""))
      (plist-put project-plist :yaml-header yaml-header)))
#+END_SRC

#+RESULTS:
: org-pm-make-yaml-front-matter

** DONE org-pm-publish (interactive: select and publish project)
:PROPERTIES:
:ID:       688C2A25-277F-4263-95C9-FFFDA2F15E87
:END:

Select a project to publish from the projects targeted by current buffer.  If called with prefix argument (C-u), publish all projects found in the target-list of this buffer.

Note:
Since a file containing org-pm tags can be anywhere outside an org-mode project folder, one cannot use org-publish-current-project to automatically provide the target project based on the file.  Therefore, use =org-pm-publish= instead to select the desired project to publish from a list of projects that are targeted by the current file.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-publish (all)
    "Publish projects to which the current buffer exports.
  If called without prefix argument, select project to publish from menu.
  If called with prefix argument, publish all projects to which current buffer exports."
    (interactive "P")
    (if all
        (dolist (project (org-pm-get-export-projects)) (org-publish project))
      (org-publish (org-pm-select-project))))

  (defun org-pm-select-export-project ()
    "Select a project from the list of projects that the current buffer exports to."
    (interactive)
    (let* ((projects (org-pm-get-export-projects))
           (index (grizzl-make-index projects)))
      (grizzl-completing-read "Select a project: " index)))

  (defun org-pm-get-export-projects ()
    "Get list of all projects that the current buffer exports to."
    (save-excursion
      (save-restriction)
      (widen)
      (let ((projects nil))
       (org-map-entries
        (lambda ()
          (dolist
              (project
               (-map (lambda (p) (car (org-pm-parse-tag p)))
                     (-filter (lambda (tag) (string-match "^_.*_$" tag))
                              (plist-get (cadr (org-element-at-point)) :tags))))
            (add-to-list 'projects project))))
       projects)))

#+END_SRC

* DONE Project Definition Commands
|-----------------------+----------------------------------------|
| Shortcut              | Command                                |
|-----------------------+----------------------------------------|
| *PROJECT DEFINITIONS* |                                        |
|-----------------------+----------------------------------------|
| H-m p e or H-m p s    | org-pm-show-project-definition-section |
| H-m p t               | org-pm-edit-project-template           |
| H-m p l               | org-pm-project-def-list |
| H-m p d               | org-pm-list-duplicate-project-defs     |
| C-u H-m p d           | pm/edit-duplicate-project-def          |
|-----------------------+----------------------------------------|

** DONE org-pm-show-project-definition-section

#+BEGIN_SRC emacs-lisp
  (defun org-pm-show-project-definition-section ()
    "Mark all sections tagged PROJECT_DEFS.
    Additionally go to the first section tagged PROJECT_DEFS, if it exists."
    (interactive)
    (let ((defs (org-map-entries '(cadr (org-element-at-point)) "PROJECT_DEFS")))
      (cond
       (defs
         (org-match-sparse-tree nil "PROJECT_DEFS")
         (goto-char (plist-get (car defs) :begin))
         (recenter-top-bottom '(4))
         (message "Showing location of first project definition section."))
       (t (message "No project definitions were found in this file.")))))
#+END_SRC
** DONE org-pm-edit-project-template

Edit the file containing the global project template.
Note that edits may cause conflicts when updating org-pm from git.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-edit-project-template ()
    "Edit the file containing the global project template.
  Note that edits may cause conflicts when updating org-pm from git."
    (interactive)
    (find-file org-pm-project-template-file-name))
#+END_SRC

** org-pm-source-file-menu

#+BEGIN_SRC emacs-lisp
  (defun org-pm-source-file-menu ()
      "Select and open a file from the list of files containing sections
    that are exported by org-pm."
      (interactive)
      (let* ((paths (-map 'car org-pm-section-exports))
             (index (grizzl-make-index paths))
             (answer (grizzl-completing-read "Select a file: " index)))
        (find-file answer)))
#+END_SRC

** org-pm-target-file-menu

#+BEGIN_SRC emacs-lisp
  (defun org-pm-target-file-menu ()
    "Select and open a file from the list of files containing sections
    that are exported by org-pm."
    (interactive)
    (let* ((paths)
           (index)
           (answer))
      (dolist (file org-pm-section-exports)
        (dolist (section (cdr file))
         (dolist (pair (cddr section)) (if (car pair) (add-to-list 'paths (car pair))))))
      (setq index (grizzl-make-index paths))
      (setq answer (grizzl-completing-read "Select a file: " index))
      (find-file answer)))
#+END_SRC

** org-pm-show-source

#+BEGIN_SRC emacs-lisp
  (defun org-pm-open-source-of-this-file ()
    "Show the section that produced the present file:

  Open the file which contains the section from which the
  present buffer's file was exported, and go to that section"
    (interactive)
    (let (paths section-id found-p source-file
                (this-file (buffer-file-name (current-buffer))))
      (when this-file
        (dolist (file-sections org-pm-section-exports)
          (setq source-file (car file-sections))
          (dolist (section (cdr file-sections))
            (setq section-id (cadr section))
            (dolist (pair (cddr section))
              (when (and (car pair) (equal (file-truename (car pair)) this-file))
                (setq found-p t)
                (find-file source-file)
                (widen)
                (beginning-of-buffer)
                (search-forward section-id)
                (org-back-to-heading)
                (recenter-top-bottom '(4))
                (org-show-subtree))))))
      (unless found-p (message "Could not find a source for file %s" (buffer-name)))))

#+END_SRC

** org-pm-show-target

#+BEGIN_SRC emacs-lisp
  (defun org-pm-open-target-of-this-file ()
    "Open a target from the list of targets of this section or
  any of its super-sections."
    (interactive)
    (let (paths path index)
      (save-excursion
        (save-restriction
          (widen)
          (org-back-to-heading)
          (while (and (not (setq paths (org-pm-get-1-section-project-paths)))
                      (org-current-level > 1))
           (org-up-heading-safe))))
      (cond (paths
             (cond ((> (length paths) 1)
                    (setq index (grizzl-make-index paths))
                    (setq path (grizzl-completing-read "Select target: " index)))
                   (t (setq path (car paths))))
             (find-file path))
            (t (message "No targets found for %s" (org-get-heading))))))
#+END_SRC

** DONE org-pm-project-def-list
CLOSED: [2013-12-22 Sun 14:30]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-project-def-list ()
    "Build list of projects with links to file and node containing the project definition,
  in a separate org-mode buffer, and provide links to both file and section.
  Also list duplicate project definitions,
  i.e. definitions of same name that are found in more than one file or section.
  Note: static and combined projects created by the system
  are not checked and added as duplicates by org-pm-check-add-project.
  But they are in org-publish-project-alist, which we use for this list.
  So we filter them out."

    (interactive)

    (if (equal 0 (length org-publish-project-alist))
        (error "There are no project definitions at all."))

    (let ((buffer (get-buffer-create "*org-pm-project-definitions*"))
          node-id dir)
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "PROJECT DEFINITIONS")
      (dolist (project (-remove (lambda (proj)
                                  (or (string-match "^combined_" (car proj))
                                      (string-match "^static_" (car proj))))
                                org-publish-project-alist))
        (setq node-id (plist-get (cdr project) :node-id))

        (insert "\n** "
                (car project)
                " (click [[elisp:(org-pm-search-link \""
                (plist-get (cdr project) :project-id)
                "\")][*HERE*]] to edit definition)\n")
        (setq dir (plist-get (cdr project) :base-directory))
        (insert "base dir: [[elisp:(dired\"" dir "\")][" dir "]]\n" )
        (setq dir (plist-get (cdr project) :publishing-directory))
        (insert "publishing dir: [[elisp:(dired\"" dir "\")][" dir "]]\n" )
        (insert "file: file:" (plist-get (cdr project) :node-filename) "\n")
        (insert "node: id:" node-id "\n")
        (let ((duplicates (cdr (assoc (car project) org-pm-project-def-duplicates))))
          (if duplicates
              (dolist (def duplicates)
                (let ((path-and-id (split-string def "::#")))
                  (insert "\n*** duplicate: ")
                  (insert
                   " (click [[elisp:(org-pm-search-link \""
                   def
                   "\")][*HERE*]] to edit)"
                   )
                  (insert "\nfile: file:" (car path-and-id) "\n")
                  (insert "node: " "id:" (cadr path-and-id) "\n")))
            (insert "\nThere no duplicate definitions for this project!\n"))))))
#+END_SRC

#+RESULTS:
: org-pm-project-def-list

*** DONE org-pm-search-link
CLOSED: [2013-12-22 Sun 18:45]

Currently, links to IDs that are not in org-link-locations are not found by org-mode.  =org-pm-search-link= finds such links by going to the file and then searching for the property with the id of the link.  It is used in org-pm-project-def-list to enable jumping to links of duplicate project defs.  It can also be used for the same purpose in lists of components.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-search-link (link)
    (let ((file-and-id (split-string link "::#")))
      (find-file (car file-and-id))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr file-and-id)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (recenter-top-bottom 1)
      (message "
  ---> Marked the entire section containing project definition.
  Type C-space C-space to de-select region and deactivate mark.")))
#+END_SRC

#+RESULTS:
: org-pm-search-link

** DONE org-pm-list-dupicate-project-defs
CLOSED: [2013-12-22 Sun 12:21]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-duplicate-project-defs ()
    "List project definitions of same name that are found in more than one file or section.
  Do this in a separate org-mode buffer, and provide links to both file and section."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no duplicate project definitions at all.\n!!! ... YAyyy ... !!!"))

    (let ((buffer (get-buffer-create "*org-pm-project-def-duplicates*")))
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "DUPLICATE PROJECT DEFINITIONS")
      (dolist (project org-pm-project-def-duplicates)
        (let ((project-name (car project)))
          (insert "\n** " project-name "\n")
          (dolist (def (cdr project))
            (let ((path-and-id (split-string def "::#")))
              (insert "file: file:" (car path-and-id) "\n")
              (insert "node: " "id:" (cadr path-and-id) "\n")))))
      ))
#+END_SRC

** DONE pm/edit-duplicate-project-def

Note: Naming this function org-pm-edit-duplicate-project-def disabled the auto-display of selections in the command line.  Something with org-mode recognizing names of functions and changing the meaning of completing-read?

#+BEGIN_SRC emacs-lisp
  (defun pm/edit-duplicate-project-def ()
    "Select a project definition from the list of found duplicates, and
  go to the containing file at the selected location, so as to edit the
  duplicate definition (or to remove it)."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no project definitions to edit."))
    (let ((definitions (mapcar (lambda (p) (car p)) org-pm-project-def-duplicates))
          definition def-address)
      (setq project
            (completing-read "Select project: " definitions nil t (car definitions)))
      (setq definitions (cdr (assoc project org-pm-project-def-duplicates)))
      (setq project
            (completing-read "Select definition: " definitions nil t (car definitions)))
      (setq def-address (split-string project "::#"))
      (find-file (car def-address))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr def-address)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (message "
  Marked the entire section containing duplicate project definition.
  Type C-space C-space to de-select region and deactivate mark")
      ))
#+END_SRC

#+RESULTS:
: pm/edit-duplicate-project-def


** DONE org-pm-post-project-def
:PROPERTIES:
:DATE:     <2014-01-05 Sun 19:11>
:END:

Select a project interactively and post its definition.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-post-project-def ()
    "Select a project interactively and post its definition."
    (interactive)
    (let ((project-name
           (grizzl-completing-read
            "Which project? "
            (grizzl-make-index (mapcar 'car org-publish-project-alist)))))
      (message "THIS IS THE DEFINITION OF PROJECT %s:\n%s"
               project-name
               (assoc project-name org-publish-project-alist))))
#+END_SRC


* UNDERWAY Target File List Commands
|--------------------------+---------------------------------------------|
| Shortcut                 | Command                                     |
|--------------------------+---------------------------------------------|
| *TARGET FILE LISTS*      |                                             |
|--------------------------+---------------------------------------------|
| H-m f                    | org-pm-list-exported-files (current buffer) |
| C-u H-m f                | org-pm-list-exported-files (all)            |
| H-m ?????   (TODO)       | org-pm-show-target-file-list ???            |
|--------------------------+---------------------------------------------|

** UNDERWAY File menu of exported sections
#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-exported-files (&optional all-p)
    "Create a list of paths of all files which the current file and its sections
  outputs to.  Present this as a grizzl list for auto-complete search.
  Open selected file.
  If called with argument, list exported sections from all files contained
  in assoc-list org-pm-section-exports."
    (interactive "P")
    (let* ((source-files
            (if all-p
                org-pm-section-exports
              (list (assoc (buffer-file-name) org-pm-section-exports))))
           paths index selected-path)
      (dolist (sections source-files)
        (dolist (section (cdr sections))
          (dolist (path-project (cddr section))
            (if (car path-project) (add-to-list 'paths (car path-project))))))
      (setq index (grizzl-make-index paths))
      (setq selected-path (grizzl-completing-read "Choose file to open: " index))
      (if selected-path (find-file selected-path))))

#+END_SRC

** TODO org-pm-show-target-file-list


* DONE Saved Data Commands
|--------------------------+---------------------------------------------|
| Shortcut                 | Command                                     |
|--------------------------+---------------------------------------------|
| *SAVED DATA*             |                                             |
|--------------------------+---------------------------------------------|
| H-m d l                  | org-pm-load-project-data                    |
| H-m d s                  | org-pm-save-project-data                    |
| H-m d r or H-m d c       | org-pm-reset-project-list                   |
| H-m d e                  | org-pm-edit-saved-project-data              |
|--------------------------+---------------------------------------------|

** DONE org-pm-load-project-data

#+BEGIN_SRC emacs-lisp
  (defun org-pm-load-project-data ()
    "Load project alist, project file lists, duplicate project def lists
  from previously saved date on disk."
    (interactive)
    (if (file-exists-p org-pm-project-data-file-path)
        (load-file org-pm-project-data-file-path)))
#+END_SRC

#+RESULTS:
: org-pm-load-all-project-data

** DONE org-pm-save-project-data

#+BEGIN_SRC emacs-lisp
  (defun org-pm-save-project-data ()
    "Load project alist, project file lists, duplicate project def lists
  from previously saved date on disk."
    (interactive)
    (dump-vars-to-file
     '(org-publish-project-alist
       ;; org-pm-file-exports
       org-pm-section-exports
       org-pm-project-def-duplicates)
     org-pm-project-data-file-path))

  (defun dump-vars-to-file (varlist filename)
    "simplistic dumping of variables in VARLIST to a file FILENAME"
    (save-excursion
      (let ((buf (find-file-noselect filename)))
        (set-buffer buf)
        (erase-buffer)
        (dump varlist buf)
        (save-buffer)
        (kill-buffer))))

  (defun dump (varlist buffer)
    "insert into buffer the setq statement to recreate the variables in VARLIST"
    (loop for var in varlist do
          (print (list 'setq var (list 'quote (symbol-value var)))
                 buffer)))
#+END_SRC


** DONE org-pm-reset-project-list / org-pm-clear-project-defs

#+BEGIN_SRC emacs-lisp
  (defun org-pm-reset-project-list ()
    "Set org-publish-project-alist to nil.  Save"
    (interactive)
    (cond ((y-or-n-p "Really erase all projects and save?")
           (setq org-publish-project-alist)
           (org-pm-save-project-data))))
#+END_SRC


** DONE org-pm-edit-saved-project-data

Edit the file containing the auto-saved data for org-pom.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-edit-saved-project-data ()
    "Edit the file containing the global project data."
    (interactive)
    (find-file org-pm-project-data-file-path))
#+END_SRC


* Auxiliary functions + Fixes
:PROPERTIES:
:DATE:     <2013-12-18 Wed 17:24>
:END:

** DONE Functions for adding, removing and replacing elements in a-lists
CLOSED: [2013-12-19 Thu 09:01]
:PROPERTIES:
:ID:       6F334A92-6B8C-473B-B8C5-1BAFB70F819F
:END:

#+BEGIN_SRC emacs-lisp
  (defun assoc-add (alist key element)
    "Add element to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons element (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key element) (cdr alist)))
          (setq alist (list (list key element))))))
    alist)

  (defun assoc-remove (alist key element)
    "Remove element from the sublist of alist whose car is equal to key."
    (when alist
      (let ((sublist (assoc key alist)))
        (when sublist
          (setcdr sublist(remove element (cdr sublist)))
          (if (equal 1 (length sublist)) (setq alist (remove sublist alist))))
        alist)))

  (defun assoc-remove-key (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))

    ;;; older version
  (defun assoc-remove-key-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))

  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
       add (cons key newlist) to alist."
    (setq alist (assoc-remove-key alist key))
    (setq alist (cons (cons key newlist) alist)))

#+END_SRC

** DONE Get header properties: org-get-header-property
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-get-header-property (property &optional all)
    "Get property from buffer variable.  Returns only fist match except if ALL is defined.
  NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
    (with-current-buffer
        (current-buffer)
      (save-excursion
        (save-restriction
          (save-match-data
            (widen)
            (goto-char (point-min))
            (let (values)
              (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
                (add-to-list 'values (substring-no-properties (match-string 1))))
              (if all
                  values
                (car values))))))))
#+END_SRC

** Get section properties: org-get-section-properties
:PROPERTIES:
:DATE:     <2014-01-15 Wed 02:32>
:TEST: 123
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-get-section-properties (properties)
    "Return values of each of the properties in list properties,
  as separate values.  Can be used with multiple-value-bind to set
  each one of several variables to the value of each property in properties list."
    (save-excursion
      (org-back-to-heading)
      (let ((plist (cadr (org-element-at-point))))
        (values-list
         (-map (lambda (p) (plist-get plist (intern (concat ":" p)))) properties)))))
#+END_SRC

#+RESULTS:
: org-get-section-properties

#+BEGIN_SRC elisp
(org-get-section-properties '("DATE" "TEST"))
#+END_SRC

#+RESULTS:
| <2014-01-15 Wed 02:32> | 123 |

#+BEGIN_SRC elisp
  (multiple-value-bind (date test)
      (org-get-section-properties '("DATE" "TEST"))
    test)
#+END_SRC

#+RESULTS:
: 123

** TODO Fix grizzl-completing-read prompt argument use

#+BEGIN_SRC emacs-lisp
  ;; Fix grizzl-completing-read to display custom prompt
  (require 'grizzl)
  (defun grizzl-completing-read (prompt index)
    "Performs a completing-read in the minibuffer using INDEX to fuzzy search.
  Each key pressed in the minibuffer filters down the list of matches."
    (minibuffer-with-setup-hook
        (lambda ()
          (setq *grizzl-current-result* nil)
          (setq *grizzl-current-selection* 0)
          (grizzl-mode 1)
          (lexical-let*
              ((hookfun (lambda ()
                          (setq *grizzl-current-result*
                                (grizzl-search (minibuffer-contents)
                                               index
                                               ,*grizzl-current-result*))
                          (grizzl-display-result index prompt)))
               (exitfun (lambda ()
                          (grizzl-mode -1)
                          (remove-hook 'post-command-hook    hookfun t))))
            (add-hook 'minibuffer-exit-hook exitfun nil t)
            (add-hook 'post-command-hook    hookfun nil t)))
      (read-from-minibuffer (if prompt prompt ">>> "))
      (grizzl-selected-result index)))

#+END_SRC


** Set state of current heading to COMMENT

This function is derived by modifying org-toggle-comment.

#+BEGIN_SRC emacs-lisp
  (defun org-set-comment ()
    "Change the COMMENT state of an entry to COMMENT.
  Do *not* remove COMMENT state if already present.
  This function is derived from org-toggle-coment."
    (interactive)
    (save-excursion
      (org-back-to-heading)
      (let (case-fold-search)
        (cond
         ((looking-at (format org-heading-keyword-regexp-format
                              org-comment-string))
          ;; if comment was found, then do nothing:
          )
         ((looking-at org-outline-regexp)
          (goto-char (match-end 0))
          (insert org-comment-string " "))))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-;") 'org-set-comment))
#+END_SRC


* Load project data at init time

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-pm" '(org-pm-load-project-data))
#+END_SRC

* Provide org-pm library

#+BEGIN_SRC emacs-lisp
(provide 'org-pm)
#+END_SRC

* COMMENT Project Definitions                                  :PROJECT_DEFS:
** org_pm
:PROPERTIES:
:ID:       5F6A7EFA-7491-49CB-9985-26D53BB17F34
:END:
*** base-directory "/Users/iani2/Documents/Dev/Emacs/org-publish-meta/"
*** base-extension "org"
*** recursive t
*** publishing-directory "/ssh:iani@larigot.avarts.ionio.gr:Sites/org-pm/"
*** publishing-function 'org-html-publish-to-html
*** headline-levels 4
*** auto-preamble t
*** section-numbers nil
*** with-toc t
*** html-preamble t
*** with-author t
*** with-creator t
*** with-emphasize t
*** with-sub-superscript nil
*** with-tables t
*** with-tags t
*** with-tasks t
*** with-todo-keywords nil
*** html-head-include-scripts t
*** with-latex t
*** with-drawers nil
*** html-link-up "{{.}}/"
*** html-link-home "{{.}}/"
*** toc-heading "Contents"
*** html-head
<link href="{{.}}/static/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="{{.}}/static/worg.min.css" rel="stylesheet" type="text/css">
*** html-head-include-default-style nil
*** html-head-include-scripts nil
*** static_base-directory "/Users/iani2/Documents/Dev/Emacs/org-publish-meta/static/"
*** static_publishing-directory "/ssh:iani@larigot.avarts.ionio.gr:Sites/org-pm/static/"
*** static_base-extension "css\\|js\\|less\\|scss\\|php\\|rb\\|py\\|pdf\\|jpg\\|gif\\|png"
*** static_publishing-function 'org-publish-attachment
*** static_recursive t
