#+TODO: TODO UNDERWAY | DONE CANCELLED
* Command for loading this file manually
:PROPERTIES:
:ID:       DE05B7A2-2C3F-4AB8-B3AF-E2670087E570
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-babel-load-current-file ()
    (interactive)
    (org-babel-load-file (buffer-file-name (current-buffer))))
  (global-set-key (kbd "C-c C-=") 'org-babel-load-current-file)
#+END_SRC

#+RESULTS:
: org-babel-load-current-file

* UNDERWAY Variables
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:52>
:END:

** DONE org-pm-files
:PROPERTIES:
:ID:       A8ABC239-E74B-4654-9850-53C8521E50BA
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-files nil
  "List of files to be copied to projects.
  For each file, store a list startig with the full path of the file, and
  followed by the list of projects specified in the file
  or any of its sections:
    (full-path-of-file project1 project2 ...)
  Function org-pm-register-project-components scans a file, creates its list
  and puts it in org-pm-files.
  Function org-pm-copy-to-project searches through all lists in org-pm-files,
  collects the list of files that belong to a project,
  parses each file to find which components should be copied,
  and copies the found components to the project.
  ")
#+END_SRC

#+RESULTS:
: org-pm-files

** DONE org-pm-duplicate-project-defs
CLOSED: [2013-12-21 Sat 22:07]

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-def-duplicates nil
    "List of links to files/sections which contains project definitions
  that were overwritten because another definition with the same name was found.
  Auto-saved together with org-publish-project-alist and org-pm-files.
  Used to create org-mode buffer with links to these locations.
  See functions:
  - org-pm-check-add-project
  - org-pm-list-dupicate-project-defs
  - org-pm-list-project-defs
  - pm/edit-duplicate-project-def"
  )
#+END_SRC

#+RESULTS:
: org-pm-project-def-duplicates

** DONE org-pm-auto-parse
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       03CF07FC-5FD7-46C6-BE11-74C3D339A315
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-auto-parse nil
    "If not nil, automatically parse a org-mode buffer
   for org-pm data before saving it.")
#+END_SRC

** DONE org-pm-auto-copy
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       3AF37A0C-F14A-41A3-B477-5B12696315BE
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-auto-copy nil
  "If not nil, automatically copy file components to a project to the
  project's source folder before publishing.")
#+END_SRC

** DONE org-pm-project-data-file-path
CLOSED: [2013-12-18 Wed 15:23]
:PROPERTIES:
:ID:       A71224C0-989C-419B-A7B6-2B0CEC64CEE7
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-data-file-path nil
  "Path of file for storing org-publish-project-alist and
  org-pm-files.  If nil, the path is deduced from the existence
  of .emacs.d folder in user's home directory.
  If .emacs.d exists, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.
  Create savefile folder if it does not exist.")
#+END_SRC

** DONE org-pm-default-project-name
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       3C9E0229-923D-4527-B2FE-903792AA5452
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-name "org-pm-default"
  "Name of default, auto-generated project.")
#+END_SRC

** DONE org-pm-default-project-org-folder
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       3475B9CF-FDDF-4760-8CF1-FE22DC2AA589
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-org-folder "~/pm-org"
  "Path of folder for source files of default project.")
#+END_SRC

** DONE org-pm-default-project-html-folder
CLOSED: [2013-12-18 Wed 15:28]
:PROPERTIES:
:ID:       92AFE11D-6A08-4D77-A2E9-BF0A196271F8
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-html-folder "~/pm-html"
    "Path of folder for html (published website) files of default project.")
#+END_SRC

** DONE org-pm-default-project-plist
CLOSED: [2013-12-18 Wed 22:16]
:PROPERTIES:
:ID:       7539D61D-95E4-4308-B1C4-F86669E921B7
:END:
#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-plist
    '(
      :base-extension "org"
      :recursive t
      :publishing-function org-publish-org-to-html
      :headline-levels 5
      :auto-preamble t
    )
  "The defalt properties for publishing a project with html.
  Used to provide initial contents when creating a project plist in
  org-pm-make-default-project-plist. "
  )
#+END_SRC

** TODO org-pm-project-template-name
:PROPERTIES:
:ID:       9D5B4E5D-90E1-4F32-842D-620B262665AF
:END:

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-project-template-name
    (concat (file-name-directory (or load-file-name (buffer-file-name)))
            "org-pm-project-template.org")
  "Full path of file containing template of project definition for
  projects generated automatically with org-pm-make-project-template-file.
  The path is initialized at code loading time by function org-pm-init-project-template-name.
  org-pm-make-project-template-file uses it to make project templates.")
#+END_SRC

* Auxiliary functions
:PROPERTIES:
:DATE:     <2013-12-18 Wed 17:24>
:END:

** Utility functions for saving emacs lisp data
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

#+BEGIN_SRC elisp

  (defun dump-vars-to-file (varlist filename)
    "simplistic dumping of variables in VARLIST to a file FILENAME"
    (save-excursion
      (let ((buf (find-file-noselect filename)))
        (set-buffer buf)
        (erase-buffer)
        (dump varlist buf)
        (save-buffer)
        (kill-buffer))))

  (defun dump (varlist buffer)
    "insert into buffer the setq statement to recreate the variables in VARLIST"
    (loop for var in varlist do
          (print (list 'setq var (list 'quote (symbol-value var)))
                 buffer)))

  (defun checkit ()
    (interactive)
    (let ((a '(1 2 3 (4 5)))
          (b '(a b c))
          (c (make-vector 3 'a)))
      (dump-vars-to-file '(a b c) "/Users/iani2/Desktop/TEST.el")))
#+END_SRC

#+RESULTS:
: checkit

** DONE Get header properties
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

#+BEGIN_SRC elisp
  (defun org-get-header-property (property &optional all)
    "Get property from buffer variable.  Returns only fist match except if ALL is defined.
  NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
    (with-current-buffer
        (current-buffer)
      (save-excursion
        (save-restriction
          (save-match-data
            (widen)
            (goto-char (point-min))
            (let (values)
              (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
                (add-to-list 'values (substring-no-properties (match-string 1))))
              (if all
                  values
                (car values))))))))
#+END_SRC

#+RESULTS:
: org-get-header-property

#+BEGIN_SRC elisp
(org-get-header-property "TEST")
#+END_SRC

** COMMENT Get drawer contents
#+RESULTS:
#+BEGIN_SRC emacs-lisp
  (defun org-get-drawer (drawer-name)
    "Get the contents of the drawer named 'drawer-name', at current section."
    (save-excursion
      (org-back-to-heading)
      (let* ((plist (cadr (org-element-at-point)))
             (node-end (plist-get plist :end))
             drawer-begin)
        (re-search-forward (format "^:%s:" drawer-name) node-end)
        (forward-char)
        (setq drawer-begin (point))
        (re-search-forward "^:END:" node-end)
        (beginning-of-line)
        (backward-char)
        (buffer-substring drawer-begin (point)))))
#+END_SRC

** DONE Functions for adding, removing and replacing elements in a-lists
CLOSED: [2013-12-19 Thu 09:01]
:PROPERTIES:
:ID:       6F334A92-6B8C-473B-B8C5-1BAFB70F819F
:END:

#+BEGIN_SRC emacs-lisp
  (defun assoc-add (alist key element)
    "Add element to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons element (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key element) (cdr alist)))
          (setq alist (list (list key element))))))
    alist)

  (defun assoc-remove (alist key element)
    "Remove element from the sublist of alist whose car is equal to key."
    (when alist
      (let ((sublist (assoc key alist)))
        (when sublist
          (setcdr sublist(remove element (cdr sublist)))
          (if (equal 1 (length sublist)) (setq alist (remove sublist alist))))
        alist)))

  (defun assoc-remove-key (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))

    ;;; older version
  (defun assoc-remove-key-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))

  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
       add (cons key newlist) to alist."
    (setq alist (assoc-remove-key alist key))
    (setq alist (cons (cons key newlist) alist))
    )

#+END_SRC

#+RESULTS:
: assoc-replace

** DONE org-pm-make-default-project-alist
CLOSED: [2013-12-19 Thu 02:12]
:PROPERTIES:
:ID:       29715E74-6E71-43C0-A50C-F312C3173645
:END:
#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-default-project-plist ()
    "Construct default plist for publishing a project in html."
    (let ((plist (copy-sequence org-pm-default-project-plist)))
      (setq plist (plist-put plist :base-directory
                             (file-truename org-pm-default-project-org-folder)))
      (setq plist (plist-put plist :publishing-directory
                             (file-truename org-pm-default-project-html-folder)))))
#+END_SRC

#+RESULTS:
: org-pm-make-default-project-plist
** DONE org-pm-add-project-file
CLOSED: [2013-12-19 Thu 09:14]
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be copied to a project base directory, add the project name to the list of projects of this file.  The list of projects of files is stored in org-pm-files.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-project-file (project-name file)
    "In list org-pm-files, add the project-name to the list
  of projects that file bel ongs. "
    (setq org-pm-files
          (assoc-add org-pm-files file project-name)))
#+END_SRC

** TODO org-pm-remove-project-file
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       1FE8167C-A514-4C21-9FC2-4A466A692E56
:END:

When a file or a section of a file should be removed from a project, remove the project name from the list of projects of this file in org-pm-files.  (The list of projects of files is stored in org-pm-files.)

NOTE: Removing components from projects is more complex than adding, because we should also remove the files of the components from the base directory of the project.  Therefore: org-pm-parse-buffer must remove any files of components that no longer exist.  How to do this?

#+BEGIN_SRC emacs-lisp
  (defun org-pm-remove-project-file (project-name file)
    "In list org-pm-files, add the project-name to the list
  of projects that file belongs. "
    (setq org-pm-files
          (assoc-add org-pm-files file project-name)))
#+END_SRC

** TODO org-pm-save-projects-and-components
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       E3ED5198-9807-4051-88E2-4A9A50A0FC7A
:END:

Save the contents of =org-publish-project-alist= and =org-pm-files= to the file specified in =org-pm-project-data-file-path=.

#+BEGIN_SRC emacs-lisp
(defun org-pm-save-projects-and-components ()

)
#+END_SRC

** TODO org-pm-add-project-to-file-header
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       3E557B48-9700-4BEE-9D72-D4AC276DCF9C
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-project-to-file-header (project-name)
    "Add property PROJECT with value project-name at beginning of file."
    (save-excursion
      (save-restriction
        (widen)
        (beginning-of-buffer)
        (insert (format "#+PROJECT: %s\n" project-name)))))
#+END_SRC

** TODO org-pm-get-section-projects
:PROPERTIES:
:DATE:     <2013-12-18 Wed 21:17>
:ID:       02A9DD60-795A-462D-A803-91E8D719560B
:END:

Get list of all projects to which any individual sections in the file should be copied. Such projects Projects are named by tags in sections.  The tags must be enclosed in underscores "_". For example, if a section has the tag =_blog_= it will be copied to be published in project named =blog=.

#+BEGIN_SRC emacs-lisp
(defun org-pm-get-section-projects ()

)
#+END_SRC

** DONE org-pm-make-project-template-file
CLOSED: [2013-12-19 Thu 02:12]
:PROPERTIES:
:ID:       36439CB5-E875-4E45-B595-5116888C9DCA
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-project-template-file (project)
    "Read file containing template of project definition for
    projects generated automatically with org-pm-make-project-template-file,
    from the synonymous file in the org-pm project source
    code folder.  Replace relevant parts of the template with
    information specific to the project.
    Finally, save the template the project's base-directory."

    ;; Consider using with-temp-buffer for constructing the template file contents

    (save-excursion
      (find-file org-pm-project-template-name)
      (let* ((filename (file-name-nondirectory org-pm-project-template-name))
             (plist (cdr project))
             (path (concat (plist-get plist :base-directory) "/" filename)))
        (unless (file-exists-p path)
          (beginning-of-buffer)
          (replace-string "PROJECTNAME" (car project))
          (beginning-of-buffer)
          (replace-string "BASEDIRECTORY" (plist-get plist :base-directory))
          (beginning-of-buffer)
          (replace-string "PUBLISHINGDIRECTORY" (plist-get plist :publishing-directory))
          (beginning-of-buffer)
          (replace-string "EXCLUDEFILE" filename)
          (write-file path)
          ;; leave buffer open for edits ?
          ;; (kill-buffer (current-buffer))
          ))))

  ;; (org-pm-make-project-template-file "test")
#+END_SRC

** TODO functions operating on org-pm-files

*** Add a project to a file component

*** Add a project to a section component

*** Remove a project from a file component

*** Remove a project from a section component

* Main functions and commands
:PROPERTIES:
:DATE:     <2013-12-18 Wed 11:16>
:END:

** New org-pm-parse-buffer draft
:PROPERTIES:
:DATE:     <2013-12-20 Fri 21:10>
:ID:       D7E1FC11-2681-47D3-B43A-E24F7EE5A215
:END:

New version, differnt approach.

Scan file to do several things:

1. Build list of all IDs of nodes that contain project definitions
2. Check for duplicates IDs. Ask to resolve them.
3. Check for duplicate projects under diffent IDs.  Ask to resolve them.
4. Build the project definitions and add them to =org-publish-project-alist=.
5. Build list of all IDs of nodes that are components of projects.
6. Check for duplicates across all files and projects.  Ask to resolve them.
7. Save list of project component section IDs and file paths to =org-pm-files=.
8. Save =org-publish-project-alist= and =org-pm-files=.

Refining, towards implementation:

#+BEGIN_SRC emacs-lisp
  (defun d1-org-pm-parse-file ()
    "DRAFT Dec 20, 2013 (9:11 PM)"
    ()
  )
#+END_SRC


** DONE org-pm-make-projects (called by org-pm-parse-buffer)
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:00>
:ID:       C4B36522-9597-4911-A829-B2414572DC06
:END:

#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-default-project-plist ()
    "Construct default plist for publishing a project in html."
    (let ((plist (copy-sequence org-pm-default-project-plist))
          (root (file-name-directory (buffer-file-name (current-buffer)))))
      (plist-put plist :base-directory (concat root "org"))
      (plist-put plist :publishing-directory (concat root "html"))))

  (defun org-pm-make-projects ()
    "Construct the projects for all project definitions found in current file.
  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_DEFS.
  Note about project definition node-IDs:
  Section IDs of project definitions are used only as links
  to point to the position in the file where a project definition is,.
  They do nod identify a project.  A project is identified by its name.
  Therefore:
  The node-id of a project is set to <full-file-path>::#<section id>.
  When a duplicate section id is found in a definition, it is replaced by a new one,
  and the new id is stored in the project."
    (let ((template (org-pm-make-default-project-plist))
          levels id ids projects)
      (org-map-entries
       '(let
            ((entry (cadr (org-element-at-point))))
          (if (member "PROJECT_DEFS" (plist-get entry :tags))
              (setq levels (cons (+ 1 (plist-get entry :level)) levels)))
          (when (equal (car levels) (plist-get entry :level))
            (setq id (org-id-get-create))
            (when (member id ids)
              (org-delete-property "ID")
              (setq id (org-id-get-create))
              (setq entry (plist-put entry :ID id)))
            (setq ids (cons id ids))
            (setq projects (cons (org-pm-parse-project-def entry template) projects))))
       "PROJECT_DEFS")
      (mapcar 'org-pm-check-add-project projects)))

  (defun org-pm-check-add-project (project)
    "Add the project definition contained in plist 'project' to org-publish-project-alist,
  replacing any previously existing definition there.  Before replacing, save any
  previously existing project whose definition is in a different file component in
  the variable org-pm-project-def-duplicates:
  If a project with the same name already exists in org-publish-project-alist,
  and that project has a different ID (file path + section ID), then the previously
  existing project definition is added to the list in org-pm-project-def-duplicates."
    (let* ((p-name (car project))
           (p-def (cdr project))
           (prev-proj (assoc p-name org-publish-project-alist))
           (prev-proj-id (plist-get (cdr prev-proj) :project-id))
           (duplicates (assoc p-name org-pm-project-def-duplicates)))
      (cond
       ((not prev-proj))
       ((equal prev-proj-id (plist-get p-def :project-id)))
       (t (setq
           org-pm-project-def-duplicates
           (assoc-replace org-pm-project-def-duplicates p-name
                          (add-to-list 'duplicates prev-proj-id)))))
      (setq org-publish-project-alist
            (assoc-replace org-publish-project-alist p-name p-def)))
    project)

  (defun org-pm-parse-project-def (proj-node template)
    "Return a project definition plist for the node represented by proj-node
    org-element plist.
  Note: project-id MUST contain both filename and node-id to be unique.
  Storing node-id is convenient for building report of duplicate projects.
  But get it from project-id?"
    (let ((pdef (copy-sequence template))
          (pname (plist-get proj-node :raw-value))
          (begin (plist-get proj-node :contents-begin))
          (node-id (plist-get proj-node :ID))
          (file-name (buffer-file-name (current-buffer))))
      (setq pdef (plist-put pdef :project-name pname))
      (setq pdef (plist-put pdef :node-id node-id))
      (setq pdef (plist-put pdef :node-filename file-name))
      (setq pdef (plist-put pdef :project-id (concat file-name "::#" node-id)))
      (setq pdef (plist-put pdef :last-updated (format-time-string "[%Y-%m-%d %a %H:%M]")))
      (cond
       (begin
        (save-excursion
          (save-restriction
            (narrow-to-region begin (plist-get proj-node :contents-end))
            (org-map-entries
             '(let* (
                     (element (cadr (org-element-at-point)))
                     (heading (plist-get element :raw-value))
                     (space (string-match " .*" heading))
                     prop-name prop-value contents-begin)
                (cond
                 (space
                  (setq prop-name (substring heading 0 space))
                  (setq prop-value (eval (read (substring heading space))))
                  (if (and
                       (equal prop-name "include-containing-file")
                       prop-value)
                      (org-pm-add-component
                       pname (buffer-file-name (current-buffer)) prop-value)))
                 (t (setq prop-name heading)
                    (setq contents-begin (plist-get element :contents-begin))
                    (if contents-begin
                        (setq
                         prop-value
                         (buffer-substring-no-properties
                          contents-begin
                          (plist-get element :contents-end))))))
                (setq pdef
                      (plist-put pdef (intern (concat ":" prop-name)) prop-value))))))))
      (cons pname pdef)))


  (defun org-pm-query-select-project (new-project old-project)
    "Check if new project definition is from a different source than old-project.
    If yes, then ask the user which of the project definitions to keep.
    Post info about the rejected definition so that user can remove or edit it.
    Return the selected project so that it is added by org-pm-add-project,
    replacing the previous entry for this project."
    (let ((selection new-project))
      (unless (equal (plist-get (cdr new-project) :source-id)
                     (plist-get (cdr old-project) :source-id))
        (setq selection (must-write-the-code-for-query-selection new-project old-project))
        (must-write-the-code-for-message-about-rejected
         (if (eq selection new-project) old-project new-project)))
      selection))

  (defun org-pm-add-project (project)
    "Add project to org-pm-project-alist.
    If previous project with same name exist, replace it."
    (setq org-publish-project-alist
          (assoc-replace org-publish-project-alist (car project) (cdr project))))

#+END_SRC

#+RESULTS:
: org-pm-add-project

For test purposes:
#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c C-x t") 'org-pm-make-projects)
#+END_SRC

#+RESULTS:
: org-pm-make-projects

** old org-pm-parse-buffer notes

This command parses the current  in order to do 3 things:

1. Create project definitions. (org-pm-make-projects)
2. Find which parts of the file are stored in which project, and store the results in org-pm-files. (org-pm-make-component-project-list)
3. Save the resulting configurations by writing =org-publish-project-alist= and =org-pm-files= to the file whose path is contained in =org-pm-project-data-file-path=

org-pm-parse-buffer can be called explicitly by the user as a command.

If org-pm-auto-parse is enabled, then it is called automatically whenever a buffer is saved.

*** IMPORTANT: When scanning for which projects are
NOTE: Removing components from projects is more complex than adding, because we should also remove the files of the components from the base directory of the project.  Therefore: org-pm-parse-buffer must remove any files of components that no longer exist.  How to do this?


** UNDERWAY org-pm-add-file-to-project:
:PROPERTIES:
:ID:       24187886-5ADA-4263-806B-8655A9813C8B
:END:

Add file to current buffer to project interactively selected or input by user.

If project name input by user does not correspond to an existing project, offer to create that project.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-file-to-project ()
    "Add the file of the current buffer to a project selected or input by the user.
      If the project selected/input by the user is not already in the file's project list:
      - If no project of that name exists, request that the project be defined using
      org-pm or other methods.
      - If no project at all exists, then offer to create default project.
      - Add the selected project to the file's list in org-pm-files.
      - Save org-pm-files.
      - Add the project name to property PROJECT in file's header."
    (interactive)
    (unless (buffer-file-name (current-buffer))
      (error "This buffer is not associated with a file.  Please save first."))
    (let* ((org-completion-use-ido t)
           (projects
            (if org-publish-project-alist
                (mapcar org-publish-project-alist 'car)
              (list org-pm-default-project-name)))
           (project-name
            (org-icompleting-read "Choose or input a project name: " projects)))
      (if (member project-name (org-pm-get-file-projects))
          (error "This file is already part of project '%s'" project-name))
      (setq project (org-pm-query-make-default-project project-name))
      (org-pm-add-project-to-file-header project-name)
      (org-pm-add-project-file project-name (buffer-file-name (current-buffer)))
      (org-pm-save-projects-and-components)
      (org-pm-make-project-template-file project)
      (message
       "Added project named: %s to file: %s\nBase directory is: %s\nPublishing directory is: %s"
       project-name
       (file-name-nondirectory (buffer-file-name (current-buffer)))
       (plist-get (cdr project) :base-directory)
       (plist-get (cdr project) :publishing-directory))))

  (defun org-pm-query-make-default-project (project-name)
    "Make a project using default settings and project-name as name."
    (unless (y-or-n-p (format "Create project '%s'? " project-name))
      (error "Project creation cancelled."))
    (let (plist)
      (setq plist (org-pm-make-default-project-plist))
      (setq plist
            (plist-put
             plist :base-directory
             (query-make-folder (plist-get plist :base-directory)
                                "Base directory:")))
      (setq plist
            (plist-put
             plist :publishing-directory
             (query-make-folder (plist-get plist :publishing-directory)
                                "Publishing directory:")))
      (cons project-name plist)))

  (defun query-make-folder (path &optional prompt-string)
    "If folder at path does not exist, then show dialog offering to user
      the option to create the indicated folder or to choose another path.
      If the path selected does not exist, create folder."
    (setq path (file-truename path))
    (unless prompt-string (setq prompt-string "Folder select or create:"))
    (let ((answer
           (read-file-name
            (format
             "%s\nSelect or input folder (folder will be created if needed):\n"
             prompt-string)
            path)))
      (unless (equal (file-truename answer) (buffer-file-name (current-buffer)))
        (setq path answer))
      (unless (file-exists-p path) (make-directory path))
      path))

#+END_SRC elisp

#+BEGIN_SRC elisp
  (let ((result
         (read-file-name "test" "~/")))
    (if (equal (file-truename result) (buffer-file-name (current-buffer)))
        "this would be the original default"
      result)
  )
#+END_SRC

#+RESULTS:
: this would be the original default

#+BEGIN_SRC elisp
(query-make-folder "~/pm-org")
#+END_SRC

#+RESULTS:
: ~/Documents/Dev/Emacs/org-publish-meta/org-pm.org

** TODO org-pm-remove-file-from-project:

Remove file from project interactively selected by user.

** TODO org-pm-add-component-to-project

Add current section (node) to a project interactively selected or input by user.

If project name input by user does not correspond to an existing project, offer to create that project.

** TODO org-pm-remove-component-from-project

Remove current section (node) from a project interactively selected by user.

** UNDERWAY org-pm-register-project-components

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
TO BE REPLACED BY org-pm-process-file
org-pm-process-file starts by incorporating the code from this function
and adds to it the copying of the components found.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Parse current buffer, looking for projects added for the whole file (with property =#+PROJECT:= or for sections (with tags enclosed in =_=). Collect names of all projects found in a list.
Put the list in the assoc list stored in =org-pm-files=, using the full path of the file as key. Function =org-pm-copy-to-project= scans this list to find if the file contains any components that should be copied to the project, and copies them.

#+begin_src emacs-lisp :tangle yes
  (defun org-pm-register-project-components ()
    "Parse current buffer, looking for projects added for the whole file (with property
  =#+PROJECT:= or for sections (with tags enclosed in =_=). Collect names of all projects
  found in a list. Put the list in the assoc list stored in =org-pm-files=, using the
  full path of the file as key. Function =org-pm-copy-to-project= scans this list to find
  if the file contains any components that should be copied to the project, and copies
   them."
    (interactive)

    (let (projects (filename (buffer-file-name (current-buffer))))
      (mapcar (lambda (project)
                (add-to-list 'projects (org-pm-get-project-name project)))
              (org-get-header-property "PROJECT" t))
      (org-map-entries
       '(let ((tags (plist-get (cadr (org-element-at-point)) :tags)))
          (dolist (tag tags)
            (if (string-match  "^_.*_$" tag)
                (add-to-list 'projects (org-pm-get-project-name tag))))
          ))
      (setq org-pm-files (assoc-replace org-pm-files filename projects))
      (message "Result: %s" projects)))

  (defun org-pm-get-project-name (name-and-folder)
    (car (split-string name-and-folder "@")))

  ;; Note: for setting the project name to the car of the split, and the
  ;; folder to the cdr of the split, see
  ;; http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node94.html
  ;; and http://clhs.lisp.se/Body/m_mult_2.htm
  ;; on how to do multiple-value-setq
  ;; Here example from site 2 above:
  ;; (multiple-value-setq (a b c) (values 1 2))
#+end_src

#+RESULTS:
: org-pm-get-project-name

** org-pm-process file (replaces: org-pm-register-project-components)

- org-pm-copy-components can be called explicitly by the user as a command.
- If org-pm-auto-copy is enabled, then it is called automatically.
- There are two ways to automate the copying:
  1. Copy whenever the file is saved.
  2. Copy whenever the project is published.

Assessment:

Version 1 lengthens the file saving time.
Version 1 lengthens the publishing time.

The accumulated delay of copying project components from all files when publishing may be more distracting than the delay of copying components of a single project.  Additionally, it is better to be able to check the condition of a project at any stage, and to have it updated as soon as a file is saved.  So I start by setting the default to copy components when the file is saved.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-copy-components ()
    "Identify and copy the components that are marked to belong to projects."

  )

  ;; This version does both the registering and the copying.
  ;; Will replace org-pm-register-project-components.
  (defun org-pm-process-file ()
    "Identify and copy the components that are marked to belong to projects.
  Parse current buffer, looking for projects added for the whole file (with property
  =#+PROJECT:= or for sections (with tags enclosed in =_=). Collect names of all projects
  found in a list. Put the list in the assoc list stored in =org-pm-files=, using the full
  path of the file as key. Function =org-pm-copy-to-project= scans this list to find if
  the file contains any components that should be copied to the project, and copies them."
      (interactive)

      (let ((filename (buffer-file-name (current-buffer)))
            projects components project file folder)
        (mapcar (lambda (project)
                  (add-to-list 'projects (org-pm-get-project-name project)))
                (org-get-header-property "PROJECT" t))
        (org-map-entries
         '(let ((tags (plist-get (cadr (org-element-at-point)) :tags)))
            (dolist (tag tags)
              (if (string-match  "^_.*_$" tag)
                  (add-to-list 'projects (org-pm-get-project-name tag))))
            ))
        (setq org-pm-files (assoc-replace org-pm-files filename projects))
        (message "Result: %s" projects)))
#+END_SRC

** TODO org-pm-publish: Select a project to publish from the projects targeted by current buffer.

Since a file containing org-pm tags can be anywhere outside an org-mode project folder, one cannot use org-publish-current-project to automatically provide the target project based on the file.  Therefore, use =org-pm-publish= instead to select the desired project to publish from a list of projects that are targeted by the current file.




** org-pm-enable-auto:

** org-pm-disable-auto:
:PROPERTIES:
:ID:       5D8EF403-7567-4C82-B919-37ED86C3D268
:END:

** DONE org-pm-list-dupicate-project-defs
CLOSED: [2013-12-22 Sun 12:21]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-duplicate-project-defs ()
    "List project definitions of same name that are found in more than one file or section.
  Do this in a separate org-mode buffer, and provide links to both file and section."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no duplicate project definitions at all.\n!!! ... YAyyy ... !!!"))

    (let ((buffer (get-buffer-create "*org-pm-project-def-duplicates*")))
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "DUPLICATE PROJECT DEFINITIONS")
      (dolist (project org-pm-project-def-duplicates)
        (let ((project-name (car project)))
          (insert "\n** " project-name "\n")
          (dolist (def (cdr project))
            (let ((path-and-id (split-string def "::#")))
              (insert "file: file:" (car path-and-id) "\n")
              (insert "node: " "id:" (cadr path-and-id) "\n")))))
      ))
#+END_SRC

** DONE org-pm-list-project-defs
CLOSED: [2013-12-22 Sun 14:30]

#+BEGIN_SRC emacs-lisp
  (defun org-pm-list-project-defs ()
    "List projects by name, giving links to file and node containing the project definition.
  Also list project definitions of same name that are found in more than one file or section.
  Do this in a separate org-mode buffer, and provide links to both file and section."

    (interactive)

    (if (equal 0 (length org-publish-project-alist))
        (error "There are no project definitions at all."))

    (let ((buffer (get-buffer-create "*org-pm-project-definitions*")))
      (switch-to-buffer buffer)
      (org-mode)
      (delete-region (point-min) (point-max))
      (org-insert-heading)
      (insert "PROJECT DEFINITIONS")
      (dolist (project org-publish-project-alist)
        ;; (insert (format "\nDEBUG %s\n\n" project))
        (insert "\n** "
                (car project)
                " (click [[elisp:(org-pm-search-link \""
                (plist-get (cdr project) :project-id)
                "\")][*HERE*]] to edit)\n")
        (insert "file: file:" (plist-get (cdr project) :node-filename) "\n")
        (insert "node: id:" (plist-get (cdr project) :node-id) "\n")
        (let ((duplicates (cdr (assoc (car project) org-pm-project-def-duplicates))))
          (if duplicates
              (dolist (def duplicates)
                (let ((path-and-id (split-string def "::#")))
                 (insert "\n*** duplicate: ")
                 (insert
                  " (click [[elisp:(org-pm-search-link \""
                  def
                  "\")][*HERE*]] to edit)"
                  )
                 (insert "\nfile: file:" (car path-and-id) "\n")
                 (insert "node: " "id:" (cadr path-and-id) "\n")))
            (insert "\nThere no duplicate definitions for this project!\n"))))))

#+END_SRC

#+RESULTS:
: org-pm-list-project-defs

*** DONE org-pm-search-link
CLOSED: [2013-12-22 Sun 18:45]

Currently, links to IDs that are not in org-link-locations are not found by org-mode.  =org-pm-search-link= finds such links by going to the file and then searching for the property with the id of the link.  It is used in org-pm-list-project-defs to enable jumping to links of duplicate project defs.  It can also be used for the same purpose in lists of components.

#+BEGIN_SRC emacs-lisp
  (defun org-pm-search-link (link)
    (let ((file-and-id (split-string link "::#")))
      (find-file (car file-and-id))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr file-and-id)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (message "
  Marked the entire section containing project definition.
  Type C-space C-space to de-select region and deactivate mark.")))
#+END_SRC

#+RESULTS:
: org-pm-search-link

** UNDERWAY pm/edit-duplicate-project-def

Note: Naming this function org-pm-edit-duplicate-project-def disabled the auto-display of selections in the command line.  Something with org-mode recognizing names of functions and changing the meaning of completing-read?

#+BEGIN_SRC emacs-lisp
  (defun pm/edit-duplicate-project-def ()
    "Select a project definition from the list of found duplicates, and
  go to the containing file at the selected location, so as to edit the
  duplicate definition (or to remove it)."

    (interactive)

    (if (equal 0 (length org-pm-project-def-duplicates))
        (error "There are no project definitions to edit."))
    (let ((definitions (mapcar (lambda (p) (car p)) org-pm-project-def-duplicates))
          definition def-address)
      (setq project
            (completing-read "Select project: " definitions nil t (car definitions)))
      (setq definitions (cdr (assoc project org-pm-project-def-duplicates)))
      (setq project
            (completing-read "Select definition: " definitions nil t (car definitions)))
      (setq def-address (split-string project "::#"))
      (find-file (car def-address))
      (beginning-of-buffer)
      (re-search-forward (concat ":ID: +" (cadr def-address)))
      (org-back-to-heading)
      (org-show-subtree)
      (org-mark-element)
      (message "
  Marked the entire section containing duplicate project definition.
  Type C-space C-space to de-select region and deactivate mark")
      ))


#+END_SRC

#+RESULTS:
: pm/edit-duplicate-project-def




* Cleaning up duplicate links and dead projects+files

1. Some sections may have duplicate IDs, created by copy-pasting sections.
2. When a project definition is copied or renamed, this may result in having duplicate definitions, i.e. multiple project definitions with the same name in different places.  Which is the one to work with.
3. When a project definition is renamed or removed, the one stored under its previous name becomes orphaned. What to do?
4. When a project component is deleted or moved to another project, or when the project or folder or name of the file where it should be copied changes, then the old file becomes orphaned.   What to do?

Dealing with the above:

1. One can use org-id-update-id-locations to both find all ids and all duplicates.
2. is possible to check as soon as it happens, because the moment a new project gets defined one can check if the already existing definition is in the same file.  Registering duplicate projects defintions in org-pm-projectd-def-duplicates.  Function org-pm-list-project-defs creates buffer listing all project defs, including duplicates, and provides links for going to any one of thse in order to edit/remove.
3. could be delegated to commands that a user can call independently of the main specification and publishing process.
4. could be handled like No. 3.
