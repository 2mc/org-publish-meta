#+TODO: TODO UNDERWAY MUST_REVISIT | DONE CANCELLED

* org-publish-meta: Extending org-publish
:PROPERTIES:
:DATE:     <2013-11-20 Wed 20:08>
:END:

** Note: Current dynsite publishing setup example code
:PROPERTIES:
:DATE:     <2013-12-02 Mon 17:49>
:END:

Noting this code down here as example to guide new version, even if the principles of the new version will be very different. 

*** Publish                                                        :noexport:

#+BEGIN_SRC sh
cp "/Users/iani2/Dropbox/000WORKFILES/org/work/publications/articleforsoundscapejournal201310_solomos/SoundscapeJournalArticleIZ201310.org" "/Users/iani2/SitesSource/larigot-iani/papers/"
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp

(require 'dynsite)

(org-install-site
	'("larigot-iani"
	"/Users/iani2/SitesSource/larigot-iani"
	"/Users/iani2/Sites"))

(org-set-site (car org-sites))

#+END_SRC

#+RESULTS:
: project defs created: (all-all AVA940HMI<classes<larigot-iani-static AVA940HMI<classes<larigot-iani-all AVA940HMI<classes<larigot-iani classes<larigot-iani-static classes<larigot-iani-all classes<larigot-iani larigot-iani-static larigot-iani-all larigot-iani)

** Publishing principles, specification, options, format + feature considerations
:PROPERTIES:
:DATE:     <2013-12-02 Mon 08:52>
:ID:       2C1A8D6A-7A07-4825-9557-D8026FCD3377
:END:

Publishing principle: Do not convert the source org-mode file directly into an HTML file.  Instead, copy the entire file plus optionally some subnodes of the file as org-mode files into a folder belonging to one or more org-mode publish projects, and then publish those projects.  This makes it possible to selectively publish different files and different parts of files in different projects as needed.  Nodes that are marked with a tag in order to be copied into project folders as separate org files.  These nodes are removed from the original file, if the original file is also published.  (NOTE: Under consideration is an optional [[id:BA6F1997-EC76-4C9E-A33B-0B1D4370829D][summary feature]] for putting a summary of a node in place of that node in the original file).  The default tag for publishing is =publish=.  The name of each file to be published is automatically generated from the heading of the node.  The property :FILE: can be used to customize the file name for saving.  Links between files are converted from org-mode style links on the basis of custom IDs (see http://orgmode.org/manual/Handling-links.html#fn-2, the proper setup for creating IDs is included in the present package).  

One can customize the manner in which parts of the file are copied through the properties =PUBLISH= and =PUBLISH_TAGS=.  Additionally one can use the property =TAGS_INDICATE_FOLDERS= to indicate that tags should be used as names of folders (subfolders of the org-publish-project folder) into which the published files will be copied.  Finally it is considered to use =TAG_PUBLISH_MODE= to indicate whether the tags should be used as names of folders or projects to copy the node contents into. 

One could even publish one node to several projects by listing these projects in a property =extra_projects= in the node's property list. 

*** Property =PUBLISH= : Mode of publishing
:PROPERTIES:
:DATE:     <2013-12-03 Tue 06:15>
:END:
The property =PUBLISH= can have two values: =all= or =nodes=.  A value of =all= indicates to copy the entire file, while removing only those nodes which are marked with tags for publishing as separate files (see below).  A value of =nodes= indicates that only the nodes marked with a tag (default: =publish=) will be published, as separate files, while the original file to which they belong will not be published.  Thus: 

- #+PUBLISH: all :: Publish both this file and any nodes marked with tag =publish= (or other custom tags).
- #+PUBLISH: nodes ::  Publish only nodes that have the tag =publish= (or other custom tags).
*** CANCELLED Property =PUBLISH_TAGS= : Which tags mark nodes for publishing
CLOSED: [2013-12-05 Thu 03:04]
:PROPERTIES:
:DATE:     <2013-12-03 Tue 06:15>
:END:

The property PUBLISH_TAGS optionally specifies which tags indicate to publish a nodes as separate files.  For example:

- #+PUBLISH_TAGS: blog intro news tutorial :: Tags marked with one of =blog=, =intro=, =news= or =tutorial= will be published as separate files (note: this feature could also be used to indicate which folders or even projects the contents of the nodes should be copied to.  To indicate this, we may use the value of property =TAG_PUBLISH_MODE=)

*** Shorter alternative to =PUBLISH_TAGS= : mark publish tags by enclosing in special chars
:PROPERTIES:
:DATE:     <2013-12-05 Thu 02:30>
:END:

Instead of listing all tags for publishing in a property, use a special marker to indicate that a tag denotes publishing.  

I tried [] and *...* as markers but it seems these tags cannot be searched by the API.  But _..._ as markers work: 

- tag _test_ :: (a tag enclosed in underscore characters _) indicates that this node is to be published.
                The tag minus the _ markers can be used to indicate one of:
                - Name of project
                - Name of folder to be appended to root org path for copying.
                Note: The file name is constructed from the heading.
                Property FILE if present in node overrides the heading as filename.

*** Property =TAG_PUBLISH_MODE= : Publishing action of tags
:PROPERTIES:
:DATE:     <2013-12-03 Tue 06:16>
:END:

The property =TAG_PUBLISH_MODE= can have one of 3 values: 
- =project= :: Publish the node marker by the tag to the project whose name is the same as the tag. (This is the default value).
- =current= :: Publish the node marked by the tag by copying it to the root org folder of the project or to the folder indicated by property =FOLDER=
- =folder= :: Publish the node marked by the tag, copying it to a subfolder of the project.  The name of the subfolder is the same as the tag (minus _ chars).

The default value of =TAG_PUBLISH_MODE= is =project=.

A command can be written to swiftly add the tag of the project of the current file, or to select from all defined projects and add the tag to the current node. 

*** CANCELLED Alternative (to be considered):  Publish property to indicate 
CLOSED: [2013-12-05 Thu 03:22]
:PROPERTIES:
:DATE:     <2013-12-03 Tue 05:57>
:END:
: #+PUBLISH_PROPERTY: publish

Inherited publish property
One may inherit the PUBLISH_PROPERTY to subnodes.  Then one has to specify: Do only the last-level nodes get published?  Or nodes at a specified depth level?  This gets a bit complicated.
???: 
: #+PUBLISH_INHERIT: t 

There are different ways in which the different variants of this feature can be configured.  I should explore these variants incrementally, starting with the simplest one.  Another feature related with copying nodes of the main file to independent new files, is the "Summary" feature explained in the next section:

*** Summary feature
:PROPERTIES:
:DATE:     <2013-12-02 Mon 14:49>
:ID:       BA6F1997-EC76-4C9E-A33B-0B1D4370829D
:END:
Another feature to be considered: 
For any pubished nodes that have a drawer :DESCRIPTION:, the contents of the drawer :DESCRIPTION: will be included in the main file after a heading that contains a link to the node's html file. 

Another option for the description contents: If the value of :DESCRIPTION: is "auto", extract the description from the first n words or characters of the contents of the node.

Still another option for the summary feature: The summary could be saved as auto-summary.org in the same folder as the file that it summarizes, thereby making it possible to include the summary at any point in the file, using the include mechanism of Org-mode.   Examples from http://orgmode.org/manual/Include-files.html :

#+BEGIN_QUOTE
,#+INCLUDE: "~/.emacs" src emacs-lisp

,#+INCLUDE: "~/my-book/chapter2.org" :minlevel 1

,#+INCLUDE: "~/.emacs" :lines "5-10" 
#+END_QUOTE

(Incidentally: see also: http://orgmode.org/manual/Macro-replacement.html#fn-1)

*** Auto-navigation link feature
:PROPERTIES:
:DATE:     <2013-12-02 Mon 15:01>
:END:

Since the relationships of the nodes in the document tree (up, next, previous, down) can be deduced from the node structure of the file from which they are extracted, it is possible to use this information to automatically construct navigation links (like those produced for example by texinfo).

** TODO Describe the two main tasks separately: (a) Parse project definitions (b) Parse file/node specifications
:PROPERTIES:
:DATE:     <2013-12-03 Tue 07:52>
:END:

TODO ...

** How to set or define a project for a file or node
:PROPERTIES:
:DATE:     <2013-12-02 Mon 21:25>
:END:

*** Preparatory info: Syntax of properties and drawers            :ARCHIVE:
:PROPERTIES:
:DATE:     <2013-12-02 Mon 21:41>
:END:

NOTE: This node is archived because we will not use drawers, and we will use properties only in a straightforward way for a few basic information items (while leaving the rest of the standard way of customizing export via properties in Org-mode as it is).

See: http://orgmode.org/manual/Property-syntax.html#Property-syntax
and: http://orgmode.org/manual/Drawers.html

Testing drawers here: 

The following teests show that only those drawers are recognized as such, whose names are already defined in orgmode. 
One can do this on a per-file basis also (although for dynsite it is better to set this up globally in advance).

#+DRAWERS: HIDDEN TEST_DRAWER STATE

:HIDDEN:
This should be hidden
asdf 
:END:

Note: The contents of TEST_DRAWER do not fold, because of the underscore _.  Is this a bug?

:TEST_DRAWER:
test
asdf
:END:

:STATE:
Test again
asdf 
:END:

:RESULTS:
This is a test drawer. 
It has several lines of contents.
Next we need to test several things: 
(a) how to get the contents of the drawer with emacs lisp
(b) how to suppress the drawer for being published.
:END:

*** Project-definition and configuration nodes
:PROPERTIES:
:DATE:     <2013-12-02 Mon 21:32>
:END:

**** CANCELLED Marking project each config node with a project_config tag
CLOSED: [2013-12-05 Thu 03:22]
:PROPERTIES:
:DATE:     <2013-12-05 Thu 03:15>
:END:
- A node with tag "project_config" is parsed as containing the definition of a project (see details below, and examples in old dynsite doc).

But why do this for each config, if we can put them all together as subnodes of one tagged node.  Therefore see next alternative. 

**** Simpler alternative: Project config nodes as subnodes of a node tagged PROJECT_CONFIGS
:PROPERTIES:
:DATE:     <2013-12-05 Thu 03:22>
:END:

Keeps all configs together.  Obviates the need to add tags to each node. 
Multiple PROJECT CONFIGS nodes can be added if needed



- The heading of the node becomes the name of the project.

**** Rejected idea: supernode of config node belongs to project defined by it
:PROPERTIES:
:DATE:     <2013-12-05 Thu 03:22>
:END:

The reason for rejecting this is that it places a constraint on the supernode and also requires that config nodes become subnodes, which would hide them in overview.  It seems desirable to have all project configs together as first level nodes, for better overview.  Or one may place them all together as subnodes of a node named "project_configs". 

- The supernode of this node, or if there is no supernode, then the entire file, is assigned to this project.  See detailed description below.

For example: 

**** blog                                                 :project_config:
:PROPERTIES:
:ID:       3C190267-84C4-4AEA-86A1-00130BCFB056
:END:

Such a node will do several things: 

1. Create a project alist named after the heading of the node.
2. If the node is a first-level node (one "*"), then the whole file gets assigned to this project.
3. If the node is of level 2 or more (2 or more "*"), then the supernode of this node and all its subnodes are assigned to this project.
4. Store the path of the file under property :project-config-file.
5. Store the ID (!) of this node under property :project-config-node.  (Create unique ID if not already present).
6. Parse the contents of the node and add the resulting properties to the project alist.
7. Provide defaults for any indispensable properties which are missing from the node's contents.

Using the above info, methods will be defined to:
- open the file and node which contains the definition of a project by selecting the project name. 
  (org-pm-open-project-def)
- open in dired the org source directory of the project (org-pm-dired-org)
- open in dired the html directory of the project (org-pm-dired-html)

Important: 

Any previously existing project-alist with the same name is completely erased.  Only one node can contain the definition of a project.  Project properties cannot be added for the same project from two different nodes.  This is to avoid confusion, and also to enable correct re-definition of projects when one edits the definition node and recompiles the project.



*** How to assign the project of the entire file
:PROPERTIES:
:DATE:     <2013-12-05 Thu 03:23>
:END:

- The name of the project can also be specified in the file's header through property PROJECT.  If that property is not defined, then the name and definition of the project are deduced in the following way:
- If a node tagged PROJECT_CONFIGS exists, and contains at least one valid project definition as a subnode, then *the first* valid definition becomes the files' project config.
- If no valid project definition exists in this file, then the name of the project is taken from the name of the file sans extension.  This project is sought in the global project-alist.  If not found, then default properties are provided to make the project publishable.

*** Per-file (or node) publish properties in file or node header

Properties defined in the header of the file (with #+PROPERTY_NAME: value...) give extra specifications for the publishing of this file.  They are not copied in the project-alist.  Such properties are: 

: #+PROJECT: blog

This tries to find a project with than name (for example =blog=) from org-publish-project-alist. 
If there is no such project, a project is created and defaults are provided. 
If a first-level node of the file defines a project, then the PROJECT property in the header is ignored (One should therefore therefore not define the PROJECT property in the header if one is [[id:3C190267-84C4-4AEA-86A1-00130BCFB056][defining the project for the file in a node]]).

: #+FILE: index.org

This defines the filename under which this file or node should be saved when copied to the org source of the project.  The ending .org is provided if missing.  If no FILE property is defined, then the file name is guessed by these rules: 
- If the file or node contains a project definition subnode, then the default is "index.org"
- Else, it is created by uniting the words of the name of the file or the heading of the node, substituting any spaces (" ") by "-".

: #+FOLDER: news

If a folder is provided, then the folder is added to the org path of the project to create the path where the file/node will be copied.

All other properties relevant to the org-publish configuration rules are parsed by the org-publish and org-export functions as usual. 
Properties defined in a node must be converted to file-level properties when copying the node to a separate file.

*** Use nodes tagged file_config to include long html-head and html-head-extra strings etc.

As explained in http://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html#sec-5-1, the properties #+HTML_HEAD: and #+HTML_HEAD_EXTRA: are used to specify the html header parts of a file for export.  However, property values should be specified in a single line (see http://orgmode.org/manual/Property-syntax.html#Property-syntax).  This is inconvenient if one wants to include a long header. 

However this is cumbersome and I do not even know if it works. 

So why not use nodes for long strings that need to become property values for the html-export config of a file or node (not an entire project), like in the [[id:A1FFF0FC-3289-4D9B-99C0-8BF0029BCD5A][following example]].  Unfortunately, to insert the value of this node in the export options of a single file will require some deep exploration of html-export functions of Org mode.  [ ... ] After looking into it, following trick seems to be the most feasible one: 

For those properties that are specified by the nodes as custom-configured, such as any of html-head, html-head-extra, html-preamble, html-postamble, if a node is tagged :file_config: and has one of these as heading, do this: 

1. When copying the file to the org folder for publishing, the copy function inserts a property heading for the corresponding setting it to a special mark string, such as, for exemple, for property html-head: 

#+HTML_HEAD: =====HTML-HEAD=====

2. This will be inserted by the standard org-mode exporter in the exported file at the corresponding location

3. After that, use either a filter function (see here below) or a chain of publishing functions in the project alist, or a 'completion-function property in the project alist to substitute the string "=====HTML-HEAD=====" with the string given in the file_config node, which has been stored in the file's plist, which is inside the project-alist. 

The filter function was already tested for conversion of links, and is probably the best option.  See http://orgmode.org/worg/dev/org-export-reference.html#filter-system . The code I used recently in dynsite for filtering the full html-ized text is: 

#+BEGIN_SRC elisp
(add-to-list 'org-export-filter-final-output-functions
             'org-html-provide-relative-path)
#+END_SRC

The function =org-export-filter-final-output-functions= is documented here:  http://orgmode.org/worg/doc.html#org-export-filter-final-output-functions

The doc says about this function: 

#+BEGIN_QUOTE
List of functions applied to the transcoded string.
Each filter is called with three arguments: the full transcoded
string, the back-end, as a symbol, and the communication channel,
as a plist.  It must return a string that will be used as the
final export output.
#+END_QUOTE


Note that the exporter also inserts a ton of other stuff, which can/must be further fine-tweaked with other options if one is to make files with extremely customized html header and footer parts. 


**** html-head                                               :file_config:
:PROPERTIES:
:ID:       A1FFF0FC-3289-4D9B-99C0-8BF0029BCD5A
:END:

here is the text that will become the string that is the value of html-head property for this file/node.
It has several lines.





** ====== Current newest redo:  Projects defined in files, auto-save projects, site redo
:PROPERTIES:
:DATE:     <2013-11-30 Sat 16:37>
:END:

See this tutorial for systematics of building a project:  http://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html

*** Inheritance of project parameters in sites
:PROPERTIES:
:DATE:     <2013-11-30 Sat 17:18>
:END:

A project can contain component projects.  However, the component feature of org-publish is not equivalent to the way that dynsite handles subproejcts, because it does not entail inheritance of properties.  Therefore we need to redo inheritance functionality based on projects.  

This is not so difficult.  Consider that we have a set of projects stored in the usual manner in =org-publish-project-alist=. Then, if a project wants to inherit properties from another project, it can simply state that by storing in its alist the name of that project, as property :superproject. That would be something like: 

#+BEGIN_SRC elisp
'("project-name" :superproject "site-name" :property value  ...)
#+END_SRC

It is then easy to recursively inherit the properties descending from the top super-project to the current project, via any intermediate projects. 

There is no need to create a separate site list!

If a superproject is not found, an error should be issued. 

*** Notes on New base function: org-publish-auto-project
Consider new function: org-publish-auto-project

This function will create or deduce a project from information found in the currently selected file/buffer.  

If there is no information at all about a project in the current buffer, then it will create a new default project. 

The default name of the new project is the name of the file without extention.  

For now we will not consider the following idea, but we will take it up later:  If there is a property =super-project= defined in the current file, then the project defined by the file becomes a subproject of =super-project=, if it exists.

The contents of the variable org-publish-project-alist (see: http://orgmode.org/manual/Project-alist.html) are auto-saved in file
=~/.emascs.d/savefile/org-publish-project-alist= if ~/.emacs.d/ exists, otherwise they are saved in =~/.org-publish-project-alist=.  

Some notes about starting the beginning of org-publish-file-project: 

First call: 
Function: =org-publish-parse-project-config-node=

If there is a node called =project-config=, then this function will parse its contents and *create a new project alist* with the information contained in the node. 

Then call: 
Function: =org-publish-parse-file-config-node=

If there is a node called =project-config=, then this function will 
- Attempt to get the project name from the properties of the node
- Parse its contents and keep the information in a list, in order to use it for putting in the headers of the org files created by the org-publish-in-file-project

Then check if there is enough information about the project of the current file.  If not, try to create a default project, taking into account also any relevant properties defined in the header of the file.

If the file has the property PUBLISH_FILE set to t (true), then copy the file itself to the org target directory, but also extract any subnodes that should be copied into different files. 

Go through all nodes in the file, and if any are marked by relevant properties or tags (to be specified!), then parse their config properties and extract these and copy them as separate files to the org folder of the project to which they belong according to the specifications in the config properties, or the project of the file in which they are contained. 

After this is done, process the files of all projects contained in the file and its subnodes, and add file targets to the IDs of links to org mode files belonging to the project. 

After that, publish all projects contained in this file. 

When publishing projects:  If a project is a subproject of another project, then its files should not be published by the superproject.  So the folders of subprojects should be added to the exclude list of the superproject. 

Following is a step-by-step roadmap for building the functionality for dynsite2.

*** ========= !!!!!!!!!!!!! CURRENT IMPLEMENTATION DRAFT
:PROPERTIES:
:DATE:     <2013-12-01 Sun 17:46>
:END:

**** Auto-Load and save org-publish-project-alist
:PROPERTIES:
:DATE:     <2013-12-01 Sun 23:20>
:END:

#+BEGIN_SRC elisp
  
  (defun org-publish-get-project-alist-path ()
    ;; if ~/.emacs.d is present, use ~/.emacs.d/savefile/org-publish-project-alist
    ;; else use ~/.org-publish-project-alist
    ;; Create savefile folder if it does not exist. 
  )
  
  (defun org-publish-save-project-alist ()
    ;; to be defined
    ;; uses org-publish-get-project-alist
    )
  
  (defun org-publish-load-project-alist ()
    ;; to be defined
    ;; uses org-publish-get-project-alist
    )
  
  ;; Include the following in startup file
  (org-publish-load-project-alist) 
#+END_SRC

**** Help functions: Saving emacs lisp data to a file
:PROPERTIES:
:DATE:     <2013-12-01 Sun 23:21>
:END:

From: http://stackoverflow.com/questions/2321904/elisp-how-to-save-data-in-a-file

#+BEGIN_QUOTE
This 'dump-vars-to-file routine will create some expressions that can be read by simply evaluating the expressions later (via a 'load command or 'read):

(defun dump-vars-to-file (varlist filename)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf)
      (save-buffer)
      (kill-buffer))))

(defun dump (varlist buffer)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (loop for var in varlist do
        (print (list 'setq var (list 'quote (symbol-value var)))
               buffer)))
I'm sure I'm missing some built-in routine that does a nicer job or is more flexible.

I tested it with this little routine:

(defun checkit ()
  (let ((a '(1 2 3 (4 5)))
        (b '(a b c))
        (c (make-vector 3 'a)))
    (dump-vars-to-file '(a b c) "/some/path/to/file.el")))
Which produced the output:

(setq a (quote (1 2 3 (4 5))))
(setq b (quote (a b c)))
(setq c (quote [a a a]))
For more information, see the info page on reading and printing lisp objects:
http://www.gnu.org/software/emacs/manual/html_node/elisp/Read-and-Print.html#Read-and-Print
#+END_QUOTE

**** Help function: merge-plists
#+BEGIN_SRC elisp
  ;; dash package should be provided as file in the dynsite2 release
  (require 'dash) ;; needed for merge-plists

  (defun merge-plists (plist-a &rest plist-b)
    (-reduce-from
     (lambda (plist-a plist-b)
       (->> (-partition 2 plist-b)
         (-reduce-from
          (lambda (acc it)
            (let ((key (first it))
                  (val (second it)))
              (plist-put acc key val)))
          plist-a)))
     plist-a
     plist-b))
#+END_SRC
**** Top level function: org-publish-auto-project
:PROPERTIES:
:ID:       0B0ECFA8-544E-41DB-849A-20F19ABD5459
:END:
#+BEGIN_SRC elisp
  (defun org-publish-auto-project ()
    "Step 1 in org-publish-in-file-project func dev."
    (interactive)
    ;; load if not loaded: 
    (unless org-publish-project-alist (org-publish-load-project-alist))
    (let* 
        ((projects) ;; projects that belong to this file only.
         (default-base-directory 
           (concat (file-name-directory (buffer-file-name (current-buffer))) "org/"))
         (default-publish-directory 
           (concat (file-name-directory (buffer-file-name (current-buffer))) "html/"))
         (project-alist (org-publish-parse-project-config-node))
         (file-config (org-publish-parse-file-config-node))
         (project-name
          (or
           (plist-get project-alist :project-name)
           (plist-get file-config :project-name)
           ))
         )
      (setq project-alist
            (org-publish-provide-project-defaults 
             project-name 
             project-alist
             default-base-directory
             default-publish-directory
             ))
      (if (eq (plist-get project-alist :base-directory) default-base-directory)
          (if (not (file-exists-p default-base-directory))
              (make-directory default-base-directory)))
      (if (eq (plist-get project-alist :publish-directory) default-publish-directory)
          (if (not (file-exists-p default-publish-directory))
              (make-directory default-publish-directory)))
      (setq org-publish-project-alist
            (delq (assoc project-name org-publish-project-alist) org-publish-project-alist))
      (setq org-publish-project-alist (cons project-alist org-publish-project-alist))
      ;; Collect all projects, configs, and files contained in this file:
      (setq projects (org-parse-file-project-configs)) ;; projects local to this file
      ;; Add top-level project-alist to projects derived from contents of file:
      (setq projects (cons project-alist projects)) 
      ;; Resolve dependencies between projects, create files.
      (dolist (project projects)
        (org-inherit-project-properties project)
        (org-copy-files-to-project-folder project)
        (org-add-project-to-excludes-list project))
      ;; Add projects to org-publish-project-alist for interactive publishing later.
      (org-add-projects-to-global-alist projects)
      ;; Publish.
      (dolist (project projects) (org-publish project))))
#+END_SRC

**** org-publish-parse-project-config-node, org-publish-parse-file-config-node

These two functions ... bla bla. 

#+BEGIN_SRC elisp
  
  (defun org-publish-parse-project-config-node ()
      
    )
#+END_SRC

#+BEGIN_SRC elisp
  
  (defun org-publish-parse-file-config-node ()
    
    )
#+END_SRC

#+BEGIN_SRC elisp
  
**** org-publish-provide-project-defaults
  (defun org-publish-provide-project-defaults 
    (project-name project-config default-base-directory default-publish-directory)
    (setq project-name 
          (or
           project-name
           (org-publish-make-project-name)
           ))
    (cons project-name 
          (merge-plists 
           (list
            :base-directory default-base-directory
            :base-extension "org"
            :publishing-directory default-publish-directory
            :recursive t
            :publishing-function org-publish-org-to-html
            :headline-levels 5
            :auto-preamble t
            )
           project-config)))
#+END_SRC

**** org-publish-make-project-name
#+BEGIN_SRC elisp
  
  (defun org-publish-make-project-name ()
    "Construct name of project from file name of buffer.
  If a project with that name already exists, ask the user whether to 
  overwrite that project. If the answer is no, then an error is issued, and 
  the new project creation process stops."
    (let* (
           (name (file-name-sans-extension (buffer-file-name (current-buffer))))
           (ok          (or
             (not (assoc name org-publish-project-alist))
             (y-or-n-p (format "Overwrite existing project %s?" name))
             ))
           )
      (if ok name (error (format "Duplicate project named '%s'. Please rename." name)))))
  
#+END_SRC


**** org-parse-file-project-configs (NOTE: Store info in separate variable, not in org-publish-project-alist)

Go through all the nodes in the file and create projects or specs for new files in existing projects according to properties defined in the nodes. 

A first thought was to store the necessary info from the parsing inside the prorject-alist to which the node/file will belong.  
From the following draft it seems that we need yet to analyse the data required, and how they should be structured.

The file info, which is obtained by parsing the specifications contained in the source file or its nodes, is saved *IN A SEPARATE LIST*, not in org-publish-project-alist components.  The reason is that the project definition alist is overwritten on purpose and created afresh when the project definition is parsed from a single node.  This would erase any file info collected previously by parsing other files. 

Drafting this here: 

#+BEGIN_SRC elisp
  ;;; !!!!!!!!!!!!!!!!!!!!!!!!!!!! MUST REWRITE THIS
 ;;; !!!!!!!!!!! Should be separate from org-publish-project-alist !!!!!!!!

;;; Probably like this: 

(
("file-name1" :path "path" :project "project" :id "id...." etc)
("file-name2" :path "path" :project "project" :id "id...." etc)
)

Not like this: 
  '("<project-name>"
    :files ;; this property contains the list of all files created for this project 
    ;; through dynsite2 config specifications in org files.
    ;; The property :files is a single list, containing several sublists.
    ;; One sublist per file. 
    (
     ;; One sublist for each source file and the components of the file that should be copied.
     ;; =======================================================================
     ;; First file
    ("path"  ;; full path of file to be processed
     ;; Each file can have many other file components to be extracted
     ;; optionally start plist here or leave it just as plain cdr   
     ;; Specs of how to create extract each file file go here:
     ;; id of node to be copied, or "file" to copy entire file
     :node "node id...."
     ;; folder where this node should be copied
     :folder "subfolder-name" 
     ;; file where this node should be copied 
     :file "file-name" ;; .org provided if missing
     ;; publish properties which should be inserted in the header of the file.
     :header (:property "value" :property value ...)
     ;; (NOTE: project properties are added directly to the project alist being created)
     )
    ;; ========================================================================
     ;; Second second source file and all files extracted from it.
    ("path" ;; second file ...
      ;; ...
     )
    ) ;; end of :files list
     ;; other project properties follow here:
    :recursive t
    :auto-preamble t
    ;; ...
   )

#+END_SRC

#+BEGIN_SRC elisp
(defun org-parse-file-project-configs ()

)
#+END_SRC

OTE



*** Step 1: File has no project info at all
:PROPERTIES:
:DATE:     <2013-11-30 Sat 16:56>
:END:

Create a new project using default settings.  The name of the project is the name of the file without extension. 

If there is already a project by that name, and the path of the file stored in the already existing projects' alist under property =root-source-file= is not identical to the path of the current file/buffer, then issue a message and ask the user whether they wish to proceed and overwrite the existing project info under that name with the parameters extracted from the present file. 

The org folder for the project is =<path-to-files-folder>/org/=.
The html folder for the project is =<path-to-files-folder>/html/=.

If these folders do not exist, they are created.

NOTE: When creating a default project with the file's name, it may be useful to check 

*** Step 2: File has *project* info in a node =publish-project-config=
:PROPERTIES:
:DATE:     <2013-11-30 Sat 17:04>
:END:

Put the info from that node in the project's alist.  

This creates a new project, to which the file and all files created from subnodes in the file are added.  

More details about this to come. 

*** Step 3: File has *file specific* info in a node =publish-file-config=
:PROPERTIES:
:DATE:     <2013-11-30 Sat 17:04>
:END:

This expects this file and any files copied from subnodes of the project to become part of an already existing project, named in property :PROJECT:. 

Put the info from that node in the header of the file which is copied in the org directory for publishing.  Do the same for all other files which are copied from subnodes of this file.  

How do we indicate inheritance or not of file config to subnodes in same file?

More details about this to come. 

*** Step 4: File has a node with separate file config, in same project

*** Step 5: File has a node with separate file config, in different project

Question: When is the different project a subproject of that of the file?


** Starting point: Top level user-commands
:PROPERTIES:
:DATE:     <2013-11-26 Tue 21:07>
:END:

org-site-publish-file :: publish the entire file, splitting into separate files any subnodes which have a "FILENAME" property defined. 

org-site-publish-subtree :: publish this subtree.  If the subtree does not have a FILENAME property, ascend until you find one. If there is no FILENAME in any supertree of this subtree, issue a message saying "No filename property found for this subtree.  Use org-site-publish-file?". 

** Top-level file properties
:PROPERTIES:
:DATE:     <2013-11-27 Wed 08:34>
:END:

All of the following configuration properties are optional.  If none of these is provided, then a site is created using the defaults indicated for each property below: 
 
- SITE :: The name of the dynsite to which this file belongs.  Default: "default".  The config paths of the "default" site are created from ORG_PATH and HTML_PATH properties of this file.
- ORG_PATH :: Path for publishing the org-files in. Default: "./org/"
- HTML_PATH :: Path for publishing the html-files created from the org-files.  Default: "./html/"
- FILENAME :: Name for publishing the entire file.  Default: index.org.  ".org" ending is added if not provided by user.
- FOLDER :: Path of subfolder to be added to ORG_PATH (or sites' org-path) for publishing the org-files.
- PUBLISH_SUBTREES_ONLY :: If the value of this property is t (true), then the function "org-site-publish-file" will not publish the entire file, but only any subtrees which define a "FILENAME" property.
- INCLUDE_SITEMAP :: If the value of this property is t (true), then the function "org-site-publish-file" will include in the published top-level file links to the files created by any subnodes of the file.  If a subnode which creates a file contains a property called "DESCRIPTION", then the contents of DESCRIPTION are appended after the link in the top-level file.  The default value of this property is t. NOTE: A smarter way to provide the functionality of "INCLUDE_SITEMAP" would be to always create a sitemap with descriptions, and save this sitemap as an include file, which can then be included at any part of any file using  #+INCLUDE: ".path/to/file".

** Initial tests with top-level file properties
:PROPERTIES:
:DATE:     <2013-11-27 Wed 12:26>
:END:


Run this first - we need this function for the tests: 
#+BEGIN_SRC elisp
(defun org-get-header-property (property &optional all)
  "Get property from buffer variable.  Returns only fist match except if ALL is defined.
NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
  (with-current-buffer
	(current-buffer)
    (save-excursion
      (save-restriction
	(save-match-data
	  (widen)
	  (goto-char (point-min))
	  (let (values)
	    (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
	      (add-to-list 'values (substring-no-properties (match-string 1))))
	    (if all
		values
	      (car values))))))))
#+END_SRC

#+RESULTS:
: org-get-header-property

Test some of the funcs that you will use: 

#+BEGIN_SRC elisp
(buffer-file-name) ;; Does not work if editing on separate sub-buffer
#+END_SRC

#+RESULTS:
: /Users/iani2/Dropbox/000WORKFILES/org/personal/underway.org

#+BEGIN_SRC elisp
  (let* (
         (root (file-name-directory (buffer-file-name)))
         (org-root (concat root "/org/"))
         (html-root (concat root "/html/"))
         )
    (if (not (file-exists-p org-root)) (make-directory org-root))
    (if (not (file-exists-p html-root)) (make-directory html-root))
    (org-set-site (list "default" org-root html-root)))
#+END_SRC

#+BEGIN_SRC elisp
(org-get-header-property "")
#+END_SRC

#+BEGIN_SRC elisp
  (let* (
         (site ())
  
         )
   (assoc "org-tests" org-sites))
#+END_SRC
#+RESULTS:
: TODO ACTIVE | DONE CANCELLED

#+BEGIN_SRC elisp
  (defun org-site-make-site-for-file ()
    "Create site specs for file of current buffer.
  Get the org and html paths from properties in the file.
  If they are not present, provide defaults."
  
  
  )
#+END_SRC

#+BEGIN_SRC elisp
  (org-element--current-element (point))
#+END_SRC

#+BEGIN_SRC elisp
  (defun org-site-publish-file ()
    (interactive)
    
  )
#+END_SRC

** Converting links for split files
ROPERTIES:
:DATE:     <2013-11-28 Thu 09:33>
:CUSTOM_ID:       22447DE7-50E6-4AEC-8CB3-1F548BEB460A
:END:

*** Prep research
:PROPERTIES:
:DATE:     <2013-11-29 Fri 09:45>
:END:

This needed some deep research.  Current state: 
See http://orgmode.org/manual/Handling-links.html

Links that are stored using the CUSTOM_ID of a node should be converted correctly when exporting a project in HTML, even when the link has been moved to a different file than the file in which it was created,together with its CUSVOM_ID. 

C-c l     (org-store-link) to create the links to insert in text.
To make he 



But set org-id-link-to-org-use-id to true.
This creates unique ids for each link when using org-store-link. 
You can then insert a unique-id link created by  in the text with C-c C-l     (org-insert-link). 

Here is the code for setting org-id-link-to-org-use-id to t and then a resulting link: 
#+BEGIN_SRC elisp
(setq org-id-link-to-org-use-id t)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(setq org-id-link-to-org-use-id nil)
#+END_SRC

#+RESULTS:


[[*Converting%20links%20for%20split%20files][Converting links for split files]
[[*Converting%20links%20for%20split%20files][Converting links for split files]
[[*Converting%20links%20for%20split%20files][Converting links for split files]
[[*Converting%20links%20for%20split%20files][Converting links for split files]

The resulting link is: [[id:22447DE7-50E6-4AEC-8CB3-1F548BEB460A][Converting links for split files]]
Its internal form in ASCII is: 
#+ASCII:  [[id:22447DE7-50E6-4AEC-8CB3-1F548BEB460A][Converting links for split files]]

So now, how to use such a unique link to insert the correct html equivalents of the links in the published site???  We could use org-export-resolve-id-link (see http://orgmode.org/worg/dev/org-export-reference.html#resolve-id-link). 

For this we need to provide the id link (full or only the link ID???), and a plist (what plist?).  See (Defun org-export-resolve-id-link (link info) ...) in file ox.el.  Fortunately the code is short and the answers to the ??? above can be found there, probably.  First conclusions: org-export-resolve-id link indeed does perform multi-file ssearch and resolution for the link, if needed, using the files stored in property :id-alist of the info plist.  The question then is, how is :id-alist constructed?  A grep search yielded locations (besides the one in the function above):
./ox.el:1258:;; + `:id-alist' :: Alist between ID strings and destination file's
./ox.el:1515:    :id-alist
The first one of these belongs to documentation after the function: org-export-derived-backend-p



*** Conclusion
:PROPERTIES:
:DATE:     <2013-11-29 Fri 11:25>
:END:

One can use the unique ID property of a node to identify links, so that these links can be resolved and the proper html link can be created for them, even when the node is refiled (or moved) into a different file than the one it was previously.  The following code, which was added to iani2.org, tells Org mode to create a unique ID and to use it as ID for a link every time that one uses org-store-link (C-c l) to store a link and org-insert-link (C-c C-l) to paste that link into another place in a document: 

#+BEGIN_SRC emacs-lisp
(require 'org-id)
(setq org-id-link-to-org-use-id t)
#+END_SRC

The links created in this way do *not* contain the name of the file to which the node belongs (anyway that would not work when moving the node to another file).  Thus, one should process the files created by dynsite2 to insert the proper file names where needed. How to do this? See next: 

**** Providing file references to node-id-links
:PROPERTIES:
:DATE:     <2013-11-29 Fri 11:25>
:ID:       7F10AFC0-078D-40FC-9E75-9DAA8F06932F
:END:

***** Setup:
:PROPERTIES:
:DATE:     <2013-11-30 Sat 09:57>
:END: 

Links between org files in a project must be provided with a unique id in order to ensure that the links will be resolved correctly even when moving nodes to different files.  For this, the following code must be included in the org-project-meta setup: 

#+BEGIN_SRC emacs-lisp
(require 'org-id)
(setq org-id-link-to-org-use-id t)
#+END_SRC

To store the id of a node to link to, type C-c l with the cursor inside the node or heading.  To insert the stored link at any location, type C-c C-l. 

See http://orgmode.org/manual/Handling-links.html

The links inserted will *not* contain the name of the file.  File names must be provided after having copied all files to the org publish folder. 

No modification is needed in the id or link code functions of Org-mode.  (Using CUSTOM_ID to make Org-mode insert the files in the links is not useful, since those names change when the files are copied for publishing). 

***** Function org-resolve-file-links
:PROPERTIES:
:DATE:     <2013-11-30 Sat 09:57>
:CUSTOM_ID:       A13FB84D-4868-4FC7-9EF8-82675AB5BD06
:END:

To work when the link is pointing to a node in a different file than the file in which the link is located, the (relative) path to that file must be added to the link.

[[id:A13FB84D-4868-4FC7-9EF8-82675AB5BD06][Function org-resolve-file-links]]

Testing with added file name here:
[[file:org-publish-meta.org::#A13FB84D-4868-4FC7-9EF8-82675AB5BD06][Function org-resolve-file-links]]

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IMPORTANT: In order for a link that contains both a file and a custom id in the address to work (file:filename.org::#123451234-THEID123), 
as in the examples above, the ID of the target must be stored in property named CUSTOM_ID and not ID. If the property is named ID the link will not work. 

Debugging: 

See here: http://www.gnu.org/software/emacs/manual/html_node/org/Handling-links.html
Footnote 2: The library org-id must first be loaded, either through org-customize by enabling id in org-modules , or by adding (require 'org-id) in your .emacs. Talking about the same library in both cases? Conflicts? 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



For example:

#+ASCII: [[id:7F10AFC0-078D-40FC-9E75-9DAA8F06932F][test link]]
Should become:
#+ASCII: [[file:underway.org::#7F10AFC0-078D-40FC-9E75-9DAA8F06932F][test link]]

The required, tested, final html format is:

For a target:
#+BEGIN_HTML
<h2 id="sec-2"><a id="ID-D86EC76A-8599-4B81-8DCD-24E24932DA3C" name="ID-D86EC76A-8599-4B81-8DCD-24E24932DA3C"></a>This heading has plain :ID: property</h2>
#+END_HTML

For the links pointing to a target: 

#+BEGIN_HTML
<a href="index3.html#ID-D86EC76A-8599-4B81-8DCD-24E24932DA3C">This heading has plain :ID: property</a>
#+END_HTML

This conversion should be done on a per-project basis (later perhaps to be extended to directories containing groups of project).  It should be done as a pre-processing function just before the start of the standard org-publish-project function call.  Let's name the function that performs this task =org-resolve-file-links=. 

The function org-resolve-file-links works as follows:

1. Process all Org mode files of a project, and build:
   1. a list of ids,
   2. a list of links that need to be resolved,
   3. a list of duplicate ids (same id number occurring for 2 or more different org-nodes).

2. Do the following
   1. Go through the list of links that need to be resolved and provide the file reference for each of these links.
   2. Save the modified org files with the resolved links.
   3. Build a list of unresolved links (links who's ids could not be found in the list of ids).

**** The 4 link conversion lists
:PROPERTIES:
:DATE:     <2013-11-30 Sat 10:43>
:END:
Here are in detail the 4 lists needed for the conversion process (2 lists for making the conversion and additionally 2 lists for reporting (a) nodes with duplicate IDs and (b) links that could not be resolved):

1. List of ids:

#+NAME: variable "org-node-id-list"  
#+BEGIN_SRC elisp
  (
   ("7F10AFC0-078D-40FC-9E75-9DAA8F06932F" . "index.org")
   ("71234123-078D-40FC-9E75-9DAA8FASDFFF" . "subdir1/filex.org")
   ...
  )
#+END_SRC

2. List of links 

#+NAME: variable "org-link-id-list"  
#+BEGIN_SRC elisp
(
 ("[id:7F10AFC0-078D-40FC-9E75-9DAA8F06932F]" . "index.org")
 ("[id:30QWER99-078D-40FC-9E74-QWERREWERWWW]" . "subdirx/fileyz.org")
 ...
)
#+END_SRC

3. List of duplicate IDs

#+BEGIN_SRC elisp
  (
  ;;; how to give more details about the location of each duplicate in the file?
  ;;; maybe omit details here, create them later when needed, with grep?
   ("7F10AFC0-078D-40FC-9E75-9DAA8F06932F" . "index.org")
   ("7F10AFC0-078D-40FC-9E75-9DAA8F06932F" . "filez.org")
  )
#+END_SRC

4. List of unresolved links

(Of similar structure as the above lists)

These lists 

- When dynsite2 starts publishes a file by creating a copy of the file and/or copying subnodes of the file into new org files, it should do the following:
  - for every new org file created, it should record the ID properties of all nodes which have one. 
  - afterwards, it should go through all the new org files which were created by the publishing process, and replace any links which contain references to ids with corrected references to which the file name and path has been added: 

 
Procedure to do the above:
- Before saving each new buffer created from parts of the file to be published in a new file. 
  - scan for links with ids.  Add each link to a list of links, and add the new file's relative path to the root of the project as assoc value to the link. 
    While building this link, note if there are any nodes that have the same ids, and save their location details in a separate list called "duplicate-ids". 
  - scan for nodes with ids.  Add each node id to alist of ids, and again add the new file's relative path to the root of the project as assoc value to the id. 


The result of the above process is two lists of this form: 

Then, for each link in the org-link-id-list, replace the id: part with the file:<filename>:: using as <filename> the cdr of the sublist found by searching for the id from org-link-id-list in the org-node-id-list.  When doing this keep track of any links whose ids have not been found in the org-node-id-list, putting them in a list unresolved-links. 

Save the two by-product check lists: duplicate-ids and unresolved-links in a log file for debugging the project publishing process.
*** One more hint: use wiki? 
See: http://sachachua.com/blog/2011/11/planning-an-emacs-based-personal-wiki-org-muse-hmm/
#+BEGIN_QUOTE
Juan G. • a year ago −
Another detail for Org-mode personal wikis: Link abbreviations can help to have very simple wikilinks like [[wiki:Topic][topic]], that work like absolute links, the same from any directory (for easy moving of files, or copy/paste). The directory path and the extension .org are added automatically. For example:

This is a normal wikilink to a [[wiki:Topic][topic]] in the main wiki directory.

And this is an optional wikilink to another [[wiki:Subdirectory/Topic][topic]] in a subdirectory.

It works adding something like the following to the .emacs file (changing /long/path/to/wiki, of course):

;; Link abbreviations
(setq org-link-abbrev-alist
'(("wiki" . "file:/long/path/to/wiki/%s.org")
("google" . "http://www.google.com/search?q...")))

Does this convert right when publishing? If yes, it could save some coding.  One could construct the org-link-abbrev-alist from the node id list. 




** Scrap site concept and work with single project?
:PROPERTIES:
:DATE:     <2013-11-28 Thu 10:31>
:ID:       B4241C9F-E9CD-4773-9F83-A52831E81FD4
:END:

It may be of advantage to work with a single project created dynamically from a single file *or from a folder*, because of this [[id:69BCA8CC-2C92-42E4-BED4-2AF075445EA2][Conclusion]]. 

** Previous link tries (obsolete?)
:PROPERTIES:
:DATE:     <2013-11-28 Thu 10:33>
:END:

Set org-link-search-inhibit-query to t to prevent queries if the link is not found. 

#+BEGIN_SRC elisp
(setq org-link-search-inhibit-query t)
(setq test (point))
(org-link-search "*Subnode properties")
(setq test2 (point))
#+END_SRC

Some test links: 

[[*Alpha][Alpha]] [[*Alpha][Alpha]] [[*Alpha][Alpha]]

[[*Alpha][Alpha]
*** Alpha
:PROPERTIES:
:ID:       BE36A7E7-F17A-47BD-822F-32E989949297
:END:

*** Alpha

**** Alpha

** Using jquery .inc to dynamically create page summary lists?
:PROPERTIES:
:DATE:     <2013-11-27 Wed 09:10>
:END: 

http://stackoverflow.com/questions/676394/how-to-include-an-html-page-into-an-html-page : 
See this: 

#+BEGIN_SRC 
If you're willing to use jquery, there is a handy jquery plugin called "inc".

I use it often for website prototyping, where I just want to present the client with static HTML with no backend layer that can be quickly created/edited/improved/re-presented

http://johannburkard.de/blog/programming/javascript/inc-a-super-tiny-client-side-include-javascript-jquery-plugin.html

For example, things like the menu and footer need to be shown on every page, but you dont want to end up with a copy-and-paste-athon

You can include a page fragment as follows

<p class="inc:footer.htm"></p>
#+END_SRC

** Subnode properties
:PROPERTIES:
:DATE:     <2013-11-27 Wed 08:54>
:END:

** Principles, Basic Design
:PROPERTIES:
:DATE:     <2013-11-25 Mon 12:03>
:END:
Its basically simple: 

The function for splitting a file into org files and then publishing it as site is:   org-publish-split-file

The subfiles are written in directory specified by property: DYNSITE_ORG_DIR
If this is not defined, it tries to get the directory from the propety DYNSITE_NAME
It then looks for a site named after the string contaned in DYNSITE_NAME in the variable
containing the dynsite definitions, which is: org-sites. 

I am going to use this function "as-is" since it works:

#+BEGIN_SRC elisp
   (org-get-header-property "DYNSITE_ORG_DIR")
#+END_SRC

#+RESULTS:
: 50144

However, to get inherited properties one would have to use org-element-up, which, although in the manual http://orgmode.org/worg/org-api/org-element-api.html#sec-1-141, does not seem to be defined.  So one would perhaps use outline-up-heading instead:

#+BEGIN_SRC elisp
   (outline-up-heading 1)
#+END_SRC
   
and combine it with: 

#+BEGIN_SRC elisp
   (org-entry-get (point) "DATE")
#+END_SRC

#+RESULTS:
   : <2013-11-25 Mon 12:03>

Note: Do not use third argument t for inheritance, because we also need to find which is the top level of the node that should be exported. 
   
To find out the level of the node, use function org-current-level. 

So next do something like this: 

#+BEGIN_SRC elisp
  (defun org-get-property-recursively (property level)
    (unless level ())
  
  )
  
  
  (let ((test 0) (level (org-current-level)))
   (while
       (and
        (not (eq level) ()) 
        
        (> (org-current-level) 0)
        
  )
     (outline-up-heading 1 t)
     (setq test (+ 1 test))
     )
   test)
  
  (setq test 1)
#+END_SRC

#+BEGIN_SRC elisp
  (if (eq nil (org-current-level)) ;; if we are outside any node
      ;; pseudo code follows
      (then: get the property from heading using custom function above)
    (else: recurse till current level is 1 trying to get the property 
           if that fails, then try getting the property from the heading as above
           if even that fails, then provide default property and/or ask user 
              if it is ok to proceed
           )
  )
  
  
#+END_SRC


   #+BEGIN_SRC elisp
    (org-entry-get (point) "DATE" t)
   #+END_SRC

   #+RESULTS:
   : <2013-11-25 Mon 12:03>

   #+BEGIN_SRC elisp
   org-export-options-alist
   #+END_SRC

   #+RESULTS:
   | :author                  | AUTHOR       | nil       | user-full-name                     | t                      |
   | :creator                 | CREATOR      | nil       | org-export-creator-string          |                        |
   | :date                    | DATE         | nil       | nil                                | t                      |
   | :description             | DESCRIPTION  | nil       | nil                                | newline                |
   | :email                   | EMAIL        | nil       | user-mail-address                  | t                      |
   | :exclude-tags            | EXCLUDE_TAGS | nil       | org-export-exclude-tags            | split                  |
   | :headline-levels         | nil          | H         | org-export-headline-levels         |                        |
   | :keywords                | KEYWORDS     | nil       | nil                                | space                  |
   | :language                | LANGUAGE     | nil       | org-export-default-language        | t                      |
   | :preserve-breaks         | nil          | \n        | org-export-preserve-breaks         |                        |
   | :section-numbers         | nil          | num       | org-export-with-section-numbers    |                        |
   | :select-tags             | SELECT_TAGS  | nil       | org-export-select-tags             | split                  |
   | :time-stamp-file         | nil          | timestamp | org-export-time-stamp-file         |                        |
   | :title                   | TITLE        | nil       | nil                                | space                  |
   | :with-archived-trees     | nil          | arch      | org-export-with-archived-trees     |                        |
   | :with-author             | nil          | author    | org-export-with-author             |                        |
   | :with-clocks             | nil          | c         | org-export-with-clocks             |                        |
   | :with-creator            | nil          | creator   | org-export-with-creator            |                        |
   | :with-date               | nil          | date      | org-export-with-date               |                        |
   | :with-drawers            | nil          | d         | org-export-with-drawers            |                        |
   | :with-email              | nil          | email     | org-export-with-email              |                        |
   | :with-emphasize          | nil          | *         | org-export-with-emphasize          |                        |
   | :with-entities           | nil          | e         | org-export-with-entities           |                        |
   | :with-fixed-width        | nil          | :         | org-export-with-fixed-width        |                        |
   | :with-footnotes          | nil          | f         | org-export-with-footnotes          |                        |
   | :with-inlinetasks        | nil          | inline    | org-export-with-inlinetasks        |                        |
   | :with-latex              | nil          | tex       | org-export-with-latex              |                        |
   | :with-planning           | nil          | p         | org-export-with-planning           |                        |
   | :with-priority           | nil          | pri       | org-export-with-priority           |                        |
   | :with-smart-quotes       | nil          | '         | org-export-with-smart-quotes       |                        |
   | :with-special-strings    | nil          | -         | org-export-with-special-strings    |                        |
   | :with-statistics-cookies | nil          | stat      | org-export-with-statistics-cookies |                        |
   | :with-sub-superscript    | nil          | ^         | org-export-with-sub-superscripts   |                        |
   | :with-toc                | nil          | toc       | org-export-with-toc                |                        |
   | :with-tables             | nil          |           |                                    | org-export-with-tables |
   | :with-tags               | nil          | tags      | org-export-with-tags               |                        |
   | :with-tasks              | nil          | tasks     | org-export-with-tasks              |                        |
   | :with-timestamps         | nil          | <         | org-export-with-timestamps         |                        |
   | :with-todo-keywords      | nil          | todo      | org-export-with-todo-keywords      |                        |

   #+BEGIN_SRC elisp
   org-sites
   #+END_SRC
   
   #+RESULTS:
   | larigot-iani | /Users/iani2/SitesSource/larigot-iani | /Users/iani2/Sites |                                                          |
   | org-tests    | /Users/iani2/SitesSource/org-tests    | ~/Sites/org-tests  | earlabor@earlab.org:public_html/larigot-tests/org-tests/ |
   | default      | ~/org                                 | nil                | earlabor@earlab.org:~/public_html/org/                   |
   
   #+BEGIN_SRC elisp
   (org-entry-get (point) "TAB-WIDTH" t)
   #+END_SRC

   #+BEGIN_SRC elisp
   (org-buffer-property-keys)
   #+END_SRC

   #+RESULTS:
   | DATE | ENTRYTYPE |

   #+BEGIN_SRC elisp
   org-file-properties
   #+END_SRC

   #+BEGIN_SRC elisp
   org-global-properties
   #+END_SRC


   #+RESULTS:

   #+BEGIN_SRC elisp
   (org-entry-get-with-inheritance "TAB-WIDTH")
   #+END_SRC

   #+RESULTS:

   If that is also not defined, it gets the default value: 
   (concat (file-name-directory (buffer-file-name)) "org/")
3. The target for publishing the files to html is given by property: DYNSITE_PUBLISH_DIR
   If this is not defined, it gets the default value: 
   (concat (file-name-directory (buffer-file-name)) "html/")
4. A dynsite is defined with the parameters DYNSITE_ORG_DIR and DYNSITE_PUBLISH_DIR
5. The file is copied as "index.org" into the DYNSITE_ORG_DIR
   The name of the file can be customized by setting the property "FILE_NAME" in the header of the file. 
6. Any org-mode nodes in the file which have th property "FILE_NAME" set, are extracted from the file
   and copied as separate files in the DYNSITE_ORG_DIR.
7. Any org-mode node in the file which has the property "FOLDER_NAME" set, creates a subfolder 
   in DYNSITE_ORG_DIR with that name. The contents of the node are copied inside 


Note: The node-extraction as org files algorithm can be implemented recursively with a function like: 

#+BEGIN_SRC elisp
  (defun org-publish-hierarchically-as-org (folder file buffer)
    ;; If folder does not exist, create it
    ;; For buffer: 
    ;; Write header part of file (until first node) in <file>.org under <folder>.
    ;; For each node: 
    ;; If node has a FILE_NAME or FOLDE_NAME property defined, then 
    ;; Create temp buffer for this node
    ;; Copy contents of node into temp buffer
    ;; Run org-publish-hierarchically-as-org on the temp buffer,
    ;; (folder and file are deduced from properties of node or inherited)
  )
#+END_SRC


Config parameters can be written either in nodes named config, or in a drawer.  I will decide that next.  I tend to use a combination of drawers and node properties instead of a node named config. 

Multiple nested config files are possible for subnodes, which specify among other things the names and paths of the file. 

For Files: Define a property named "FILE" to give tne name of the file. 
For subfolders: Define a property named FOLDER to give the name of the folder.  The contents of the node are saved in a file named "index.org" in that folder.  Subnodes of that folder are made to be files in that folder if they have a property "FILE" giving them a file name.  Idea: We may reserver a name "_AUTO" to make dynsite deduce the name of the file from the heading of the node. 


IMPORTANT: The only delicate thing here is to convert links to other nodes to make them point to the files.

** Implementation coding tests
:PROPERTIES:
:DATE:     <2013-11-25 Mon 18:47>
:END:

Note: See other subnodes below or above for [[*Roadmap][Roadmap]] and [[*Principles,%20Basic%20Design][Principles, Basic Design]]. 

*** Getting header properties
:PROPERTIES:
:DATE:     <2013-11-26 Tue 19:25>
:END:

Dynsite 2 optionally allows to define the following properties in the header of the file (rather than in a subnode/heading of the file): 

- DYNSITE_NAME :: The name of the site to which this file belongs.
- DYNSITE_ORG_DIR :: If DYNSITE_NAME is not defined, create dynsite for this file, using DYNSITE_ORG_DIR as root for org files.  Default is ./org/
- DYNSITE_HTML_DIR :: If DYNSITE_NAME is not defined, use this as root for the exported html files. Default is ./html/
- FOLDER_NAME :: If set, this folder is used as root for the org-export of this file and any of its separate subnodes. The path given by FOLDER_NAME is appended to the dynsite org dir to form the full path. 
- FILE_NAME :: If set, this is the name for exporting the file in org-mode.  If not set, then ...? export only nodes with file names?

An additional optional property is used: 

- NOEXPORT :: If set to t (true), then the file will not be exported 

Strangely enough, there exists no general-purpose function for getting a global property (one defined with a #+PROPNAME: ... line in an org buffer.  This seems to be the conclusion at least when examining the source code of org mode.  The search stopped at the function org-set-regexps-and-options-for-tags, where I found that the function org-make-options-regexp is used to search for properties.  I combine this information with the code found in o-blog, and use it to make my own function for getting the values of properties DYNSITE_NAME, DYNSITE_ORG_DIR, DYNSITE_HTML_DIR from header lines. The function in question is: ob:get-header.  The slightly modified variant which I will use is: 

#+BEGIN_SRC elisp
(defun org-get-header-property (property &optional all)
  "Get property from buffer variable.  Returns only fist match except if ALL is defined.
NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
  (with-current-buffer
	(current-buffer)
    (save-excursion
      (save-restriction
	(save-match-data
	  (widen)
	  (goto-char (point-min))
	  (let (values)
	    (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
	      (add-to-list 'values (substring-no-properties (match-string 1))))
	    (if all
		values
	      (car values))))))))
#+END_SRC

#+RESULTS:
: org-get-header-property

*** Getting node properties, ascending recursively
:PROPERTIES:
:DATE:     <2013-11-26 Tue 21:06>
:END:
** Roadmap
:PROPERTIES:
:DATE:     <2013-11-25 Mon 12:03>
:END:

*** Define function org-publish-open-in-site
:PROPERTIES:
:DATE:     <2013-11-25 Mon 12:08>
:END:

The function has two versions, depending on whether it is called interactively with numeric argument or not. 

1. No numeric argument: Open current subtree in site. 
2. With numeric argument: Open whole file in site. 


**** Finding the path to copy the subtree as org to
:PROPERTIES:
:DATE:     <2013-11-25 Mon 16:54>
:END:




**** No numeric argument: Open current subtree in site. 

- read properties FILE_NAME and FOLDER_NAME of this subtree (node). 

- if :: this node has neither FILE_NAME nor FOLDER_NAME
  - then :: recursively 
  - else :: Construct the
 
Function 

**** With numeric argument: Open whole file in site. 

** Drawer test
:TEST:
This is a test. 

:END:




* OLD STUFF - quasi archive
** ACTIVE Fixing dynsite's build site function
:PROPERTIES:
:DATE:     <2013-11-19 Tue 00:38>
:END:

Currently org-build-projects does not work correctly:  Project properties created through config.org are not inherited in all subfolders, but only in the top few.  Therefore, rewrite here org-build-projects.  Use recursion, and check that project properties are properly inherited. 

Descend a directory recursively, and build a nested list from it.
Application: Build org-publish-project-alists for all projects contained.

Starting point: 

path of root folder of site. Eg: "~/SitesSource/" or "~/SitesSource".

If this folder contains config.org: 

1. Parse the data of config.org
2. Merge the parsed data with those passed as argument to this func (recursively)
3. Make a project alist from the data, store it in variable "the-plist"
4. Add the-plist to the list of all projects of the site
5. Recurse over all subfolders of the present folder, passing the-plist as argument. 

Details: 

- After each project's name is built, add its path to the string of ignore folders for its superproject

#+BEGIN_SRC elisp
    (defvar test-alist nil)
    (defvar project-list nil)
    
    (defun org-build-site-alists (path)
      "Build project alists by recursively descending a folder."
      (interactive "DBuild site for folder:")
      (setq test-alist nil)
      (setq project-list nil)
      (org-recursive-build-project-alist path (org-publish-make-default-plist path))
      (setq test-alist
            (cons
             (list "all-all" :components project-list)
             test-alist)))
  #+END_SRC

*** Building the default plist
:PROPERTIES:
:DATE:     <2013-11-18 Mon 22:18>
:END:

#+BEGIN_SRC elisp
   (defun org-publish-make-default-plist (path)
     (list
      (file-name-nondirectory path)
      :base-directory path
      ;; FIXME: The publishing directory must be constructed 
      ;; on the basis of the sites publishing directory. publish-dir-root.
      ;; See subnode in this section below!
      :publishing-directory 
      (concat 
       org-site-html
       (replace-regexp-in-string (concat "^" org-site-root) "" path))
      :section-numbers nil
      :with-toc t
      ;; more stuff needed here, from the previous dynsite code.
      ;; But: Also check all properties for compatibility with Org 8.x
      )
  )
#+END_SRC

#+BEGIN_SRC elisp
(org-publish-make-default-plist (concat org-site-root "/" "papers"))
#+END_SRC

**** How the publish path is made from publish-dir-root
:PROPERTIES:
:DATE:     <2013-11-19 Tue 00:40>
:END:

Given: 
:base-directory = "/Users/xxx/Source/subproject"
publish-dir-root = "/Library/WebServer/Documents"

We also need 1 more item of information: the site-root.  This is necessary in order to find out which part of the base-directory should be subtracted to obtain the folders that are to be added to publish-dir-root to obtain the :publishing-directory. 

Therefore, reminder of vars already defined by dynsite: 

- org-site-root contains the path to the root directory containing all  org-sites
- org-site-html contains the path for publishing sites in html

These must be used to obtain the correct :publishing-directory from the :base-directory.

Algorithm: 

1. Subtract org-site-root from :base-directory. What remains is the extra folder path of the project. 
2. Add the extra folder path of the project to org-site-html to obtain the :publishing-directory. 

Tests: 

#+BEGIN_SRC elisp
  org-site-root
  org-site-html
  (let* ((path (concat org-site-root "/" "papers"))
         (proj-folder (replace-regexp-in-string (concat "^" org-site-root) "" path)))
    (concat org-site-html proj-folder)
  )
#+END_SRC

#+RESULTS:
: /Users/iani2/Sites/papers

file:/Users/iani2/Sites/papers
**** Properties to put in the default plist (from the manual+dynsite)
:PROPERTIES:
:DATE:     <2013-11-18 Mon 22:19>
:END:

***** From dynsite
:PROPERTIES:
:DATE:     <2013-11-18 Mon 22:21>
:END:

****** For documents
:PROPERTIES:
:DATE:     <2013-11-18 Mon 22:23>
:END:

  (list 
     :base-directory base-directory
     :publishing-directory publishing-directory
     :base-extension "org" ;; publish all org files
     :exclude "config.org$" ;; except config.org
     :section-numbers nil ;; do not add section numbers
     :with-sub-superscript nil ;; do not translate _ and ^ as subscript and superscript
     :table-of-contents t ;; generate a table of contents
;; did not get the following lines for making an index to do anything useful yet
;; I need to look at: http://orgmode.org/Changes_old.html, section "Index generation"
;;     :auto-index t ;; Automatic index generation. Where does this happen? 
;; next line produces an error ([2012-03-25 Sun 20:59])
;;     :makeindex t ;; makeindex again, according to http://orgmode.org/manual/Generating-an-index.html#Generating-an-index
     :recursive t ;; descend into subdirectories
     :publishing-function 'org-html-publish-to-html ;; publish to html
     :headline-levels 2 ;; only include headlines down to 2 levels in the table of contents
     :auto-preamble nil ;; do not use automatic preamble
     :auto-sitemap t                ; Generate sitemap.org automagically...
     :sitemap-filename "sitemap.org"  ; ... call it sitemap.org (it's the default)...
     :sitemap-title "Sitemap"         ; ... with title 'Sitemap'.
     ;; This does not bring the shell window to front so not activated yet:
;;     :completion-function 'org-upload-site-with-rsync
     :author "Ioannis Zannos & Aris Bezas"
     :email  "zannos AT gmail DOT com & aribezas AT gmail DOT com"))

****** For attachments
		       (list (concat name "-static")
			     :base-directory  (plist-get project-def :base-directory)
			     :publishing-directory (plist-get project-def :publishing-directory)
			     :recursive t
			     :base-extension "css\\|html\\|js\\|ppt\\|doc\\|xls\\|dwg\\|zip\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"  ;;change 121114 by ari
			     ;; :base-extension "css\\|js\\|zip\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf" 
			     :folder-exclude (plist-get project-def :folder-exclude)
			     :publishing-function 'org-publish-attachment
			     )))))

***** From the manual
Most properties are optional, but some should always be set:

  `:base-directory'

    Directory containing publishing source files.

  `:base-extension'

    Extension (without the dot!) of source files.  This can be
    a regular expression.  If not given, \"org\" will be used as
    default extension.

  `:publishing-directory'

    Directory (possibly remote) where output files will be
    published.

The `:exclude' property may be used to prevent certain files from
being published.  Its value may be a string or regexp matching
file names you don't want to be published.

The `:include' property may be used to include extra files.  Its
value may be a list of filenames to include.  The filenames are
considered relative to the base directory.

When both `:include' and `:exclude' properties are given values,
the exclusion step happens first.

One special property controls which back-end function to use for
publishing files in the project.  This can be used to extend the
set of file types publishable by `org-publish', as well as the
set of output formats.

  `:publishing-function'

    Function to publish file.  Each back-end may define its
    own (i.e. `org-latex-publish-to-pdf',
    `org-html-publish-to-html').  May be a list of functions, in
    which case each function in the list is invoked in turn.

Another property allows you to insert code that prepares
a project for publishing.  For example, you could call GNU Make
on a certain makefile, to ensure published files are built up to
date.

  `:preparation-function'

    Function to be called before publishing this project.  This
    may also be a list of functions.

  `:completion-function'

    Function to be called after publishing this project.  This
    may also be a list of functions.

Some properties control details of the Org publishing process,
and are equivalent to the corresponding user variables listed in
the right column.  Back-end specific properties may also be
included.  See the back-end documentation for more information.

  :author                   `user-full-name'
  :creator                  `org-export-creator-string'
  :email                    `user-mail-address'
  :exclude-tags             `org-export-exclude-tags'
  :headline-levels          `org-export-headline-levels'
  :language                 `org-export-default-language'
  :preserve-breaks          `org-export-preserve-breaks'
  :section-numbers          `org-export-with-section-numbers'
  :select-tags              `org-export-select-tags'
  :time-stamp-file          `org-export-time-stamp-file'
  :with-archived-trees      `org-export-with-archived-trees'
  :with-author              `org-export-with-author'
  :with-creator             `org-export-with-creator'
  :with-date                `org-export-with-date'
  :with-drawers             `org-export-with-drawers'
  :with-email               `org-export-with-email'
  :with-emphasize           `org-export-with-emphasize'
  :with-entities            `org-export-with-entities'
  :with-fixed-width         `org-export-with-fixed-width'
  :with-footnotes           `org-export-with-footnotes'
  :with-inlinetasks         `org-export-with-inlinetasks'
  :with-latex               `org-export-with-latex'
  :with-priority            `org-export-with-priority'
  :with-smart-quotes        `org-export-with-smart-quotes'
  :with-special-strings     `org-export-with-special-strings'
  :with-statistics-cookies' `org-export-with-statistics-cookies'
  :with-sub-superscript     `org-export-with-sub-superscripts'
  :with-toc                 `org-export-with-toc'
  :with-tables              `org-export-with-tables'
  :with-tags                `org-export-with-tags'
  :with-tasks               `org-export-with-tasks'
  :with-timestamps          `org-export-with-timestamps'
  :with-planning            `org-export-with-planning'
  :with-todo-keywords       `org-export-with-todo-keywords'

The following properties may be used to control publishing of
a site-map of files or summary page for a given project.

  `:auto-sitemap'

    Whether to publish a site-map during
    `org-publish-current-project' or `org-publish-all'.

  `:sitemap-filename'

    Filename for output of sitemap.  Defaults to \"sitemap.org\".

  `:sitemap-title'

    Title of site-map page.  Defaults to name of file.

  `:sitemap-function'

    Plugin function to use for generation of site-map.  Defaults
    to `org-publish-org-sitemap', which generates a plain list of
    links to all files in the project.

  `:sitemap-style'

    Can be `list' (site-map is just an itemized list of the
    titles of the files involved) or `tree' (the directory
    structure of the source files is reflected in the site-map).
    Defaults to `tree'.

  `:sitemap-sans-extension'

    Remove extension from site-map's file-names.  Useful to have
    cool URIs (see http://www.w3.org/Provider/Style/URI).
    Defaults to nil.

If you create a site-map file, adjust the sorting like this:

  `:sitemap-sort-folders'

    Where folders should appear in the site-map.  Set this to
    `first' (default) or `last' to display folders first or last,
    respectively.  Any other value will mix files and folders.

  `:sitemap-sort-files'

    The site map is normally sorted alphabetically.  You can
    change this behaviour setting this to `anti-chronologically',
    `chronologically', or nil.

  `:sitemap-ignore-case'

    Should sorting be case-sensitive?  Default nil.

The following property control the creation of a concept index.

  `:makeindex'

    Create a concept index.  The file containing the index has to
    be called \"theindex.org\".  If it doesn't exist in the
    project, it will be generated.  Contents of the index are
    stored in the file \"theindex.inc\", which can be included in
    \"theindex.org\".

Other properties affecting publication.

  `:body-only'

    Set this to t to publish only the body of the documents."
  :group 'org-export-publish
  :type 'alist)

*** Further code
#+BEGIN_SRC elisp
(setq org-publish-project-alist
  (list (org-publish-make-default-plist "/Users/iani2/Dropbox/000WORKFILES/org/personal"))
)
#+END_SRC

Just testing: 
#+BEGIN_SRC elisp
  (defun test (path)
  "asdf"
  (interactive "Dpath:")
   (message (file-name-nondirectory path)))
#+END_SRC

The progn part in the function below must do the following: 

1. Create the first part of the name component of the new project.
2. Append the superproject part of the name to the first part to create the final name of the project.
3. Add project name to variable project-list, which is the components list of project all-all.
4. Add current path to the ignore folders string of the current parent project plist.

#+BEGIN_SRC elisp
    (defun org-recursive-build-project-alist (path parent-plist)
      "Workhorse function for org-build-site-project-alists.
    Build project alists by recursively descending a folder."
      (setq path (expand-file-name path))
      (let
          (
           (my-plist) 
           (project-name (car parent-plist))
           (config-file (car (file-expand-wildcards (concat path "/config.org")))))
        (if
            config-file
            ;; - Add path to string of ignored folders in parent-plist.
            (progn
              ;; create project name
              (setq 
               project-name
               (concat 
                (file-name-sans-extension (file-name-nondirectory config-file))
                "<" superproject-name))
              ;; add project name to project list
              (setq project-list (cons project-name project-list))
              ;; create project alist
              (setq my-plist (org-make-project-alist config-file parent-plist project-name))
              ;; add path to string of ignored folders in parent-plist
              (org-add-ignore-path-to-project-plist path parent-plist))
          ;; If no config file is present in this folder, then set my-list to parent list
          (setq my-plist parent-plist))
        ;; Iterate build project recursively on all subfolders
        ;; my-plist is now either new plist or parent-plist inherited from previous call.
        (dolist (folder (file-expand-wildcards (concat path "/*")))
          (if (file-directory-p folder)
              (org-recursive-build-project-alist folder my-plist)))))
    
    (defun org-make-project-alist (config-file parent-list project-name)
      "Construct a plist for a single project by merging specs in config-file
    with parent-list and setting project's name to project-name.  
    The plist is then added to org-publish-project-alist"
      (cons 
       project-name
       (m/merge
        (copy-tree (cdr parent-list))
        (org-custom-properties config-file))))
  
  (defun org-add-ignore-path-to-project-plist (path parent-list)
    (plist-put 
     parent-list 
     :folder-exclude 
     (concat (plist-get parent-list :folder-exclude) "\\|^" path)))
  
  ;;; Merge plists: Elements of rightmost list shadow those of left list.
  ;;; This means that the elements of the right list will be adopted,
  ;;; while elements of the left list will be overwritten. 
  ;;; From: https://github.com/megakorre/maps/blob/master/maps.el
  ;;; Requires dash.el from: https://github.com/magnars/dash.el/blob/master/dash.el
  ;;; dash.el was now added to custom-elisp in emacs.d personal prelude folder
  
  (defun m/merge (plist-a &rest plist-b)
    (-reduce-from
     (lambda (plist-a plist-b)
       (->> (-partition 2 plist-b)
         (-reduce-from
          (lambda (acc it)
            (let ((key (first it))
                  (val (second it)))
              (plist-put acc key val)))
          plist-a)))
     plist-a
     plist-b))
  
  ;; (m/merge '(:alpha 1 :beta 'oldbeta :delta 123) '(:beta 'NEWBETA :gamma 3))
  
#+END_SRC

Here is an example of a project plist: 

 ("AVA940HMI<classes<larigot-iani" :base-directory "/Users/iani2/SitesSource/larigot-iani/classes/AVA940HMI/" :publishing-directory "/Users/iani2/Sites/classes/AVA940HMI/" :base-extension "org" :exclude "config.org$" :section-numbers nil :with-sub-superscript nil :table-of-contents t :recursive t :publishing-function org-html-publish-to-html :headline-levels 40 :auto-preamble nil :auto-sitemap t :sitemap-filename "sitemap.org" :sitemap-title "Sitemap" :author "Ioannis Zannos" :email "zannos AT gmail DOT com & aribezas AT gmail DOT com" :folder-exclude "~$" :html-link-up "{{.}}/" :html-link-home "{{.}}/" :html-doctype "\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n" :html-xml-declaration nil :html-link-org-as-html t :html-head "\n<link href=\"{{.}}/css/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\">\n<link href=\"{{.}}/css/worg.min.css\" rel=\"stylesheet\" type=\"text/css\">\n" :html-head-extra "\n\n" :html-inline-images t :html-extension "html" :toc-heading "Contents" :html-preamble-disabled "\n<div id=\"org-navbar\" class=\"navbar\">Menu 1 Menu 2 Menu 3a, 3b</div>\n" :html-postamble "\n\n" :html-table-attributes
  '(:border "2" :cellspacing "0" :cellpadding "6" :rules "groups" :frame "hsides")
  :html-head-include-default-style nil :html-head-include-scripts nil :archived-trees nil :exclude-tags
  '("noexport")
  :language "en" :preserve-breaks nil :select-tags nil :with-author t :with-creator t :with-drawers nil :with-email t :with-emphasize t :with-fixed-width t :with-footnotes t :with-latex t :with-planning t :with-priority t :with-special-strings t :with-tables t :with-tags t :with-tasks t :with-timestamps nil :with-toc t :with-todo-keywords t)

To set properties 

#+BEGIN_SRC elisp
  
  (defun org-default-plist ()
    "Provide default org-publish-project-alist."
    '(this is just a test)
  )
  
  (defun org-add-config-data-to-alist (config-file parent-list)
    (setq test-alist (cons config-file test-alist))
  )
  
  test-alist
  
  org-publish-project-alist
#+END_SRC


