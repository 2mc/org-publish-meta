#+TODO: TODO UNDERWAY NEEDS_REVIEW | DONE CANCELLED

Developing the org-publish-meta application incrementally, step-by-step. 

* DONE Step 1: Auto-save of org-publish-project-alist
CLOSED: [2013-12-04 Wed 17:59]
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

** Utility functions for saving emacs lisp data
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

#+BEGIN_SRC elisp

(defun dump-vars-to-file (varlist filename)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf)
      (save-buffer)
      (kill-buffer))))

(defun dump (varlist buffer)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (loop for var in varlist do
        (print (list 'setq var (list 'quote (symbol-value var)))
               buffer)))

(defun checkit ()
  (interactive)
  (let ((a '(1 2 3 (4 5)))
        (b '(a b c))
        (c (make-vector 3 'a)))
    (dump-vars-to-file '(a b c) "/Users/iani2/Desktop/TEST.el")))
#+END_SRC

#+RESULTS:
: checkit

** The project save and load project alist functions
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:ID:       2624DC79-CBF5-413A-8BB5-4FD6B90E4CB9
:END:

#+BEGIN_SRC elisp
  
  (defvar org-pm-auto-save-path nil
    "Location where org-publish-meta saves and loads the contents of:
  - org-publish-project-alist,
  - org-pm-files
  - org-pm-nodes")
  
  (defvar org-pm-files nil
    "Assoc-list of files belonging to org-publish-projects.
  Each element of the list is of the form: 
  (full-file-path 
   :project projectname 
   :nodes (nodelist)
   :config (export config parameters))
  ")
  
  (defvar org-pm-nodes nil
    "Assoc-list of org-nodes belonging to org-publish-projects.
  Each element of the list is of the form: 
  (node-id 
   :file full-file-path 
   :configs (export config parameters)
   :projects 
   (
    (projectname :folder folderpath :file filename)
    (projectname2 :folder folderpath :file filename)
    )
  ")
  
  (defun org-pm-get-auto-save-path ()
    "Get the path where org-publish-project-alist should be auto-saved.
  if ~/.emacs.d is present, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.  
  Create savefile folder if it does not exist. 
  "
    (or
     org-pm-auto-save-path
    (setq org-pm-auto-save-path 
     (let* (
           (home (expand-file-name "~/"))
           (emacs-d-path (concat home ".emacs.d/"))
           )
       (cond
        ((file-exists-p emacs-d-path)
         (setq emacs-d-path (concat emacs-d-path "savefile/"))
         (unless (file-exists-p emacs-d-path) (make-directory emacs-d-path))
         (concat emacs-d-path "org-publish-meta"))
        (t (concat home ".org-publish-meta"))
        )))))
  
  (defun org-pm-save-project-configs ()
    "Save the contents of the following variables to org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes.
  Uses dump-vars-to-file"
    (dump-vars-to-file 
     '(org-publish-project-alist org-pm-files org-pm-nodes)
     (org-pm-get-project-alist-path)))
  
  (defun org-pm-load-project-configs ()
    "Load the contents of the following variables from org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes."
    (load-file (org-pm-get-auto-save-path)))
#+END_SRC

#+RESULTS:
: org-pm-load-project-configs

  
Note: The following should be included in the startup procedure for loading org-publish-meta: 

#+BEGIN_SRC elisp
(org-pm-load-project-configs)
#+END_SRC
* NEEDS_REVIEW Step 2: Construct default project for a file
:PROPERTIES:
:ID:       7FA277CA-8253-4BFB-9574-32D29E505BE0
:END:

#+BEGIN_SRC elisp
  
  (require 'cl)
  (load-file "dash.el")
  
  (defvar org-pm-default-project-properties 
    '(
      :recursive t
      :publishing-function org-publish-org-to-html
      :base-extension "org"
      )
  "Default properties for org-publish.  These are used by org-pm-make-default-project
  to construct the default project alist component for a file.
  The base-directory and publishing-directory properties are provided 
  by org-pm-make-default-project.
  ")
  
  (defun merge-plists (plist-a &rest plist-b)
    (-reduce-from
     (lambda (plist-a plist-b)
       (->> (-partition 2 plist-b)
         (-reduce-from
          (lambda (acc it)
            (let ((key (first it))
                  (val (second it)))
              (plist-put acc key val)))
          plist-a)))
     plist-a
     plist-b))
  
  (defun org-pm-make-project-defaults ()
    "Construct a default org-publish-project configuration alist.
  If project-name is given, use it.
  Otherwise use the file-name-sans-extension of the current buffer
  as project name"
    (let* (
           (pm-def-file  (buffer-file-name (current-buffer)))
           (base-dir (file-name-directory pm-def-file))
           (plist (copy-list org-pm-default-project-properties)))
      (setq plist (plist-put plist :base-directory (concat base-dir "org/")))
      (setq plist (plist-put plist :publishing-directory (concat base-dir "html/")))
      (setq plist (plist-put plist :file pm-def-file))
      (setq plist 
            (plist-put 
             plist :project-name
             (file-name-nondirectory (file-name-sans-extension pm-def-file))))
      plist
      ))
#+END_SRC

The following must be modified to follow the new scheme described in

[[file:org-publish-meta.org::#id:2C1A8D6A-7A07-4825-9557-D8026FCD3377][Publishing principles]]

Publishing principles, specification, options, format + feature considerations]]

 [[file:org-publish-meta.org][org-publish-meta]
#+BEGIN_SRC elisp  
  (defun org-pm-get-file-project-config ()
    "Get the project configuration list for the current file.
  Provide essential defaults if missing."
    (org-pm-load-project-configs)
    (beginning-of-buffer)
;; not here ...
    (let ((config (org-pm-get-node-project-configs)))
      (setq 
       config
       (merge-plists 
        (unless config
          (assoc (plist-get config :project-name) org-publish-project-alist)
          config)
        (org-pm-make-project-defaults)
        ))
      (cons (plist-get config :project-name) plist)))

  (defun org-pm-get-node-project-configs ()
    "Get *all* project configs contained in this file, 
by parsing nodes that have the tag: project_config"
  )
#+END_SRC

#+RESULTS:
: org-pm-make-default-project

For the org-pm-get-node-project-config
see http://orgmode.org/manual/Using-the-mapping-API.html#Using-the-mapping-API
and http://orgmode.org/manual/Matching-tags-and-properties.html

Test: 
#+BEGIN_SRC elisp
(org-pm-make-default-project)
#+END_SRC

See also: 
org-cut-subtree

(org-insert-heading "alpha")

(org-cut-subtree)

* UNDERWAY Step 3: Try publishing a project with default properties

Under construction

TODO: review [[id:7FA277CA-8253-4BFB-9574-32D29E505BE0][this]] and make new function as described in code below,
I mean function org-pm-node-get-project-config.

Draft of all steps: 

      ;; Get project config from node 
      ;; If it exists here, then ALWAYS reinitialize it to update edited changes

    ;; if no config was found, then: 
    ;; get the name of the project from the file header
    ;; if not found, provide project name
    ;; try to find project config from project alist
    ;; if not found, then create default project with the given project name. 


  ;; Get project configs of all nodes in project
  ;; Get file config of file
  ;; Get file configs of all nodes in project
  ;; Resolve inheritances
  ;; Resolve subfile-ignores
  ;; Build list of projects contained in file project config
  ;; and in the configs of all nodes in this file
  ;; For all projects in the list of projects, 
  ;; publish project.



#+BEGIN_SRC elisp
  
  ;;; ;;;;;;;;;;; NOT DONE YET ;;;;;;;;;;;;;;;;;;;;;
  
  (defun org-pm-publish ()
    "Create all project files for this file and then publish them."
    (interactive)
    (org-pm-load-project-configs)
    ;; here insert save-excursion etc.
    ;; 
    ;; !!!!!!!!!! save-excursion.
    ;; For the rest of this function.
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (let* 
        projects
        ;; Get project config from node 
        ;; If it exists here, then ALWAYS reinitialize it to update edited changes
        ((project-config (org-pm-node-get-project-config)))
      ;; if no config was found, then: 
      ;; get the name of the project from the file header
      ;; if not found, provide project name
      ;; try to find project config from project alist
      ;; if not found, then create default project with the given project name. 
  
      ;; must rework this into new function: 
      ;; org-pm-get-file-project-config
      ;; this function gets the config for this file from scratch.
      ;; Do this by combining the code below with the code in
      ;; org-pm-make-default project.
      ;; link for this is given above.
      (unless project-config
        (let ((project-name (org-pm-get-project-name)))
          (setq project-config (assoc project-name org-publish-project-alist))
          (unless project-config
            (setq project-config (org-pm-default-project-config project-name)))
          )
       )
      ;; Get project configs of all nodes in project
      (org-pm-get-node-configs)
      ;; Get file config of file
      (org-pm-get-file-params)
      ;; Get file configs of all nodes in project
      (org-pm-get-node-params)
      ;; Resolve inheritances
      (org-pm-process-subproject-configs)
      ;; Resolve subfile-ignores
      (org-pm-make-subprocess-ignores)
      ;; Build list of projects contained in file project config
      ;; and in the configs of all nodes in this file
      (setq projects (org-pm-collect-projects-for-file))
  
      ;; For all projects in the list of projects, 
      ;; publish project.
      (dolist (project projects)
        (org-publish project))
      )
  )
#+END_SRC
* Options for org-pm-dispatch top level function dispatcher
:PROPERTIES:
:DATE:     <2013-12-04 Wed 20:12>
:END:

The interactive command function org-pm-dispatch will open a dispatcher modeled after that of function org-export-dispatch.  

When called with an argument (C-u prefix), the function will automatically publish the related projects when done.  Otherwise it will just create project configs and copy the parts of org files concerned.  The options of the dispatcher refer to which files and which parts of files should be processed and copied to projects.  The options are: 

- f :: file of current buffer and all nodes that belong to the project of this file only
- a :: file of current buffer and all nodes it contains (also those belonging to other projects)
- n :: current node and its subnodes only
- p :: all files belonging to the project that the file of the current buffer belongs to. 
- * :: all files of all projects
* getting the project definition from a node
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

** Use these functions from dynsite to start:
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

#+BEGIN_SRC elisp

(defun org-custom-properties (file)
  "parse project def data in file and put them in a project-definition alist"
  (message "working on %s ..." file)
  (save-excursion
    (let ((buffer (find-file-noselect file)) def)
      (set-buffer buffer)
      (setq buffer-read-only t)
      (setq def (get-proj-def-from-org-nodes))
      (kill-buffer buffer)
      def)))

(defun get-proj-def-from-org-nodes ()
  (org-map-entries 
   '(save-excursion 
      (let* ((heading 
	      (progn 
		(re-search-forward (concat "^\\(" outline-regexp "\\)\\([^\n]*$\\)") nil 'move)
		(match-string-no-properties 2)))
	     (body 
	      (buffer-substring-no-properties (point) (org-entry-end-position))))
      (construct-proj-property heading body)))))

(defun construct-proj-property (heading body)
  "construct cons pair from heading and body of org node parsed by get-proj-def-from-org-nodes
   headings of the format <propertyname>: <property> create property-value pair"
  (let ((property-p (string-match "^\\([^: ]*\\): \\(.*\\)" heading)))
    (if property-p
        (cons (match-string 1 heading) (car (read-from-string (match-string 2 heading))))
      (cons heading body))))

#+END_SRC

** Combine with this, to get header, properties, description and filter with tag
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

#+BEGIN_SRC elisp
        (org-map-entries 
           '(let (
                  (props (cadr  (org-element-at-point)))
                  (descr-start 
                   (re-search-forward "^:DESCRIPTION:" (plist-get props :contents-end)))
                  (descr-end
                   (re-search-forward "^:END:" (plist-get props :contents-end))))
              (setq 
               props
               (plist-put 
                props 
                :contents 
                (buffer-substring 
                 (plist-get props :contents-begin)
                 (plist-get props :contents-end)))
                    )
              (if (and descr-start descr-end)
                  (setq props
                        (plist-put 
                         props :description 
                         (buffer-substring (+ 1 descr-start) (- descr-end 6))))
                )
              props)
           "project_config"
           )
#+END_SRC


