#+TODO: TODO UNDERWAY NEEDS_REVIEW | DONE CANCELLED DEFERRED

Developing the org-publish-meta application incrementally, step-by-step.

* UNDERWAY Saving org-pm project info
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

** Store path of project definition file in org-publish-project-alist
:PROPERTIES:
:DATE:     <2013-12-17 Tue 09:25>
:END:

Org-pm adds to the org-publish-project-alist one additional property:

- org-pm-def-file :: The path of the file which contains the definition of this project.

This is useful for opening the file that contains the definition of a project.

The org-pm-def-file property is generated along with the other data when the project definition node is parsed.

** Store files containing source for projects in org-pm-project-files

The variable =org-pm-project-files= contains an association list of paths to files followed by the projects which the files contents should be copied to.  For example, if a file contains one node that should be copied to project1 and another node that should be copied to project2, while the whole file should be copied to project3, and the path for file is "/path/to/file.org", the the entry for that file is:

("/path/to/file.org" "project1" "project2" "project3")

The entire list =org-pm-project-files= thus looks like this:

#+BEGIN_SRC elisp
  '(
    ("/path/to/file1.org" "project1" "project2")
    ("path/to/file2.org" "project1" "project3" ...)
    ...
  )
#+END_SRC

Details:

Each entry of the list in =org-pm-project=files= contains with the name of one file, followed by all projects that this file or its nodes are copied to.  The details of which node goes to which project are not stored here, but always read from the file just before doing the copying.  The information for building the list of projects is contained only in the file itself.  Therefore, the list of projects for a file is created and stored just when that file is parsed with org-pm-parse file.

** Auto-saving the org-pm project info

org-publish-project-alist and org-pm-project-files is auto-saved after each generation of project definitions from org-files (function =org-pm-make-file-projects=).  The saving function is: =org-pm-save-projects=.

** Utility functions for saving emacs lisp data
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

#+BEGIN_SRC elisp

(defun dump-vars-to-file (varlist filename)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf)
      (save-buffer)
      (kill-buffer))))

(defun dump (varlist buffer)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (loop for var in varlist do
        (print (list 'setq var (list 'quote (symbol-value var)))
               buffer)))

(defun checkit ()
  (interactive)
  (let ((a '(1 2 3 (4 5)))
        (b '(a b c))
        (c (make-vector 3 'a)))
    (dump-vars-to-file '(a b c) "/Users/iani2/Desktop/TEST.el")))
#+END_SRC

#+RESULTS:
: checkit

** Project save and load project alist functions
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:ID:       2624DC79-CBF5-413A-8BB5-4FD6B90E4CB9
:END:

#+BEGIN_SRC elisp

  (defvar org-pm-auto-save-path nil
    "Location where org-publish-meta saves and loads the contents of:
  - org-publish-project-alist,
  - org-pm-files
  - org-pm-nodes")

  (defvar org-pm-files nil
    "Assoc-list of files belonging to org-publish-projects.
  Each element of the list is of the form:
  (full-file-path
   :project projectname
   :nodes (nodelist)
   :config (export config parameters))"
  )

  (defvar org-pm-nodes nil
    "Assoc-list of org-nodes belonging to org-publish-projects.
  Each element of the list is of the form:
  (node-id
   :file full-file-path
   :configs (export config parameters)
   :projects
   (
    (projectname :folder folderpath :file filename)
    (projectname2 :folder folderpath :file filename)
    )"
  )

  (defun org-pm-get-auto-save-path ()
    "Get the path where org-publish-project-alist should be auto-saved.
  if ~/.emacs.d is present, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.
  Create savefile folder if it does not exist. "
    (or
     org-pm-auto-save-path
    (setq org-pm-auto-save-path
     (let* (
           (home (expand-file-name "~/"))
           (emacs-d-path (concat home ".emacs.d/"))
           )
       (cond
        ((file-exists-p emacs-d-path)
         (setq emacs-d-path (concat emacs-d-path "savefile/"))
         (unless (file-exists-p emacs-d-path) (make-directory emacs-d-path))
         (concat emacs-d-path "org-publish-meta"))
        (t (concat home ".org-publish-meta"))
        )))))

  (defun org-pm-save-projects ()
    "Save the contents of the following variables to org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes.
  Uses dump-vars-to-file"
    (dump-vars-to-file
     '(org-publish-project-alist org-pm-files org-pm-nodes)
     (org-pm-get-project-alist-path)))

  (defun org-pm-load-project-configs ()
    "Load the contents of the following variables from org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes."
    (load-file (org-pm-get-auto-save-path)))
#+END_SRC

#+RESULTS:
: org-pm-load-project-configs


Note: The following should be included in the startup procedure for loading org-publish-meta:

#+BEGIN_SRC elisp
(org-pm-load-project-configs)
#+END_SRC

* UNDERWAY Project definition parsing code
:PROPERTIES:
:DATE:     <2013-12-09 Mon 00:58>
:ID:       2260C2D9-268F-4A0B-8F02-BD70445988A1
:END:

** DONE Auxiliary functions 2: getting header properties, merging plists
CLOSED: [2013-12-16 Mon 09:04]
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

*** Get header properties
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

#+BEGIN_SRC elisp
(defun org-get-header-property (property &optional all)
  "Get property from buffer variable.  Returns only fist match except if ALL is defined.
NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
  (with-current-buffer
	(current-buffer)
    (save-excursion
      (save-restriction
	(save-match-data
	  (widen)
	  (goto-char (point-min))
	  (let (values)
	    (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
	      (add-to-list 'values (substring-no-properties (match-string 1))))
	    (if all
		values
	      (car values))))))))
#+END_SRC

#+RESULTS:
: org-get-header-property

#+BEGIN_SRC elisp
(org-get-header-property "TEST")
#+END_SRC

#+RESULTS:

*** DEFERRED Plist merging for inheritance (later)
CLOSED: [2013-12-16 Mon 00:57]
:PROPERTIES:
:ID:       7FA277CA-8253-4BFB-9574-32D29E505BE0
:END:

#+BEGIN_SRC elisp

  (require 'cl)
  (load-file "dash.el")

  (defvar org-pm-default-project-properties
    '(
      :recursive t
      :publishing-function org-publish-org-to-html
      :base-extension "org"
      )
  "Default properties for org-publish.  These are used by org-pm-make-default-project
  to construct the default project alist component for a file.
  The base-directory and publishing-directory properties are provided
  by org-pm-make-default-project.
  ")

  (defun merge-plists (plist-a &rest plist-b)
    (-reduce-from
     (lambda (plist-a plist-b)
       (->> (-partition 2 plist-b)
         (-reduce-from
          (lambda (acc it)
            (let ((key (first it))
                  (val (second it)))
              (plist-put acc key val)))
          plist-a)))
     plist-a
     plist-b))

#+END_SRC


** Global variables
:PROPERTIES:
:DATE:     <2013-12-16 Mon 01:47>
:END:

*** Template for creating project plists: org-pm-default-project-plist
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:53>
:END:
#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-plist
    '(
      :base-extension "org"
      :recursive t
      :publishing-function org-publish-org-to-html
      :headline-levels 5
      :auto-preamble t
    )
  "The defalt properties for publishing a project with html.
  Used to provide initial contents when creating a project plist in
  org-pm-make-default-project-plist. "
  )
#+END_SRC

#+RESULTS:
: org-pm-default-project-plist

*** org-pm-project-files
:PROPERTIES:
:DATE:     <2013-12-17 Tue 15:08>
:END:



*** Appendix: Testing plists vs alists for file, node, folder info
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:01>
:END:

Looking at plist and alist alternatives. Alist may be better after all.

Need to modify the org-pm-files list if I want to add files, nodes and their folders as plist-properties in the cdr of each project list.

**** CANCELLED Plist version
CLOSED: [2013-12-16 Mon 04:08]
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:56>
:END:
The plists do not have to have symbols as keys, if I use lax-plist-get and lax-plist-put instead of plist-get and plist-put.  See: http://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html

Testing here:

#+BEGIN_SRC elisp
(setq alpha '("alpha" 1 2 3))

(setcdr alpha (cons 123 (cdr alpha)))

Also note:

(setq test (remove* "alpha" test :test 'equal :key 'car))

#+END_SRC

#+RESULTS:
| alpha | 123 | 1 | 2 | 3 |

Suppose the alist entry of a project is of the form:

#+BEGIN_SRC elisp
  (setq
   ptest
   '(
     ("projectalpha" :file1 nil :nodex "folderx")
     ("project2" :file2 "foldern" :nodex nil)
     )
  )
#+END_SRC

#+RESULTS:
| projectalpha | :file1 | nil     | :nodex | folderx |
| project2     | :file2 | foldern | :nodex | nil     |

Trying to edit:

#+BEGIN_SRC elisp
  (let* ((alist (assoc "projectalpha" ptest ))
         (plist (cdr alist)))
    (setcdr alist (plist-put plist :newfile "newfolder")))
  ptest
#+END_SRC

#+RESULTS:
| projectalpha | :file1 | nil     | :nodex | folderx | :newfile | newfolder |
| project2     | :file2 | foldern | :nodex | nil     |          |           |

#+BEGIN_SRC elisp
  (let* ((alist (assoc "projectalpha" ptest ))
         (plist (cdr alist)))
    (setcdr alist (plist-put plist :newfile "newfolder")))
  ptest
#+END_SRC

**** UNDERWAY Alist version
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:56>
:END:

#+BEGIN_SRC elisp
  (setq
   atest
   '(
     ("projectalpha" ("file1") ("nodex" . "folderx"))
     ("project2"  ("file2" . "foldery") ("nodex"))
     )
  )
#+END_SRC

#+RESULTS:
| projectalpha | (file1)           | (nodex . folderx) |
| project2     | (file2 . foldery) | (nodex)           |

***** Accessing/finding:

#+BEGIN_SRC elisp
  (cdr (assoc "nodex" (cdr (assoc "projectalpha" atest))))
#+END_SRC

#+RESULTS:
: folderx

***** Trying to edit:

#+BEGIN_SRC elisp
  (let* ((all (assoc "projectalpha" atest ))
         (pairs (cdr all))
         (node (assoc "nodex" pairs))
         )
    (setcdr all (delq node pairs)))
  atest
#+END_SRC

#+RESULTS:
| projectalpha | (file1)           |         |
| project2     | (file2 . foldery) | (nodex) |

** TODO org-pm-parse-buffer : Parse project definitions+components
:PROPERTIES:
:DATE:     <2013-12-18 Wed 10:56>
:END:

** Adding/removing files/nodes to/from projects
:PROPERTIES:
:DATE:     <2013-12-16 Mon 04:11>
:END:

*** org-pm-files: list of projects and files belonging to each project
:PROPERTIES:
:DATE:     <2013-12-17 Tue 00:16>
:END:

List of files and nodes that are copied as single files to project source (org) folders.
org-pm-files is of the form:
#+BEGIN_ASCII
(
    (projectname (file1 . folder) (file2 . folder) ...)
    (projectname2 ...)
    ...
)
#+END_ASCII

The variable org-pm-files registers all files and nodes that belong to each project under the name of the project.  When publishing a project, the list of files and nodes that belong to a project is processed and copied to the designated folder.  The designated folder is either the root folder of the source of the project or a subfolder of it.  The folder part of the list in each file-folder pair: =(file . folder)= indicates the subfolder where the component should be copied.  If the subfolder is the empty string, then the component is copied to the root folder of the project.

#+BEGIN_SRC emacs-lisp
  (defvar org-pm-files nil
    "List of files and nodes that are copied as single files to project
    source (org) folders.  org-pm-files is of the form:
           (
             (projectname (file1 . folder) (file2 . folder) ...)
             (projectname2 ...)
             ...
            )
  The variable org-pm-files registers all files and nodes that belong
  to each project under the name of the project.  When publishing a project,
  the list of files and nodes that belong to a project is processed and copied
  to the designated folder.  The designated folder is either the root folder of
  the source of the project or a subfolder of it.  The folder part of the list
  in each file-folder pair:
     (file . folder)
  indicates the subfolder where the component should be copied.  If the subfolder
  is the empty string, then the component is copied to the root folder of the project.")

 #+END_SRC

*** Functions for adding and removing files to org-pm-files
:PROPERTIES:
:DATE:     <2013-12-17 Tue 00:20>
:END:

#+BEGIN_SRC elisp
  (defun org-pm-add-component (project component folder)
    "Component is a file or node to be published.
    A component is added to a project so that it will
    be copied to the source folder of the project for publishing.
    This function adds (component . folder) to that sublist of org-pm-files
    whose first element equals project.  See doc string of org-pm-files for more."

    ;; A component can only be present once in a project.
    ;; Therefore remove previous instance if present:
    (org-pm-remove-component project component)
    (unless (stringp folder) (setq folder ""))
    (let ((all (assoc project org-pm-files)) pairs item)
      (cond (all
             (setq pairs (cons (cons component folder) (cdr all)))
             (setcdr all pairs))
            (t
             (setq org-pm-files
                   (cons (list project (cons component folder)) org-pm-files))))))

  (defun org-pm-remove-component (project component)
    "Component is a file or node.  Remove this component from the project."
    (let* ((all (assoc project org-pm-files))
           (pairs (cdr all))
           (item (assoc component pairs)))
      (if all (setcdr all (delq item pairs)))))

  (defun org-pm-get-file-components (file-name)
    "Find all components (nodes) of a file that have been added to any project.
    (Include the file itself if it is part of a project).
    Return a list of the form: (
           (project1 (file-or-node1 . folder) (file-or-node3 . folder) ...)
            (project2 (file-or-node2 . folder) ...)
    This is an association-list with keys the names of the project and values
    the lists of components, where each conponent has the form: (file-or-node . folder)"

    (let (result project components component (regexp (concat "^" file-name "::")))
      (dolist (projects org-pm-files)
        (setq project (car projects))
        (setq components (cdr projects))
        (dolist (file-and-folder components)
          (setq component (car file-and-folder))
          (if (or
               (equal file-name component)
               (string-match regexp component))
              ;;            (setq result (cons (list project file-and-folder) result))
              (setq result (assoc-add result project file-and-folder)))))
      result))

  (defun assoc-add (alist key value)
    "Add value to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons value (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key value) (cdr alist)))
          (setq alist (list (list key value))))))
    alist)

  ;;
  (defun assoc-remove (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))

    ;;; older version
  (defun assoc-remove-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))

  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
       add (cons key newlist) to alist."
    (setq alist (assoc-remove alist key))
    (setq alist (cons (cons key newlist) alist))
    )
#+END_SRC

#+RESULTS:
: assoc-replace

*** Tests of auxiliary functions 1
:PROPERTIES:
:DATE:     <2013-12-16 Mon 04:51>
:END:
#+BEGIN_SRC elisp
  (setq org-pm-files nil)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp
(org-pm-remove-component "alpha" "index")
org-pm-files
#+END_SRC

#+RESULTS:
| alpha |

#+BEGIN_SRC elisp
  (setq org-pm-files
        '(("alpha" ("index" . "")))
  )
#+END_SRC

#+RESULTS:
| alpha | (index . ) |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "index" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (index . ) |
| alpha    |            |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "chapter1" "chapters")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (chapter1 . chapters) | (index . ) |
| alpha    |                       |            |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "chapter1" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (chapter1 . ) | (index . ) |
| alpha    |               |            |

#+BEGIN_SRC elisp
(org-pm-remove-component "project1" "chapter1")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (index . ) |
| alpha    |            |

#+BEGIN_SRC elisp
(org-pm-add-component "alpha" "index" "")
(org-pm-add-component "alpha" "index::node1" "")
(org-pm-add-component "project2" "other-file" "")
(org-pm-add-component "alpha" "other-file-3" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project2 | (other-file . )   |                   |            |
| project1 | (index . )        |                   |            |
| alpha    | (other-file-3 . ) | (index::node1 . ) | (index . ) |

#+BEGIN_SRC elisp
  (org-pm-get-file-components "index")
#+END_SRC
#+RESULTS:
| project1 | (index . ) |                   |
| alpha    | (index . ) | (index::node1 . ) |

#+BEGIN_SRC elisp
(setq assoc-add-test nil)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key1" "value1"))
#+END_SRC

#+RESULTS:
| key1 | value1 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key1" "value2"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value5"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |
| key3 | value5 |        |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value3"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |
| key3 | value3 | value5 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value7"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |        |
| key3 | value7 | value3 | value5 |


#+BEGIN_SRC elisp
assoc-add-test
#+END_SRC
#+RESULTS:

#+BEGIN_SRC elisp
(setcdr nil 1)
#+END_SRC

** Creating the default project definition for a file.
:PROPERTIES:
:DATE:     <2013-12-17 Tue 00:33>
:END:

Drafting:

- When running org-pm-publish


* project configs here                                      :PROJECT_DEFS:

** project1
*** the_title (list "with" "many" "types")
*** title_with_one_type_only
but some contents
*** title2
** project2
*** more 123
:PROPERTIES:
:ID:       5853E3D5-82E5-4CCF-89A5-A53E0BC8281B
:END:



* UNDERWAY Step 3: Try publishing a project with default properties

Under construction

TODO: review [[id:7FA277CA-8253-4BFB-9574-32D29E505BE0][this]] and make new function as described in code below,
I mean function org-pm-node-get-project-config.

Draft of all steps:

    ;; Get project config from node
    ;; If it exists here, then ALWAYS reinitialize it to update edited changes

    ;; if no config was found, then:
    ;; get the name of the project from the file header
    ;; if not found, provide project name from file name
    ;; try to find project config from project alist
    ;; if not found, then create default project with the given project name.


    ;; Get project configs of all nodes in project
    ;; Get file config of file
    ;; Get file configs of all nodes in project
    ;; Resolve inheritances
    ;; Resolve subfile-ignores
    ;; Build list of projects contained in file project config
    ;; and in the configs of all nodes in this file
    ;; For all projects in the list of projects,
    ;; publish project.

#+BEGIN_SRC elisp

  ;;; ;;;;;;;;;;; NOT DONE YET ;;;;;;;;;;;;;;;;;;;;;

  (defun org-pm-publish ()
    "Create all project files for this file and then publish them."
    (interactive)
    (org-pm-load-project-configs)
    ;; here insert save-excursion etc.
    ;;
    ;; !!!!!!!!!! save-excursion.
    ;; For the rest of this function.
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (let*
        ;; Build list of all projects defined in this file
        ((projects (org-pm-get-file-project-defs))
         (file-project (assoc (buffer-file-name) projects)))
      ;; if no config was found, then:
      ;; get the name of the project from the file header
      ;; if not found, provide project name
      ;; try to find project config from project alist
      ;; if not found, then create default project with the given project name.

      ;; must rework this into new function:
      ;; org-pm-get-file-project-config
      ;; this function gets the config for this file from scratch.
      ;; Do this by combining the code below with the code in
      ;; org-pm-make-default project.
      ;; link for this is given above.

      (unless project-config
        (let ((project-name (org-pm-get-project-name)))
          (setq project-config (assoc project-name org-publish-project-alist))
          (unless project-config
            (setq project-config (org-pm-default-project-config project-name)))
          )
        )

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; following go to org-pm-get-file-project-defs
      ;; Get private configs of all nodes in project

      (org-pm-get-node-configs)
      ;; Get file config of file

      (org-pm-get-file-params)
      ;; Get file configs of all nodes in project

      (org-pm-get-node-params)
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      ;; Resolve inheritances
      (org-pm-process-subproject-configs)

      ;; Resolve subfile-ignores
      (org-pm-make-subprocess-ignores)

      ;; For all projects in the list of projects,
      ;; publish project.

      (dolist (project projects)
        (org-publish project))

  )
#+END_SRC


* Useful links - doc
:PROPERTIES:
:DATE:     <2013-12-16 Mon 00:58>
:END:
[[file:org-publish-meta.org::#2C1A8D6A-7A07-4825-9557-D8026FCD3377][Publishing principles, specification, options, format + feature considerations]]

see http://orgmode.org/manual/Using-the-mapping-API.html#Using-the-mapping-API
and http://orgmode.org/manual/Matching-tags-and-properties.html

* Finding nodes that have a tag matching with wildcard "_*_"
:PROPERTIES:
:DATE:     <2013-12-06 Fri 23:23>
:END:

Note: This will insert as many copies of a nodes' entry plist as there are tags in that entry which both begin with _ and end with _.

To insert only one entry, use the dolist to return true if a match is found, and then cons the plist.

Alternatively, modify this form to return a list of a-lists with the tag followed by the plist.  This could be useful to copy a node to multiple projects specified by multiple tags.

#+BEGIN_SRC elisp
  (let (matched-entries (wildcard "^_.*_$"))
   (org-map-entries
    '(let*
         ((props (cadr (org-element-at-point))))
       (dolist
           (tag (plist-get props :tags))
         (if (string-match wildcard tag)
             (setq matched-entries (cons props matched-entries)))))
    )
   matched-entries)
#+END_SRC

* getting the project definition from a node
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

** Getting, content properties, description drawer (for copying to publication file)
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

#+BEGIN_SRC elisp
        (org-map-entries
           '(let (
                  (props (cadr  (org-element-at-point)))
                  (descr-start
                   (re-search-forward "^:DESCRIPTION:" (plist-get props :contents-end)))
                  (descr-end
                   (re-search-forward "^:END:" (plist-get props :contents-end))))
              (setq
               props
               (plist-put
                props
                :contents
                (buffer-substring
                 (plist-get props :contents-begin)
                 (plist-get props :contents-end)))
                    )
              (if (and descr-start descr-end)
                  (setq props
                        (plist-put
                         props :description
                         (buffer-substring (+ 1 descr-start) (- descr-end 6))))
                )
              props)
           "project_config"
           )
#+END_SRC
* Proj def test dummy supernode 1                           :PROJECT_DEFS:
* Proj def test dummy supernode 2                           :PROJECT_DEFS:
** Project 323
:PROPERTIES:
:ID:       5762DFE3-831A-42DD-B2C4-137F68B8D711
:END:
*** xonwrwan 123123
:PROPERTIES:
:ID:       42737B2C-54FD-40EC-9DF0-0F3CD10EBB64
:END:

* Earlier project def parsing tests
:PROPERTIES:
:DATE:     <2013-12-16 Mon 01:56>
:END:
#+BEGIN_SRC elisp
(org-pm-make-default-project-plist)
#+END_SRC

#+BEGIN_SRC elisp
(org-pm-make-projects)
#+END_SRC
#+RESULTS:
| project2    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project2    | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :more      |               123 |                           |                     |         |     |
| project1    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project1    | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :the_title | (with many types) | :title_with_one_type_only | but some contents\n | :title2 | nil |
| Project 323 | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | Project 323 | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org |            |                   |                           |                     |         |     |


* More recent tests

#+BEGIN_SRC elisp
 (org-pm-make-projects)
#+END_SRC

#+RESULTS:
| Project 323 | :base-extension | org | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :project-name | Project 323 | :node-id | 42737B2C-54FD-40EC-9DF0-0F3CD10EBB64 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :xonwrwan  |            123123 |                           |                     |         |     |
| project2    | :base-extension | org | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :project-name | project2    | :node-id | 5853E3D5-82E5-4CCF-89A5-A53E0BC8281B | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :more      |               123 |                           |                     |         |     |
| project1    | :base-extension | org | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :project-name | project1    | :node-id | 5853E3D5-82E5-4CCF-89A5-A53E0BC8281B | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :the_title | (with many types) | :title_with_one_type_only | but some contents\n | :title2 | nil |
