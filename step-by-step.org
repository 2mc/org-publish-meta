#+TODO: TODO UNDERWAY NEEDS_REVIEW | DONE CANCELLED DEFERRED

Developing the org-publish-meta application incrementally, step-by-step. 

* DONE Step 1: Auto-save of org-publish-project-alist
CLOSED: [2013-12-04 Wed 17:59]
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

** Utility functions for saving emacs lisp data
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:END:

#+BEGIN_SRC elisp

(defun dump-vars-to-file (varlist filename)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf)
      (save-buffer)
      (kill-buffer))))

(defun dump (varlist buffer)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (loop for var in varlist do
        (print (list 'setq var (list 'quote (symbol-value var)))
               buffer)))

(defun checkit ()
  (interactive)
  (let ((a '(1 2 3 (4 5)))
        (b '(a b c))
        (c (make-vector 3 'a)))
    (dump-vars-to-file '(a b c) "/Users/iani2/Desktop/TEST.el")))
#+END_SRC

#+RESULTS:
: checkit

** The project save and load project alist functions
:PROPERTIES:
:DATE:     <2013-12-04 Wed 12:47>
:ID:       2624DC79-CBF5-413A-8BB5-4FD6B90E4CB9
:END:

#+BEGIN_SRC elisp
  
  (defvar org-pm-auto-save-path nil
    "Location where org-publish-meta saves and loads the contents of:
  - org-publish-project-alist,
  - org-pm-files
  - org-pm-nodes")
  
  (defvar org-pm-files nil
    "Assoc-list of files belonging to org-publish-projects.
  Each element of the list is of the form: 
  (full-file-path 
   :project projectname 
   :nodes (nodelist)
   :config (export config parameters))"
  )
  
  (defvar org-pm-nodes nil
    "Assoc-list of org-nodes belonging to org-publish-projects.
  Each element of the list is of the form: 
  (node-id 
   :file full-file-path 
   :configs (export config parameters)
   :projects 
   (
    (projectname :folder folderpath :file filename)
    (projectname2 :folder folderpath :file filename)
    )"
  )
  
  (defun org-pm-get-auto-save-path ()
    "Get the path where org-publish-project-alist should be auto-saved.
  if ~/.emacs.d is present, use ~/.emacs.d/savefile/org-publish-project-alist
  else use ~/.org-publish-project-alist.  
  Create savefile folder if it does not exist. "
    (or
     org-pm-auto-save-path
    (setq org-pm-auto-save-path 
     (let* (
           (home (expand-file-name "~/"))
           (emacs-d-path (concat home ".emacs.d/"))
           )
       (cond
        ((file-exists-p emacs-d-path)
         (setq emacs-d-path (concat emacs-d-path "savefile/"))
         (unless (file-exists-p emacs-d-path) (make-directory emacs-d-path))
         (concat emacs-d-path "org-publish-meta"))
        (t (concat home ".org-publish-meta"))
        )))))
  
  (defun org-pm-save-project-configs ()
    "Save the contents of the following variables to org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes.
  Uses dump-vars-to-file"
    (dump-vars-to-file 
     '(org-publish-project-alist org-pm-files org-pm-nodes)
     (org-pm-get-project-alist-path)))
  
  (defun org-pm-load-project-configs ()
    "Load the contents of the following variables from org-pm-auto-save-path:
  - org-publish-project-alist
  - org-pm-files
  - org-pm-nodes."
    (load-file (org-pm-get-auto-save-path)))
#+END_SRC

#+RESULTS:
: org-pm-load-project-configs

  
Note: The following should be included in the startup procedure for loading org-publish-meta: 

#+BEGIN_SRC elisp
(org-pm-load-project-configs)
#+END_SRC


* Global variables
:PROPERTIES:
:DATE:     <2013-12-16 Mon 01:47>
:END:
  
** Template for creating project plists: org-pm-default-project-plist
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:53>
:END:
#+BEGIN_SRC emacs-lisp
  (defvar org-pm-default-project-plist 
    '(
      :base-extension "org"
      :recursive t
      :publishing-function org-publish-org-to-html
      :headline-levels 5
      :auto-preamble t
    )
  "The defalt properties for publishing a project with html.
  Used to provide initial contents when creating a project plist in 
  org-pm-make-default-project-plist. "
  )
#+END_SRC

** UNDERWAY file and node lists
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:54>
:ID:       6EFBC165-94AE-4B9B-9EBC-0245DADFDCF8
:END:

Using alists. See subnodes here for investigation of plists vs alists and results.  Utility functions are provided for adding/removing/changing details of files/nodes in projects.

#+BEGIN_SRC emacs-lisp
    (defvar org-pm-files nil
      "List of files and nodes that are copied as single files to project
  source (org) folders.  Structure:
  ( 
     (project-name 
         (filename1)
         (filename2 . folder)
         (filename::nodeid . folder)
          ... 
     )
  ) "
      )
 #+END_SRC 

*** Testing plists vs alists for file, node, folder info
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:01>
:END:

Looking at plist and alist alternatives. Alist may be better after all.

Need to modify the org-pm-files list if I want to add files, nodes and their folders as plist-properties in the cdr of each project list.  

**** CANCELLED Plist version
CLOSED: [2013-12-16 Mon 04:08]
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:56>
:END:
The plists do not have to have symbols as keys, if I use lax-plist-get and lax-plist-put instead of plist-get and plist-put.  See: http://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html

Testing here: 

#+BEGIN_SRC elisp
(setq alpha '("alpha" 1 2 3))

(setcdr alpha (cons 123 (cdr alpha)))

Also note: 

(setq test (remove* "alpha" test :test 'equal :key 'car))

#+END_SRC

#+RESULTS:
| alpha | 123 | 1 | 2 | 3 |

Suppose the alist entry of a project is of the form: 

#+BEGIN_SRC elisp
  (setq 
   ptest 
   '(
     ("projectalpha" :file1 nil :nodex "folderx")
     ("project2" :file2 "foldern" :nodex nil)
     )
  )
#+END_SRC

#+RESULTS:
| projectalpha | :file1 | nil     | :nodex | folderx |
| project2     | :file2 | foldern | :nodex | nil     |

Trying to edit: 

#+BEGIN_SRC elisp
  (let* ((alist (assoc "projectalpha" ptest ))
         (plist (cdr alist)))
    (setcdr alist (plist-put plist :newfile "newfolder")))
  ptest
#+END_SRC

#+RESULTS:
| projectalpha | :file1 | nil     | :nodex | folderx | :newfile | newfolder |
| project2     | :file2 | foldern | :nodex | nil     |          |           |

#+BEGIN_SRC elisp
  (let* ((alist (assoc "projectalpha" ptest ))
         (plist (cdr alist)))
    (setcdr alist (plist-put plist :newfile "newfolder")))
  ptest
#+END_SRC

**** UNDERWAY Alist version
:PROPERTIES:
:DATE:     <2013-12-16 Mon 03:56>
:END:

#+BEGIN_SRC elisp
  (setq 
   atest 
   '(
     ("projectalpha" ("file1") ("nodex" . "folderx"))
     ("project2"  ("file2" . "foldery") ("nodex"))
     )
  )
#+END_SRC

#+RESULTS:
| projectalpha | (file1)           | (nodex . folderx) |
| project2     | (file2 . foldery) | (nodex)           |

***** Accessing/finding: 

#+BEGIN_SRC elisp
  (cdr (assoc "nodex" (cdr (assoc "projectalpha" atest))))
#+END_SRC

#+RESULTS:
: folderx

***** Trying to edit: 

#+BEGIN_SRC elisp
  (let* ((all (assoc "projectalpha" atest ))
         (pairs (cdr all))
         (node (assoc "nodex" pairs))
         )
    (setcdr all (delq node pairs)))
  atest
#+END_SRC

#+RESULTS:
| projectalpha | (file1)           |         |
| project2     | (file2 . foldery) | (nodex) |


* Auxiliary functions 1: adding/removing files/nodes to projects
:PROPERTIES:
:DATE:     <2013-12-16 Mon 04:11>
:END:

These operate on org-pm-files.  See [[id:6EFBC165-94AE-4B9B-9EBC-0245DADFDCF8][above]] for previous discussion. 

#+BEGIN_SRC elisp
  (defun org-pm-add-component (project component folder)
    "Component is a file or node.  It is added to a project so that it will
  be copied to the source folder of the project for publishing."
    
    ;; A component can only be present once in a project. 
    ;; Therefore remove previous instance if present:
    (org-pm-remove-component project component)
    (let ((all (assoc project org-pm-files)) pairs item)
      (cond (all
             (setq pairs (cons (cons component folder) (cdr all)))
             (setcdr all pairs))
        (t 
         (setq org-pm-files (cons (list project (cons component folder)) org-pm-files))))))
  
  (defun org-pm-remove-component (project component)
    "Component is a file or node.  Remove this component from the project."
    (let* ((all (assoc project org-pm-files))
           (pairs (cdr all))
           (item (assoc component pairs)))
      (if all (setcdr all (delq item pairs)))))
  
  (defun org-pm-get-file-components (file-name)
    "Find all components of a file that have been added to any project.
  Return a list of the form: (
         (project1 (file-or-node1 . folder) (file-or-node3 . folder) ...) 
          (project2 (file-or-node2 . folder) ...)
  This is an association-list with keys the names of the project and values
  the lists of components, where each conponent has the form: (file-or-node . folder)
  "
    (let (result project components component (regexp (concat "^" file-name "::")))
      (dolist (projects org-pm-files)
        (setq project (car projects))
        (setq components (cdr projects))
        (dolist (file-and-folder components)
          (setq component (car file-and-folder))
          (if (or
               (equal file-name component)
               (string-match regexp component))
  ;;            (setq result (cons (list project file-and-folder) result))
              (setq result (assoc-add result project file-and-folder)))))
      result))
  
  (defun assoc-add (alist key value)
    "Add value to the sublist of alist which starts with key."
    (let ((sublist (assoc key alist)))
      (if sublist
          (setcdr sublist (cons value (cdr sublist)))
        (if alist
            (setcdr alist (cons (list key value) (cdr alist)))
          (setq alist (list (list key value))))))
    alist)
  
  ;; 
  (defun assoc-remove (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (setq alist (remove* key alist :test 'equal :key 'car)))
  
  ;;; older version
  (defun assoc-remove-simple-style (alist key)
    "Remove all sublists of alist whose car is equal to key."
    (let (found)
      (while (setq found (assoc key alist))
        (setq alist (delq found alist)))
      alist))
  
  (defun assoc-replace (alist key newlist)
    "Remove all sublists of alist whose car is equal to key, and then
     add (cons key newlist) to alist."
    (setq alist (assoc-remove alist key))
    (setq alist (cons (cons key newlist) alist))
    )
#+END_SRC

#+RESULTS:
: org-pm-remove-component

** Tests of auxiliary functions 1
:PROPERTIES:
:DATE:     <2013-12-16 Mon 04:51>
:END:
#+BEGIN_SRC elisp
  (setq org-pm-files nil)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp
(org-pm-remove-component "alpha" "index")
org-pm-files
#+END_SRC

#+RESULTS:
| alpha |

#+BEGIN_SRC elisp
  (setq org-pm-files
        '(("alpha" ("index" . "")))
  )
#+END_SRC

#+RESULTS:
| alpha | (index . ) |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "index" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (index . ) |
| alpha    |            |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "chapter1" "chapters")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (chapter1 . chapters) | (index . ) |
| alpha    |                       |            |

#+BEGIN_SRC elisp
(org-pm-add-component "project1" "chapter1" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (chapter1 . ) | (index . ) |
| alpha    |               |            |

#+BEGIN_SRC elisp
(org-pm-remove-component "project1" "chapter1")
org-pm-files
#+END_SRC

#+RESULTS:
| project1 | (index . ) |
| alpha    |            |

#+BEGIN_SRC elisp
(org-pm-add-component "alpha" "index" "")
(org-pm-add-component "alpha" "index::node1" "")
(org-pm-add-component "project2" "other-file" "")
(org-pm-add-component "alpha" "other-file-3" "")
org-pm-files
#+END_SRC

#+RESULTS:
| project2 | (other-file . )   |                   |            |
| project1 | (index . )        |                   |            |
| alpha    | (other-file-3 . ) | (index::node1 . ) | (index . ) |

#+BEGIN_SRC elisp
  (org-pm-get-file-components "index")
#+END_SRC
#+RESULTS:
| project1 | (index . ) |                   |
| alpha    | (index . ) | (index::node1 . ) |

#+BEGIN_SRC elisp
(setq assoc-add-test nil)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key1" "value1"))
#+END_SRC

#+RESULTS:
| key1 | value1 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key1" "value2"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value5"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |
| key3 | value5 |        |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value3"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |
| key3 | value3 | value5 |

#+BEGIN_SRC elisp
(setq assoc-add-test (assoc-add assoc-add-test "key3" "value7"))
#+END_SRC

#+RESULTS:
| key1 | value2 | value1 |        |
| key3 | value7 | value3 | value5 |


#+BEGIN_SRC elisp
assoc-add-test
#+END_SRC
#+RESULTS:

#+BEGIN_SRC elisp
(setcdr nil 1)
#+END_SRC
* DONE Auxiliary functions 2: getting header properties, merging plists
CLOSED: [2013-12-16 Mon 09:04]
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

** Get header properties
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:50>
:END:

#+BEGIN_SRC elisp
(defun org-get-header-property (property &optional all)
  "Get property from buffer variable.  Returns only fist match except if ALL is defined.
NOTE: Also works if editing subtree narrowed or in separate narrowed buffer. "
  (with-current-buffer
	(current-buffer)
    (save-excursion
      (save-restriction
	(save-match-data
	  (widen)
	  (goto-char (point-min))
	  (let (values)
	    (while (re-search-forward (format "^#\\+%s:?[ \t]*\\(.*\\)" property) nil t)
	      (add-to-list 'values (substring-no-properties (match-string 1))))
	    (if all
		values
	      (car values))))))))
#+END_SRC

** DEFERRED Plist merging for inheritance (later)
CLOSED: [2013-12-16 Mon 00:57]
:PROPERTIES:
:ID:       7FA277CA-8253-4BFB-9574-32D29E505BE0
:END:

#+BEGIN_SRC elisp
  
  (require 'cl)
  (load-file "dash.el")
  
  (defvar org-pm-default-project-properties 
    '(
      :recursive t
      :publishing-function org-publish-org-to-html
      :base-extension "org"
      )
  "Default properties for org-publish.  These are used by org-pm-make-default-project
  to construct the default project alist component for a file.
  The base-directory and publishing-directory properties are provided 
  by org-pm-make-default-project.
  ")
  
  (defun merge-plists (plist-a &rest plist-b)
    (-reduce-from
     (lambda (plist-a plist-b)
       (->> (-partition 2 plist-b)
         (-reduce-from
          (lambda (acc it)
            (let ((key (first it))
                  (val (second it)))
              (plist-put acc key val)))
          plist-a)))
     plist-a
     plist-b))

#+END_SRC
* UNDERWAY Project definition parsing code
:PROPERTIES:
:DATE:     <2013-12-09 Mon 00:58>
:ID:       2260C2D9-268F-4A0B-8F02-BD70445988A1
:END:

** Parsing project definitions
:PROPERTIES:
:DATE:     <2013-12-16 Mon 02:00>
:END:
#+BEGIN_SRC emacs-lisp
  (defun org-pm-make-default-project-plist ()
    "Construct default plist for publishing a project in html."
    (let ((plist (copy-sequence org-pm-default-project-plist))
          (root (file-name-directory (buffer-file-name (current-buffer)))))
      (plist-put plist :base-directory (concat root "org"))
      (plist-put plist :publishing-directory (concat root "html"))))
  
  (defun org-pm-make-file-projects ()
    "Construct the projects for all project definitions found in current file.
  Project definitions are those nodes which are contained in nodes tagged as
  PROJECT_CONFIGS."
    (interactive)
    (save-excursion
      (save-restriction
        (widen)
        (org-pm-check-project-config-nodes)
        (let
            (project-def
             (template (org-pm-make-default-project-plist))
             (supernodes
              (org-map-entries '(cadr (org-element-at-point)) "PROJECT_CONFIGS"))
             project-def-list tags begin level)
          (dolist (node supernodes)
            (cond ((and
                    (plist-get node :tags)
                    (setq begin (plist-get node :contents-begin)))
                   (setq level (+ 1 (plist-get node :level)))
                   (save-excursion
                     (save-restriction
                       (narrow-to-region begin (plist-get node :contents-end))
                       (dolist 
                           (proj-node (org-map-entries '(cadr (org-element-at-point))))
                         (cond ((equal level (plist-get proj-node :level))
                                (setq project-def
                                      (org-pm-parse-project-def proj-node template))
                                (setq org-publish-project-alist 
                                      (assoc-replace
                                       org-publish-project-alist
                                       (car project-def)
                                       (cdr project-def)))
                                (push project-def 
                                      project-def-list)))))))))
          project-def-list))))
  
  (defun org-pm-check-project-config-nodes ()
    "Check if a node tagged POJECT_CONFIGS has invalid content before first subnode."
    (org-map-entries 
     '(let
          (begin (node (cadr (org-element-at-point))))
        (if (and 
             (setq begin (plist-get node :contents-begin))
             (member "PROJECT_CONFIGS" (plist-get node :tags))
             )
            ;; only works with if statement in the following way. Why?
            (if (equal 0 (string-match 
                          "\\*+ " 
                          (buffer-substring-no-properties begin (plist-get node :contents-end))))
                "ok"
              (error (format 
                      "ERROR: Node named '%s' should be empty before first subnode.\n%s"
                      (plist-get node :raw-value)
                      "Please remove all content before first subnode.")))
          ))
     "PROJECT_CONFIGS"))
  
  (defun org-pm-parse-project-def (proj-node template)
    "Return a project definition plist for the node represented by proj-node
  org-element plist."
    (let ((pdef (copy-sequence template))
          (pname (plist-get proj-node :raw-value))
          (begin (plist-get proj-node :contents-begin)))
      (setq pdef (plist-put pdef :project-name pname))
      (setq pdef (plist-put pdef :node-id (org-id-get-create)))
      (setq pdef (plist-put pdef :node-filename
                            (buffer-file-name (current-buffer))))
      (cond 
       (begin
        (save-excursion
          (save-restriction
            (narrow-to-region begin (plist-get proj-node :contents-end))
            (org-map-entries
             '(let* (
                     (element (cadr (org-element-at-point)))
                     (heading (plist-get element :raw-value))
                     (space (string-match " .*" heading))
                     prop-name prop-value contents-begin)
                (cond
                 (space
                  (setq prop-name (substring heading 0 space))
                  (setq prop-value (eval (read (substring heading space))))
                  (if (and 
                       (equal prop-name "include-containing-file")
                       prop-value)
                      (org-pm-add-component 
                       pname (buffer-file-name (current-buffer)) prop-value)))
                 (t (setq prop-name heading)
                    (setq contents-begin (plist-get element :contents-begin))
                    (if contents-begin
                        (setq 
                         prop-value 
                         (buffer-substring-no-properties 
                          contents-begin
                          (plist-get element :contents-end))))))
                (setq pdef
                      (plist-put pdef (intern (concat ":" prop-name)) prop-value))
                ))))))
      (cons pname pdef)))
  
#+END_SRC

#+RESULTS:
: org-pm-parse-project-def

For test purposes: 
#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c C-x t") 'org-pm-make-file-projects)
#+END_SRC

#+RESULTS:
: org-pm-make-file-projects

** Adding nodes and files to projects

#+BEGIN_SRC emacs-lisp
  (defun org-pm-add-file-to-project (project file folder)
    "Add file to org-pm-files, to copy for publishing."
    ()
  )
#+END_SRC

** project configs here                                    :PROJECT_CONFIGS:

*** project1
**** the_title (list "with" "many" "types")
**** title_with_one_type_only
but some contents
**** title2
*** project2
**** more 123
:PROPERTIES:
:ID:       5853E3D5-82E5-4CCF-89A5-A53E0BC8281B
:END:

* project def parsing tests
:PROPERTIES:
:DATE:     <2013-12-16 Mon 01:56>
:END:
#+BEGIN_SRC elisp
(org-pm-make-default-project-plist)
#+END_SRC

#+BEGIN_SRC elisp
(org-pm-make-file-projects)
#+END_SRC
#+RESULTS:
| project2    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project2    | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :more      |               123 |                           |                     |         |     |
| project1    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project1    | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :the_title | (with many types) | :title_with_one_type_only | but some contents\n | :title2 | nil |
| Project 323 | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | Project 323 | :node-id | 2260C2D9-268F-4A0B-8F02-BD70445988A1 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org |            |                   |                           |                     |         |     |


* Useful links - doc
:PROPERTIES:
:DATE:     <2013-12-16 Mon 00:58>
:END:
[[file:org-publish-meta.org::#2C1A8D6A-7A07-4825-9557-D8026FCD3377][Publishing principles, specification, options, format + feature considerations]]

see http://orgmode.org/manual/Using-the-mapping-API.html#Using-the-mapping-API
and http://orgmode.org/manual/Matching-tags-and-properties.html



* UNDERWAY Step 3: Try publishing a project with default properties

Under construction

TODO: review [[id:7FA277CA-8253-4BFB-9574-32D29E505BE0][this]] and make new function as described in code below,
I mean function org-pm-node-get-project-config.

Draft of all steps: 

    ;; Get project config from node 
    ;; If it exists here, then ALWAYS reinitialize it to update edited changes

    ;; if no config was found, then: 
    ;; get the name of the project from the file header
    ;; if not found, provide project name from file name
    ;; try to find project config from project alist
    ;; if not found, then create default project with the given project name. 


    ;; Get project configs of all nodes in project
    ;; Get file config of file
    ;; Get file configs of all nodes in project
    ;; Resolve inheritances
    ;; Resolve subfile-ignores
    ;; Build list of projects contained in file project config
    ;; and in the configs of all nodes in this file
    ;; For all projects in the list of projects, 
    ;; publish project.

#+BEGIN_SRC elisp
  
  ;;; ;;;;;;;;;;; NOT DONE YET ;;;;;;;;;;;;;;;;;;;;;
  
  (defun org-pm-publish ()
    "Create all project files for this file and then publish them."
    (interactive)
    (org-pm-load-project-configs)
    ;; here insert save-excursion etc.
    ;; 
    ;; !!!!!!!!!! save-excursion.
    ;; For the rest of this function.
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (let* 
        ;; Build list of all projects defined in this file
        ((projects (org-pm-get-file-project-defs))
         (file-project (assoc (buffer-file-name) projects)))
      ;; if no config was found, then: 
      ;; get the name of the project from the file header
      ;; if not found, provide project name
      ;; try to find project config from project alist
      ;; if not found, then create default project with the given project name. 
  
      ;; must rework this into new function: 
      ;; org-pm-get-file-project-config
      ;; this function gets the config for this file from scratch.
      ;; Do this by combining the code below with the code in
      ;; org-pm-make-default project.
      ;; link for this is given above.
         
      (unless project-config
        (let ((project-name (org-pm-get-project-name)))
          (setq project-config (assoc project-name org-publish-project-alist))
          (unless project-config
            (setq project-config (org-pm-default-project-config project-name)))
          )
        )
  
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; following go to org-pm-get-file-project-defs
      ;; Get private configs of all nodes in project
      
      (org-pm-get-node-configs)
      ;; Get file config of file
      
      (org-pm-get-file-params)
      ;; Get file configs of all nodes in project
      
      (org-pm-get-node-params)
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
      ;; Resolve inheritances
      (org-pm-process-subproject-configs)
  
      ;; Resolve subfile-ignores
      (org-pm-make-subprocess-ignores)
  
      ;; For all projects in the list of projects, 
      ;; publish project.
      
      (dolist (project projects)
        (org-publish project))
      
  )
#+END_SRC

* Finding nodes that have a tag matching with wildcard "_*_"
:PROPERTIES:
:DATE:     <2013-12-06 Fri 23:23>
:END:

Note: This will insert as many copies of a nodes' entry plist as there are tags in that entry which both begin with _ and end with _. 

To insert only one entry, use the dolist to return true if a match is found, and then cons the plist. 

Alternatively, modify this form to return a list of a-lists with the tag followed by the plist.  This could be useful to copy a node to multiple projects specified by multiple tags.

#+BEGIN_SRC elisp
  (let (matched-entries (wildcard "^_.*_$"))
   (org-map-entries 
    '(let* 
         ((props (cadr (org-element-at-point))))
       (dolist 
           (tag (plist-get props :tags))
         (if (string-match wildcard tag) 
             (setq matched-entries (cons props matched-entries)))))
    )
   matched-entries)
#+END_SRC

* Options for org-pm-dispatch top level function dispatcher
:PROPERTIES:
:DATE:     <2013-12-04 Wed 20:12>
:END:

The interactive command function org-pm-dispatch will open a dispatcher modeled after that of function org-export-dispatch.  

When called with an argument (C-u prefix), the function will automatically publish the related projects when done.  Otherwise it will just create project configs and copy the parts of org files concerned.  The options of the dispatcher refer to which files and which parts of files should be processed and copied to projects.  The options are: 

- f :: file of current buffer and all nodes that belong to the project of this file only
- a :: file of current buffer and all nodes it contains (also those belonging to other projects)
- n :: current node and its subnodes only
- p :: all files belonging to the project that the file of the current buffer belongs to. 
- * :: all files of all projects
* getting the project definition from a node
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

** Getting, content properties, description drawer (for copying to publication file)
:PROPERTIES:
:DATE:     <2013-12-05 Thu 01:44>
:END:

#+BEGIN_SRC elisp
        (org-map-entries 
           '(let (
                  (props (cadr  (org-element-at-point)))
                  (descr-start 
                   (re-search-forward "^:DESCRIPTION:" (plist-get props :contents-end)))
                  (descr-end
                   (re-search-forward "^:END:" (plist-get props :contents-end))))
              (setq 
               props
               (plist-put 
                props 
                :contents 
                (buffer-substring 
                 (plist-get props :contents-begin)
                 (plist-get props :contents-end)))
                    )
              (if (and descr-start descr-end)
                  (setq props
                        (plist-put 
                         props :description 
                         (buffer-substring (+ 1 descr-start) (- descr-end 6))))
                )
              props)
           "project_config"
           )
#+END_SRC
* Proj def test dummy supernode 1                           :PROJECT_CONFIGS:
* Proj def test dummy supernode 2                           :PROJECT_CONFIGS:
** Project 323
:PROPERTIES:
:ID:       5762DFE3-831A-42DD-B2C4-137F68B8D711
:END:
xonwrwan


* TESTS

#+BEGIN_SRC elisp
(org-pm-make-file-projects)
#+END_SRC

#+RESULTS:
| Project 323 | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | Project 323 | :node-id | 5762DFE3-831A-42DD-B2C4-137F68B8D711 | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org |            |                   |                           |                     |         |     |
| project2    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project2    | :node-id | 5853E3D5-82E5-4CCF-89A5-A53E0BC8281B | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :more      |               123 |                           |                     |         |     |
| project1    | :base-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/org | :base-extension | org | :publishing-directory | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/html | :recursive | t | :publishing-function | org-publish-org-to-html | :headline-levels | 5 | :auto-preamble | t | :project-name | project1    | :node-id | 5853E3D5-82E5-4CCF-89A5-A53E0BC8281B | :node-filename | /Users/iani2/Documents/Dev/Emacs/org-publish-meta/step-by-step.org | :the_title | (with many types) | :title_with_one_type_only | but some contents\n | :title2 | nil |

